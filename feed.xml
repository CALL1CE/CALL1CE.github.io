<feed xmlns="http://www.w3.org/2005/Atom"> <id>/</id><title>CALL1CE</title><subtitle>这是通过Chirpy主题配置而成的</subtitle> <updated>2024-07-02T13:40:45+00:00</updated> <author> <name>CALL1CE</name> <uri>/</uri> </author><link rel="self" type="application/atom+xml" href="/feed.xml"/><link rel="alternate" type="text/html" hreflang="zh-CN" href="/"/> <generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator> <rights> © 2024 CALL1CE </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>GPU硬件架构、运行机制</title><link href="/posts/GPU%E7%A1%AC%E4%BB%B6%E6%9E%B6%E6%9E%84-%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/" rel="alternate" type="text/html" title="GPU硬件架构、运行机制" /><published>2024-06-29T06:55:00+00:00</published> <updated>2024-06-29T06:55:00+00:00</updated> <id>/posts/GPU%E7%A1%AC%E4%BB%B6%E6%9E%B6%E6%9E%84-%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/</id> <content src="/posts/GPU%E7%A1%AC%E4%BB%B6%E6%9E%B6%E6%9E%84-%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/" /> <author> <name>{"name"=>"CALL1CE", "link"=>"https://space.bilibili.com/9330604"}</name> </author> <category term="Computer Graphics" /> <category term="HardWare" /> <summary> 1、GPU是如何与CPU协调工作的？ 将主存的处理数据复制到显存中 CPU指令驱动GPU GPU中的每个运算单元并行处理。此步会从显存存取数据 GPU将显存结果传回主存 2、GPU也有缓存机制吗？有几层？它们的速度差异多少？ 部分架构的GPU与CPU类似，也有多级缓存结构：寄存器、L1缓存、L2缓存、GPU显存、系统显存 存储类型 寄存器 共享内存 L1缓存 L2缓存 纹理、常量缓存 全局内存 访问周期 1 1~32 1~32 32~64 400~600 400~600 由此可见，shader直接访问寄... </summary> </entry> <entry><title>GAMES105-Lecture 03 Character Kinematics</title><link href="/posts/GAMES105-Lecture-03-Character-Kinematics/" rel="alternate" type="text/html" title="GAMES105-Lecture 03 Character Kinematics" /><published>2024-04-20T06:55:00+00:00</published> <updated>2024-04-20T07:23:21+00:00</updated> <id>/posts/GAMES105-Lecture-03-Character-Kinematics/</id> <content src="/posts/GAMES105-Lecture-03-Character-Kinematics/" /> <author> <name>{"name"=>"CALL1CE", "link"=>"https://space.bilibili.com/9330604"}</name> </author> <category term="Computer Graphics" /> <category term="GAMES105" /> <summary> PPT 由于PPT内容非常非常丰富，博客里只贴几张最重要的，还有很多重要的还是直接去ppt里看吧 本章节ppt地址 Character Kinematics Skeleton 围绕joint旋转 joint之间叫body、bone、link Kinematics of Chain 正向运动学：每个关节局部坐标系的方向等价于夫关节的局部坐标系的方向乘以当前坐标系的旋转 Q就是每个关节局部坐标系的一个朝向 每个关节有一个局部坐标系，当Q0关节发生旋转，会带动后面所有关节旋转，此时Q1相对于Q0局部坐标系的相对位置是不会改变的，如果要计算Q1局部坐标系原点在世界坐标系的位置，等价于做一个变换，将相对于Q0局部坐标系下的位置转换到世界坐标系 Kinematics of a Character 可以把角色建模为由多个链条连接到同... </summary> </entry> <entry><title>GAMES105-Lecture 02 Math Background</title><link href="/posts/GAMES105-Lecture-02-Math-Background/" rel="alternate" type="text/html" title="GAMES105-Lecture 02 Math Background" /><published>2024-03-29T10:30:00+00:00</published> <updated>2024-04-20T07:23:21+00:00</updated> <id>/posts/GAMES105-Lecture-02-Math-Background/</id> <content src="/posts/GAMES105-Lecture-02-Math-Background/" /> <author> <name>{"name"=>"CALL1CE", "link"=>"https://space.bilibili.com/9330604"}</name> </author> <category term="Computer Graphics" /> <category term="GAMES105" /> <summary> pdf地址：Math Background Matrix Representations of 3D Rotation 对于旋转矩阵，因为是正交阵，所以旋转矩阵乘它的转置是单位阵，能得到6个式子，但有9个参数，所以自由度是3 因为旋转矩阵的行列式是+1，引入了一些约束，但只是让解空间从两瓣变成一瓣，并没有改变自由度 Interpolation 平移的插值可以由线性插值解决 但是旋转插值不能简单地由线性插值表示 好的旋转插值： 希望在每一时刻的旋转是合法的（不会变形） 旋转是以一个常数的速度进行插值（速度不会乱变） 旋转矩阵 难以构造 容易应用旋转 难以插值 欧拉角 两种公约：一是沿着局部坐标系的xyz轴... </summary> </entry> <entry><title>GAMES105-Lecture 01 Introduction to Character Animation</title><link href="/posts/GAMES105-Lecture-01-Introduction-to-Character-Animation/" rel="alternate" type="text/html" title="GAMES105-Lecture 01 Introduction to Character Animation" /><published>2024-03-28T10:30:00+00:00</published> <updated>2024-03-29T08:41:46+00:00</updated> <id>/posts/GAMES105-Lecture-01-Introduction-to-Character-Animation/</id> <content src="/posts/GAMES105-Lecture-01-Introduction-to-Character-Animation/" /> <author> <name>{"name"=>"CALL1CE", "link"=>"https://space.bilibili.com/9330604"}</name> </author> <category term="Computer Graphics" /> <category term="GAMES105" /> <summary> pdf地址：Introduction to Character Animation 3D Computer Animation Simulation: rigid bodies,deformable solids,ropes, thin shells, cloth,fluid, smoke, sound…Phenomenon Character Animation: humans, animals,virtual creatures,hands, robots,crowds…Behavior 一般一个角色只有二三十个关节数，50到100+参数 把劳动密集型的民工活-&amp;gt; 计算密集型的计算机活 Character Animation Pipeline Forward Kinematics Inverse Kinematics Inte... </summary> </entry> <entry><title>C++高级特性和性能优化</title><link href="/posts/C++%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E5%92%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" rel="alternate" type="text/html" title="C++高级特性和性能优化" /><published>2024-03-27T07:32:00+00:00</published> <updated>2024-03-27T07:32:00+00:00</updated> <id>/posts/C++%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E5%92%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</id> <content src="/posts/C++%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E5%92%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" /> <author> <name>{"name"=>"CALL1CE", "link"=>"https://space.bilibili.com/9330604"}</name> </author> <category term="C++" /> <summary> 移动语义(C++11) 编译器通过”移动“资源而不是复制它们，来优化临时对象和处理大型的数据结构 两个关键概念： 移动构造函数：参数是右值引用(&amp;amp;&amp;amp;表示)，移动后，源对象通常处于有效但未指定的状态，也就是说这个对象的生命周期还没有结束，它仍然可以被赋予新的资源，或者被销毁，如果对象的生命周期结束，它的析构函数会被调用 移动赋值运算符：类似移动构造函数，不过是把括号换成了等号 对比值语义，值语义也就是复制资源再赋值，是内置类型(int float double…)的默认行为 RVO与移动区别： MyClass b = MyClass(); 这行代码实际上涉及到了一个叫做“返回值优化”（Return Value Optimization，RVO）的编译器优化技术，而不是移动操作。为... </summary> </entry> </feed>
