<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.3.3" /><meta property="og:title" content="GAMES101-Lecture 14 Ray Tracing 2(Acceleration &amp; Radiometry) &amp; 作业6" /><meta name="author" content="CALL1CE" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="Using AABBs to accelerate ray tracing" /><meta property="og:description" content="Using AABBs to accelerate ray tracing" /><link rel="canonical" href="/posts/GAMES101-Lecture-14-Ray-Tracing-2-&-%E4%BD%9C%E4%B8%9A6/" /><meta property="og:url" content="/posts/GAMES101-Lecture-14-Ray-Tracing-2-&-%E4%BD%9C%E4%B8%9A6/" /><meta property="og:site_name" content="CALL1CE" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-07-07T06:32:00+00:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="GAMES101-Lecture 14 Ray Tracing 2(Acceleration &amp; Radiometry) &amp; 作业6" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"CALL1CE"},"dateModified":"2023-07-22T06:20:48+00:00","datePublished":"2023-07-07T06:32:00+00:00","description":"Using AABBs to accelerate ray tracing","headline":"GAMES101-Lecture 14 Ray Tracing 2(Acceleration &amp; Radiometry) &amp; 作业6","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/GAMES101-Lecture-14-Ray-Tracing-2-&-%E4%BD%9C%E4%B8%9A6/"},"url":"/posts/GAMES101-Lecture-14-Ray-Tracing-2-&-%E4%BD%9C%E4%B8%9A6/"}</script><title>GAMES101-Lecture 14 Ray Tracing 2(Acceleration & Radiometry) & 作业6 | CALL1CE</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="CALL1CE"><meta name="application-name" content="CALL1CE"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener('change', () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.notify(); } /* flipMode() */ } /* ModeToggle */ const modeToggle = new ModeToggle(); </script><body data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/config/CALL1CE.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title"> <a href="/">CALL1CE</a></div><div class="site-subtitle font-italic">一位正在练习敲代码的OW2玩家</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/CALL1CE" aria-label="github" target="_blank" rel="noopener noreferrer"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/" aria-label="twitter" target="_blank" rel="noopener noreferrer"> <i class="fab fa-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['563638083','qq.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>GAMES101-Lecture 14 Ray Tracing 2(Acceleration & Radiometry) & 作业6</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> </span> <span id="search-cancel" >取消</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>GAMES101-Lecture 14 Ray Tracing 2(Acceleration & Radiometry) & 作业6</h1><div class="post-meta text-muted"> <span> 发表于 <em class="" data-ts="1688711520" data-df="YYYY/MM/DD" data-toggle="tooltip" data-placement="bottom"> 2023/07/07 </em> </span> <span> 更新于 <em class="" data-ts="1690006848" data-df="YYYY/MM/DD" data-toggle="tooltip" data-placement="bottom"> 2023/07/22 </em> </span><div class="d-flex justify-content-between"> <span> 作者 <em> <a href=""></a> </em>, <em> <a href=""></a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="4124 字"> <em>22 分钟</em>阅读</span></div></div></div><div class="post-content"><h2 id="using-aabbs-to-accelerate-ray-tracing"><span class="mr-2">Using AABBs to accelerate ray tracing</span><a href="#using-aabbs-to-accelerate-ray-tracing" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="uniform-grids"><span class="mr-2">Uniform grids</span><a href="#uniform-grids" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><p>主旨：多做光线与盒子求交</p><li><p>先把场景的BB框住，然后在BB里创建格子</p><li><p>记录每个有物体（表面）存在的格子(下图中右上角少画了一个格子)</p></ul><p><a href="https://imgse.com/i/pCcSay4" class="img-link shimmer" ><img data-src="https://s1.ax1x.com/2023/07/07/pCcSay4.jpg" alt="pCcSay4.jpg" class="lazyload" data-proofer-ignore></a></p><ul><li><p>判断跟光线相交的格子里有没有物体</p><li><p>如果有物体，那么说明光线可能和该物体相交，就计算交点</p><li><p>在光线的发射过程中（对于图中的光线），只需判断当前格子的上方和右方是否为光线下一个相交的格子</p></ul><p><a href="https://imgse.com/i/pCcpPpT" class="img-link shimmer" ><img data-src="https://s1.ax1x.com/2023/07/07/pCcpPpT.jpg" alt="pCcpPpT.jpg" class="lazyload" data-proofer-ignore></a></p><h3 id="grid-resolution"><span class="mr-2">Grid Resolution</span><a href="#grid-resolution" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>不能太稀疏（比如1*1*1的格子，相当于没做BBAA），也不能太密集，不然和格子也求交太多次，所以要有一个均衡</ul><p><a href="https://imgse.com/i/pCcplcD" class="img-link shimmer" ><img data-src="https://s1.ax1x.com/2023/07/07/pCcplcD.jpg" alt="pCcplcD.jpg" class="lazyload" data-proofer-ignore></a></p><ul><li>BBAA适合比较均匀的场景，不适合有大片空区域的场景，会产生“Teapot in a stadium”问题</ul><h3 id="spatial-partitions空间划分"><span class="mr-2">Spatial partitions(空间划分)</span><a href="#spatial-partitions空间划分" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><p>基于格子的不足之处进行优化，在物体分布稀疏的地方格子大一点，，分布密集的地方格子小一点</p><li><p>八叉树（Oct-Tree），对空间切三刀，然后如果某个小空间中物体比较多，继续切，直到空间内没物体或者物体数量差不多了，但维度再高的话，就是$2^n$叉树，这显然不好（我认为老师意思是说这么切下去还是切太多了），为解决这个问题，KD-Tree应运而生</p><li><p>KD-Tree：每次砍一刀，然后再根据情况在分出的一个空间内再砍一刀，这样就类似二叉树，每次水平一刀，竖直一刀，这样划分的相对均匀一点</p><li><p>BSP-Tree：不是横平竖直地砍，所以比较复杂</p></ul><p><a href="https://imgse.com/i/pCcF9Qf" class="img-link shimmer" ><img data-src="https://s1.ax1x.com/2023/07/07/pCcF9Qf.jpg" alt="pCcF9Qf.jpg" class="lazyload" data-proofer-ignore></a></p><h3 id="kd-tree-pre-processing"><span class="mr-2">KD-Tree Pre-Processing</span><a href="#kd-tree-pre-processing" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>在做光追之前提前划分好，在中间节点记录它之后划分了什么样的格子，在叶子节点来实际存储和格子相交的物体（三角形）</ul><p><a href="https://imgse.com/i/pCcFdOO" class="img-link shimmer" ><img data-src="https://s1.ax1x.com/2023/07/07/pCcFdOO.jpg" alt="pCcFdOO.jpg" class="lazyload" data-proofer-ignore></a></p><ul><li><p>首先，光线和整个BBAA*（A)有交点，那么对于子节点（也就是1和B）都判断是否有交点</p><li><p>都相交，但1也就到此为止，去计算1中所有物体是否与光线相交，然后去计算B的子节点2和C</p><li><p>还是都相交，但2也到此为止，去计算2中所有物体是否与光线相交，然后去计算C的子节点3和D</p><li><p>还是都相交，继续算</p><li><p>到4和5，其中5是没有交点的，所以就不计算了</p><li><p>有几个问题：</p><ul><li><p>如何判断包围盒的格子到底和哪些三角形相交，这个问题比较困难处理</p><li><p>一个物体与多个包围盒相交，也就是多个叶子节点都要储存该物体</p></ul></ul><h3 id="object-partitions--bounding-volume-hierarchybvh"><span class="mr-2">Object Partitions &amp; Bounding Volume Hierarchy(BVH)</span><a href="#object-partitions--bounding-volume-hierarchybvh" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><p>解决了KD-Tree的两个问题，既不用求交，而且一个三角形不会与多个包围盒相交，只会存在一个包围盒中</p><li><p>但问题是包围盒有可能相交，怎么划分很讲究</p></ul><p><a href="https://imgse.com/i/pCc3MX4" class="img-link shimmer" ><img data-src="https://s1.ax1x.com/2023/07/07/pCc3MX4.jpg" alt="pCc3MX4.jpg" class="lazyload" data-proofer-ignore></a></p><ul><li><p>怎样区分一个节点：</p><ul><li><p>选择一个维度去划分（x、y、z轴）</p><li><p>总是沿着最长的轴去切</p><li><p>区分节点（切）的时候，从中间物体的位置切，快速找出中位数，使用快速选择算法，只需要O(n)的复杂度</p></ul><li><p>如果是动态场景，就需要重新计算BVH了</p><li><p>BVH伪代码：</p></ul><p><a href="https://imgse.com/i/pCc8pU1" class="img-link shimmer" ><img data-src="https://s1.ax1x.com/2023/07/07/pCc8pU1.jpg" alt="pCc8pU1.jpg" class="lazyload" data-proofer-ignore></a></p><h3 id="spatial-vs-object-partitions"><span class="mr-2">Spatial VS Object Partitions</span><a href="#spatial-vs-object-partitions" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><p>空间划分和物体划分的区别</p><li><p>空间：</p><ul><li><p>划分了不重叠的空间区域</p><li><p>一个物体可能会被包含在多个空间中</p></ul><li><p>物体：</p><ul><li><p>物体被划分到不同的子集中</p><li><p>包围盒可能会重叠</p></ul></ul><h2 id="basic-radiometry-辐射度量学"><span class="mr-2">Basic radiometry (辐射度量学)</span><a href="#basic-radiometry-辐射度量学" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="motivation"><span class="mr-2">Motivation</span><a href="#motivation" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><p>为光赋予物理意义</p><li><p>定义了一些列的方法和单位来描述光照</p><li><p>准确计量光在空间中的各种属性</p><ul><li><p>Radiant flux：光通量，单位时间内通过的光总量，单位watt或者lumen（lm）</p><li><p>intensity：光强，单位立方角光通量，单位Watt/steradians，也就是candelas</p><li><p>irradiance：辉度，单位面积光通量，瓦特/平方米</p><li><p>radiance：光亮度</p></ul></ul><h3 id="radiant-energy-and-fluxpower"><span class="mr-2">Radiant Energy and Flux(Power)</span><a href="#radiant-energy-and-fluxpower" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><a href="https://imgse.com/i/pCcJ91K" class="img-link shimmer" ><img data-src="https://s1.ax1x.com/2023/07/07/pCcJ91K.jpg" alt="pCcJ91K.jpg" class="lazyload" data-proofer-ignore></a></p><ul><li><p>Radiant Energy：可以理解为光的能量，单位是焦耳</p><li><p>Radiant Flux(power)：单位时间的能量，单位是瓦特</p><li><p>Flux（另外一种解释）：光打到一个感光的平面，单位时间内通过的光子的数量</p></ul><p><a href="https://imgse.com/i/pCcJC6O" class="img-link shimmer" ><img data-src="https://s1.ax1x.com/2023/07/07/pCcJC6O.jpg" alt="pCcJC6O.jpg" class="lazyload" data-proofer-ignore></a></p><h3 id="important-light-measurements-of-interest"><span class="mr-2">Important Light Measurements of Interest</span><a href="#important-light-measurements-of-interest" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><a href="https://imgse.com/i/pCcJRgK" class="img-link shimmer" ><img data-src="https://s1.ax1x.com/2023/07/07/pCcJRgK.jpg" alt="pCcJRgK.jpg" class="lazyload" data-proofer-ignore></a></p><ul><li><p>Radiant Intensity：光源散发的光</p><li><p>irradiance：一个平面接收的光</p><li><p>radiance：在传播中的光</p></ul><h3 id="radiant-intensity"><span class="mr-2">Radiant Intensity</span><a href="#radiant-intensity" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>单位立体角的能量</ul><p><a href="https://imgse.com/i/pCcJ4De" class="img-link shimmer" ><img data-src="https://s1.ax1x.com/2023/07/07/pCcJ4De.jpg" alt="pCcJ4De.jpg" class="lazyload" data-proofer-ignore></a></p><ul><li><p>二维中角度一般指弧度，单位是radians</p><li><p>三维中立体角：球上一块面积除以半径的平方，球有$4\pi$的立体角，单位是steradians</p></ul><p><a href="https://imgse.com/i/pCcYZb4" class="img-link shimmer" ><img data-src="https://s1.ax1x.com/2023/07/07/pCcYZb4.jpg" alt="pCcYZb4.jpg" class="lazyload" data-proofer-ignore></a></p><ul><li>单位立体角/微分立体角：微分面积/半径平方</ul><p><a href="https://imgse.com/i/pCcYfGq" class="img-link shimmer" ><img data-src="https://s1.ax1x.com/2023/07/07/pCcYfGq.jpg" alt="pCcYfGq.jpg" class="lazyload" data-proofer-ignore></a></p><ul><li>之后会用单位立体角w来表示一个单位向量</ul><p><a href="https://imgse.com/i/pCcY4zV" class="img-link shimmer" ><img data-src="https://s1.ax1x.com/2023/07/07/pCcY4zV.jpg" alt="pCcY4zV.jpg" class="lazyload" data-proofer-ignore></a></p><ul><li>Radiant Intensity就是单位立体角的能量</ul><p><a href="https://imgse.com/i/pCcYIMT" class="img-link shimmer" ><img data-src="https://s1.ax1x.com/2023/07/07/pCcYIMT.jpg" alt="pCcYIMT.jpg" class="lazyload" data-proofer-ignore></a></p><h2 id="作业6"><span class="mr-2">作业6</span><a href="#作业6" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>    在之前的编程练习中，我们实现了基础的光线追踪算法，具体而言是光线传</p><p>输、光线与三角形求交。我们采用了这样的方法寻找光线与场景的交点：遍历场景</p><p>中的所有物体，判断光线是否与它相交。在场景中的物体数量不大时，该做法可以</p><p>取得良好的结果，但当物体数量增多、模型变得更加复杂，该做法将会变得非常低</p><p>效。因此，我们需要加速结构来加速求交过程。在本次练习中，我们重点关注物体</p><p>划分算法 Bounding Volume Hierarchy (BVH)。本练习要求你实现 Ray-Bounding</p><p>Volume 求交与 BVH 查找。</p><p>    首先，你需要从上一次编程练习中引用以下函数：</p><ul><li><p>Render() in Renderer.cpp: 将你的光线生成过程粘贴到此处，并且按照新框架更新相应调用的格式。</p><li><p>Triangle::getIntersection in Triangle.hpp: 将你的光线-三角形相交函数粘贴到此处，并且按照新框架更新相应相交信息的格式。</p></ul><p>    在本次编程练习中，你需要实现以下函数：</p><ul><li><p>IntersectP(const Ray&amp; ray, const Vector3f&amp; invDir,const std::array&lt;int, 3&gt;&amp; dirIsNeg) in the Bounds3.hpp: 这个函数的作用是判断包围盒 BoundingBox 与光线是否相交，你需要按照课程介绍的算法实现求交过程。</p><li><p>getIntersection(BVHBuildNode* node, const Ray ray)in BVH.cpp: 建立 BVH 之后，我们可以用它加速求交过程。该过程递归进行，你将在其中调用你实现的 Bounds3::IntersectP</p></ul><h3 id="render函数"><span class="mr-2">Render()函数</span><a href="#render函数" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><p>其实render函数已经写的差不多了，计算投射的光线已经算出来了，只需要再写一行代码调用函数即可，需要调用的是Scene类的castRay函数，与上一次作业不同，这次作业的形参做了修改，需要直接传入ray对象，至于深度depth，不用管，就是记录个射线的弹射次数，填0即可</p><li><p><code class="language-plaintext highlighter-rouge">framebuffer[m++] = scene.castRay(ray, 0);</code>，加这行代码即可，完整代码如下：</p></ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="n">Renderer</span><span class="o">::</span><span class="n">Render</span><span class="p">(</span><span class="k">const</span> <span class="n">Scene</span><span class="o">&amp;</span> <span class="n">scene</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Vector3f</span><span class="o">&gt;</span> <span class="n">framebuffer</span><span class="p">(</span><span class="n">scene</span><span class="p">.</span><span class="n">width</span> <span class="o">*</span> <span class="n">scene</span><span class="p">.</span><span class="n">height</span><span class="p">);</span>

    <span class="kt">float</span> <span class="n">scale</span> <span class="o">=</span> <span class="n">tan</span><span class="p">(</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">scene</span><span class="p">.</span><span class="n">fov</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">));</span>
    <span class="kt">float</span> <span class="n">imageAspectRatio</span> <span class="o">=</span> <span class="n">scene</span><span class="p">.</span><span class="n">width</span> <span class="o">/</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">scene</span><span class="p">.</span><span class="n">height</span><span class="p">;</span>
    <span class="n">Vector3f</span> <span class="n">eye_pos</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">scene</span><span class="p">.</span><span class="n">height</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">scene</span><span class="p">.</span><span class="n">width</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// generate primary ray direction</span>
            <span class="kt">float</span> <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">scene</span><span class="p">.</span><span class="n">width</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span>
                      <span class="n">imageAspectRatio</span> <span class="o">*</span> <span class="n">scale</span><span class="p">;</span>
            <span class="kt">float</span> <span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">scene</span><span class="p">.</span><span class="n">height</span><span class="p">)</span> <span class="o">*</span> <span class="n">scale</span><span class="p">;</span>
            <span class="c1">// TODO: Find the x and y positions of the current pixel to get the</span>
            <span class="c1">// direction</span>
            <span class="c1">//  vector that passes through it.</span>
            <span class="c1">// Also, don't forget to multiply both of them with the variable</span>
            <span class="c1">// *scale*, and x (horizontal) variable with the *imageAspectRatio*</span>

            <span class="c1">// Don't forget to normalize this direction!</span>

            <span class="n">Vector3f</span> <span class="n">dir</span> <span class="o">=</span> <span class="n">Vector3f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// Don't forget to normalize this direction!</span>
            <span class="n">dir</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">dir</span><span class="p">);</span>
            <span class="n">Ray</span> <span class="n">ray</span><span class="p">(</span><span class="n">eye_pos</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>
            <span class="n">framebuffer</span><span class="p">[</span><span class="n">m</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">scene</span><span class="p">.</span><span class="n">castRay</span><span class="p">(</span><span class="n">ray</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">UpdateProgress</span><span class="p">(</span><span class="n">j</span> <span class="o">/</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">scene</span><span class="p">.</span><span class="n">height</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">UpdateProgress</span><span class="p">(</span><span class="mf">1.</span><span class="n">f</span><span class="p">);</span>

    <span class="c1">// save framebuffer to file</span>
    <span class="kt">FILE</span><span class="o">*</span> <span class="n">fp</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="s">"binary.ppm"</span><span class="p">,</span> <span class="s">"wb"</span><span class="p">);</span>
    <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">fprintf</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="s">"P6</span><span class="se">\n</span><span class="s">%d %d</span><span class="se">\n</span><span class="s">255</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">scene</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">scene</span><span class="p">.</span><span class="n">height</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">scene</span><span class="p">.</span><span class="n">height</span> <span class="o">*</span> <span class="n">scene</span><span class="p">.</span><span class="n">width</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">color</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
        <span class="n">color</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)(</span><span class="mi">255</span> <span class="o">*</span> <span class="n">clamp</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">framebuffer</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">x</span><span class="p">));</span>
        <span class="n">color</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)(</span><span class="mi">255</span> <span class="o">*</span> <span class="n">clamp</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">framebuffer</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">y</span><span class="p">));</span>
        <span class="n">color</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)(</span><span class="mi">255</span> <span class="o">*</span> <span class="n">clamp</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">framebuffer</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">z</span><span class="p">));</span>
        <span class="n">fwrite</span><span class="p">(</span><span class="n">color</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">fclose</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>    
<span class="p">}</span>
</pre></table></code></div></div><h3 id="trianglegetintersection函数"><span class="mr-2">Triangle::getIntersection函数</span><a href="#trianglegetintersection函数" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>这个部分说难吧也不难，说简单吧，倒也不好想，基本的算法已经是算完了，主要就是把算好的内容返回，那么返回的是一个Intersection对象，所以就需要了解下Intersection类，需要根据这个函数的计算结果来创建好要返回的Intersection对象，完整代码如下：</ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre><td class="rouge-code"><pre><span class="kr">inline</span> <span class="n">Intersection</span> <span class="n">Triangle</span><span class="o">::</span><span class="n">getIntersection</span><span class="p">(</span><span class="n">Ray</span> <span class="n">ray</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Intersection</span> <span class="n">inter</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">dotProduct</span><span class="p">(</span><span class="n">ray</span><span class="p">.</span><span class="n">direction</span><span class="p">,</span> <span class="n">normal</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">inter</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">t_tmp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">//下面的代码已经是Moller Trumbore Algorithm了</span>
    <span class="n">Vector3f</span> <span class="n">pvec</span> <span class="o">=</span> <span class="n">crossProduct</span><span class="p">(</span><span class="n">ray</span><span class="p">.</span><span class="n">direction</span><span class="p">,</span> <span class="n">e2</span><span class="p">);</span><span class="c1">//该向量与三角形法线正交</span>
    <span class="kt">double</span> <span class="n">det</span> <span class="o">=</span> <span class="n">dotProduct</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">pvec</span><span class="p">);</span><span class="c1">//det 的几何意义是三角形两个边向量以及光线方向向量构成的三维矩阵的行列式。</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">fabs</span><span class="p">(</span><span class="n">det</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">EPSILON</span><span class="p">)</span><span class="c1">//如果det接近0，说明两个边向量接近平行,从而导致三角形面积接近0,即三角形退化为线段或点</span>
        <span class="k">return</span> <span class="n">inter</span><span class="p">;</span>

    <span class="kt">double</span> <span class="n">det_inv</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">det</span><span class="p">;</span>
    <span class="n">Vector3f</span> <span class="n">tvec</span> <span class="o">=</span> <span class="n">ray</span><span class="p">.</span><span class="n">origin</span> <span class="o">-</span> <span class="n">v0</span><span class="p">;</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">dotProduct</span><span class="p">(</span><span class="n">tvec</span><span class="p">,</span> <span class="n">pvec</span><span class="p">)</span> <span class="o">*</span> <span class="n">det_inv</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">u</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">u</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">inter</span><span class="p">;</span>
    <span class="n">Vector3f</span> <span class="n">qvec</span> <span class="o">=</span> <span class="n">crossProduct</span><span class="p">(</span><span class="n">tvec</span><span class="p">,</span> <span class="n">e1</span><span class="p">);</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">dotProduct</span><span class="p">(</span><span class="n">ray</span><span class="p">.</span><span class="n">direction</span><span class="p">,</span> <span class="n">qvec</span><span class="p">)</span> <span class="o">*</span> <span class="n">det_inv</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">u</span> <span class="o">+</span> <span class="n">v</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">inter</span><span class="p">;</span>
    <span class="n">t_tmp</span> <span class="o">=</span> <span class="n">dotProduct</span><span class="p">(</span><span class="n">e2</span><span class="p">,</span> <span class="n">qvec</span><span class="p">)</span> <span class="o">*</span> <span class="n">det_inv</span><span class="p">;</span>

    <span class="c1">// TODO find ray triangle intersection</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">t_tmp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="n">inter</span><span class="p">;</span>

    <span class="n">inter</span><span class="p">.</span><span class="n">happened</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span><span class="c1">//是否相交</span>
    <span class="n">inter</span><span class="p">.</span><span class="n">coords</span> <span class="o">=</span> <span class="n">ray</span><span class="p">(</span><span class="n">t_tmp</span><span class="p">);</span><span class="c1">//交点坐标</span>
    <span class="n">inter</span><span class="p">.</span><span class="n">normal</span> <span class="o">=</span> <span class="n">normal</span><span class="p">;</span><span class="c1">//交点处三角形法线</span>
    <span class="n">inter</span><span class="p">.</span><span class="n">distance</span> <span class="o">=</span> <span class="n">t_tmp</span><span class="p">;</span><span class="c1">//d</span>
    <span class="n">inter</span><span class="p">.</span><span class="n">obj</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span><span class="c1">//三角形</span>
    <span class="n">inter</span><span class="p">.</span><span class="n">m</span> <span class="o">=</span> <span class="n">m</span><span class="p">;</span><span class="c1">//交点处三角形的材质</span>

    <span class="k">return</span> <span class="n">inter</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="intersectp函数"><span class="mr-2">IntersectP函数</span><a href="#intersectp函数" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>其实这个就按课程上讲的过程来算就行了，算出光线进入时间和推出时间即可，我看有的博主使用vector相乘，规避了for循环，这点还是很不错的。有一个点让人比较费解，就是IntersectP函数的形参中有一个是<code class="language-plaintext highlighter-rouge">const std::array&lt;int, 3&gt;&amp; dirIsNeg</code> ，实际上我全程没用到这个函数。我的代码如下：</ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="kr">inline</span> <span class="kt">bool</span> <span class="n">Bounds3</span><span class="o">::</span><span class="n">IntersectP</span><span class="p">(</span><span class="k">const</span> <span class="n">Ray</span><span class="o">&amp;</span> <span class="n">ray</span><span class="p">,</span> <span class="k">const</span> <span class="n">Vector3f</span><span class="o">&amp;</span> <span class="n">invDir</span><span class="p">,</span>
                                <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">dirIsNeg</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="c1">// invDir: ray direction(x,y,z), invDir=(1.0/x,1.0/y,1.0/z), use this because Multiply is faster that Division</span>
    <span class="c1">// dirIsNeg: ray direction(x,y,z), dirIsNeg=[int(x&gt;0),int(y&gt;0),int(z&gt;0)], use this to simplify your logic</span>
    <span class="c1">// TODO test if ray bound intersects</span>
    <span class="kt">double</span> <span class="n">t_enter</span><span class="p">,</span> <span class="n">t_exit</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">t_min</span><span class="p">[</span><span class="mi">3</span><span class="p">]{},</span> <span class="n">t_max</span><span class="p">[</span><span class="mi">3</span><span class="p">]{};</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">t_min</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">((</span><span class="n">pMin</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">ray</span><span class="p">.</span><span class="n">origin</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="n">invDir</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="p">(</span><span class="n">pMax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">ray</span><span class="p">.</span><span class="n">origin</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="n">invDir</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="n">t_max</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">((</span><span class="n">pMin</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">ray</span><span class="p">.</span><span class="n">origin</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="n">invDir</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="p">(</span><span class="n">pMax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">ray</span><span class="p">.</span><span class="n">origin</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="n">invDir</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="n">t_enter</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">fmax</span><span class="p">(</span><span class="n">t_min</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">std</span><span class="o">::</span><span class="n">fmax</span><span class="p">(</span><span class="n">t_min</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">t_min</span><span class="p">[</span><span class="mi">2</span><span class="p">]));</span>
    <span class="n">t_exit</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">fmin</span><span class="p">(</span><span class="n">t_max</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">std</span><span class="o">::</span><span class="n">fmin</span><span class="p">(</span><span class="n">t_max</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">t_max</span><span class="p">[</span><span class="mi">2</span><span class="p">]));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">t_enter</span> <span class="o">&lt;</span> <span class="n">t_exit</span> <span class="o">&amp;&amp;</span> <span class="n">t_exit</span> <span class="o">&gt;=</span> <span class="mf">0.0</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h4 id="getintersection函数"><span class="mr-2">getIntersection函数</span><a href="#getintersection函数" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>这个函数就照着课程ppt的伪码来做就行了，有几点让人费解，就是上面说的参数，有一个我就没用，还有就是光线方向的倒数，这个直接在ray对象那取出来就好，不用自己算，我一开始还在想怎么算，万一除以个0该怎么处理，实际上在ray的构造函数里就自己算了，而且就是简单的除以，没考虑除以0的情况，呃呃。代码如下：</ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="n">Intersection</span> <span class="n">BVHAccel</span><span class="o">::</span><span class="n">getIntersection</span><span class="p">(</span><span class="n">BVHBuildNode</span><span class="o">*</span> <span class="n">node</span><span class="p">,</span> <span class="k">const</span> <span class="n">Ray</span><span class="o">&amp;</span> <span class="n">ray</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="c1">// TODO Traverse the BVH to find intersection</span>
    <span class="n">Intersection</span> <span class="n">inter</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node</span> <span class="o">||</span> <span class="o">!</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">bounds</span><span class="p">.</span><span class="n">IntersectP</span><span class="p">(</span><span class="n">ray</span><span class="p">,</span> <span class="n">ray</span><span class="p">.</span><span class="n">direction_inv</span><span class="p">,</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span> <span class="p">}))</span>
        <span class="k">return</span> <span class="n">inter</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">==</span> <span class="nb">nullptr</span> <span class="o">&amp;&amp;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">getIntersection</span><span class="p">(</span><span class="n">ray</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">Intersection</span> <span class="n">inter1</span> <span class="o">=</span> <span class="n">getIntersection</span><span class="p">(</span><span class="n">node</span> <span class="o">-&gt;</span> <span class="n">left</span><span class="p">,</span> <span class="n">ray</span><span class="p">);</span>
    <span class="n">Intersection</span> <span class="n">inter2</span> <span class="o">=</span> <span class="n">getIntersection</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">ray</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">inter1</span><span class="p">.</span><span class="n">distance</span> <span class="o">&lt;</span> <span class="n">inter2</span><span class="p">.</span><span class="n">distance</span> <span class="o">?</span> <span class="n">inter1</span> <span class="o">:</span> <span class="n">inter2</span><span class="p">;</span>

<span class="p">}</span>
</pre></table></code></div></div><p><a href="https://imgse.com/i/pCTD5PH" class="img-link shimmer" ><img data-src="https://s1.ax1x.com/2023/07/18/pCTD5PH.jpg" alt="pCTD5PH.jpg" class="lazyload" data-proofer-ignore></a></p><h3 id="提高题sah"><span class="mr-2">提高题：SAH</span><a href="#提高题sah" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><p>这个sah我搞了不少时间才弄懂，但就结果而言，提升并不是很高，具体过程我就不多赘述了，我挂两个我参考的链接，我在代码处有一些注释</p><li><p><a href="https://www.cnblogs.com/lookof/p/3546320.html">BVH with SAH (Bounding Volume Hierarchy with Surface Area Heuristic) - lookof - 博客园 (cnblogs.com)</a></p><li><p><a href="https://blog.csdn.net/qq_39300235/article/details/106999514#:~:text=%E8%A1%A8%E9%9D%A2%E7%A7%AF%E5%90%AF%E5%8F%91%E5%BC%8F%E6%B3%95%20%28The%20Surface%20Area%20Heuristic%29,%E8%AF%A5%E7%AE%97%E6%B3%95%E6%8F%90%E4%BE%9B%E4%BA%86%E6%89%8E%E5%AE%9E%E7%9A%84%E6%88%90%E6%9C%AC%E6%A8%A1%E5%9E%8B%E6%9D%A5%E4%BC%B0%E8%AE%A1%E4%BA%86%E5%93%AA%E4%B8%AA%E5%88%92%E5%88%86%E4%BD%8D%E7%BD%AE%E4%BC%9A%E5%AF%BC%E8%87%B4%E5%B0%84%E7%BA%BF%E5%92%8C%E5%9B%BE%E5%85%83%E7%9B%B8%E4%BA%A4%E6%9C%80%E4%B8%BA%E4%BE%BF%E5%AE%9C%E3%80%82.%20SAH%E6%A8%A1%E5%9E%8B%E4%BC%B0%E8%AE%A1%E6%89%A7%E8%A1%8C%E5%B0%84%E7%BA%BF%E7%9B%B8%E4%BA%A4%E6%B5%8B%E8%AF%95%E7%9A%84%E8%AE%A1%E7%AE%97%E6%88%90%E6%9C%AC%EF%BC%8C%E5%8C%85%E6%8B%AC%E9%81%8D%E5%8E%86%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E6%89%80%E8%8A%B1%E8%B4%B9%E7%9A%84%E6%97%B6%E9%97%B4%EF%BC%8C%E4%BB%A5%E5%8F%8A%E9%92%88%E5%AF%B9%E7%89%B9%E5%AE%9A%E5%9B%BE%E5%85%83%E5%88%86%E5%8C%BA%E7%9A%84%E5%B0%84%E7%BA%BF%E4%B8%8E%E5%9B%BE%E5%85%83%E7%9B%B8%E4%BA%A4%E6%B5%8B%E8%AF%95%E6%89%80%E8%8A%B1%E8%B4%B9%E7%9A%84%E6%97%B6%E9%97%B4%E3%80%82.%20%E7%84%B6%E5%90%8E%EF%BC%8C%E7%94%A8%E4%BA%8E%E6%9E%84%E5%BB%BA%E5%8A%A0%E9%80%9F%E7%BB%93%E6%9E%84%E7%9A%84%E7%AE%97%E6%B3%95%E4%BB%A5%E5%B0%86%E6%80%BB%E6%88%90%E6%9C%AC%E9%99%8D%E8%87%B3%E6%9C%80%E4%BD%8E%E4%B8%BA%E7%9B%AE%E6%A0%87%E3%80%82.%20%E9%80%9A%E5%B8%B8%EF%BC%8C%E4%BD%BF%E7%94%A8%E4%B8%80%E7%A7%8D%E8%B4%AA%E5%A9%AA%E7%AE%97%E6%B3%95%EF%BC%8C%E8%AF%A5%E7%AE%97%E6%B3%95%E5%8F%AF%E6%9C%80%E5%A4%A7%E7%A8%8B%E5%BA%A6%E5%9C%B0%E5%87%8F%E5%B0%91%E5%8D%95%E7%8B%AC%E6%9E%84%E5%BB%BA%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E4%B8%AD%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E6%88%90%E6%9C%AC%E3%80%82.%20SAH%E6%88%90%E6%9C%AC%E6%A8%A1%E5%9E%8B%E8%83%8C%E5%90%8E%E7%9A%84%E6%80%9D%E6%83%B3%E5%BE%88%E7%AE%80%E5%8D%95%EF%BC%8C%E5%AE%83%E6%9C%89%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95%E8%AE%A1%E7%AE%97%E3%80%82.">(23条消息) 光线求交加速算法：边界体积层次结构(Bounding Volume Hierarchies)2-表面积启发式法(The Surface Area Heuristic)_0小龙虾0的博客-CSDN博客</a></p></ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
</pre><td class="rouge-code"><pre><span class="n">BVHBuildNode</span><span class="o">*</span> <span class="n">BVHAccel</span><span class="o">::</span><span class="n">recursiveBuild</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">*&gt;</span> <span class="n">objects</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">BVHBuildNode</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BVHBuildNode</span><span class="p">();</span>

    <span class="c1">// Compute bounds of all primitives in BVH node</span>
    <span class="n">Bounds3</span> <span class="n">bounds</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">objects</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="n">Union</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="n">objects</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">getBounds</span><span class="p">());</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">objects</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Create leaf _BVHBuildNode_</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">bounds</span> <span class="o">=</span> <span class="n">objects</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">getBounds</span><span class="p">();</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">object</span> <span class="o">=</span> <span class="n">objects</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">objects</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">recursiveBuild</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="p">{</span><span class="n">objects</span><span class="p">[</span><span class="mi">0</span><span class="p">]});</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">recursiveBuild</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="p">{</span><span class="n">objects</span><span class="p">[</span><span class="mi">1</span><span class="p">]});</span>

        <span class="n">node</span><span class="o">-&gt;</span><span class="n">bounds</span> <span class="o">=</span> <span class="n">Union</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">bounds</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">-&gt;</span><span class="n">bounds</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">Bounds3</span> <span class="n">centroidBounds</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">objects</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
            <span class="n">centroidBounds</span> <span class="o">=</span>
                <span class="n">Union</span><span class="p">(</span><span class="n">centroidBounds</span><span class="p">,</span> <span class="n">objects</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">getBounds</span><span class="p">().</span><span class="n">Centroid</span><span class="p">());</span>
        <span class="kt">int</span> <span class="n">dim</span> <span class="o">=</span> <span class="n">centroidBounds</span><span class="p">.</span><span class="n">maxExtent</span><span class="p">();</span>
        <span class="n">SplitMethod</span> <span class="n">splitMethod</span> <span class="o">=</span> <span class="n">SplitMethod</span><span class="o">::</span><span class="n">NAIVE</span><span class="p">;</span>

        <span class="k">switch</span> <span class="p">(</span><span class="n">splitMethod</span><span class="p">)</span>
        <span class="p">{</span>

            <span class="k">case</span> <span class="n">SplitMethod</span><span class="o">::</span><span class="n">SAH</span> <span class="p">:</span>
            <span class="p">{</span>

                <span class="k">const</span> <span class="kt">int</span> <span class="n">nBuckets</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
                <span class="k">const</span> <span class="kt">float</span> <span class="n">SAHTravCost</span> <span class="o">=</span> <span class="mf">0.125</span><span class="n">f</span><span class="p">;</span><span class="c1">//遍历花费的时间成本</span>
                <span class="c1">//const float SAHInterCost = 1.f;//检查一个物体花费的时间成本,其实可以不算</span>
                <span class="n">BucketInfo</span> <span class="n">buckets</span><span class="p">[</span><span class="n">nBuckets</span><span class="p">];</span>
                <span class="c1">//遍历三角形，查看三角形的质心位于哪一个桶中</span>
                <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">objects</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="c1">//用来存当前图元也就是三角形质心位于几号桶中,dim是最松散的一个轴</span>
                    <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="n">nBuckets</span> <span class="o">*</span> <span class="n">centroidBounds</span><span class="p">.</span><span class="n">Offset</span><span class="p">(</span><span class="n">objects</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">getBounds</span><span class="p">().</span><span class="n">Centroid</span><span class="p">())[</span><span class="n">dim</span><span class="p">];</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">==</span> <span class="n">nBuckets</span><span class="p">)</span> <span class="n">b</span> <span class="o">=</span> <span class="n">nBuckets</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
                    <span class="n">buckets</span><span class="p">[</span><span class="n">b</span><span class="p">].</span><span class="n">count</span><span class="o">++</span><span class="p">;</span>
                    <span class="n">buckets</span><span class="p">[</span><span class="n">b</span><span class="p">].</span><span class="n">bounds</span> <span class="o">=</span> <span class="n">Union</span><span class="p">(</span><span class="n">buckets</span><span class="p">[</span><span class="n">b</span><span class="p">].</span><span class="n">bounds</span><span class="p">,</span> <span class="n">objects</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">getBounds</span><span class="p">());</span>
                <span class="p">}</span>
                <span class="c1">//下面计算最小成本</span>
                <span class="kt">float</span> <span class="n">cost</span><span class="p">[</span><span class="n">nBuckets</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]{</span> <span class="mf">0.</span><span class="n">f</span> <span class="p">};</span>
                <span class="c1">//按i的序号，将桶分成两部分，所以不取最后一个桶</span>
                <span class="c1">//因为如果左边取了最后一个桶，那么相当于右边没有桶了，这也是为啥cost数组长度为nBuckets - 1</span>
                <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nBuckets</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="n">Bounds3</span> <span class="n">b0</span><span class="p">,</span> <span class="n">b1</span><span class="p">;</span>
                    <span class="kt">int</span> <span class="n">cnt0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cnt1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
                    <span class="p">{</span>
                        <span class="n">b0</span> <span class="o">=</span> <span class="n">Union</span><span class="p">(</span><span class="n">b0</span><span class="p">,</span> <span class="n">buckets</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">bounds</span><span class="p">);</span>
                        <span class="n">cnt0</span><span class="o">++</span><span class="p">;</span>
                    <span class="p">}</span>
                    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">nBuckets</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
                    <span class="p">{</span>
                        <span class="n">b1</span> <span class="o">=</span> <span class="n">Union</span><span class="p">(</span><span class="n">b1</span><span class="p">,</span> <span class="n">buckets</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">bounds</span><span class="p">);</span>
                        <span class="n">cnt1</span><span class="o">++</span><span class="p">;</span>
                    <span class="p">}</span>
                    <span class="n">cost</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">SAHTravCost</span> <span class="o">+</span> <span class="p">(</span><span class="n">cnt0</span> <span class="o">*</span> <span class="n">b0</span><span class="p">.</span><span class="n">SurfaceArea</span><span class="p">()</span>  <span class="o">+</span> <span class="n">cnt1</span> <span class="o">*</span> <span class="n">b1</span><span class="p">.</span><span class="n">SurfaceArea</span><span class="p">()</span> <span class="p">)</span> <span class="o">/</span> <span class="n">bounds</span><span class="p">.</span><span class="n">SurfaceArea</span><span class="p">();</span>
                <span class="p">}</span>
                <span class="c1">//找出最小时间成本的划分桶序号</span>
                <span class="c1">//船新的找最小值下标方法，一行代码解决</span>
                <span class="kt">int</span> <span class="n">minCostSplitBucket</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">distance</span><span class="p">(</span><span class="n">cost</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">min_element</span><span class="p">(</span><span class="n">cost</span><span class="p">,</span> <span class="n">cost</span> <span class="o">+</span> <span class="n">nBuckets</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
                <span class="c1">//下面是传统的找最小值方法</span>
                <span class="kt">float</span> <span class="n">minCost</span> <span class="o">=</span> <span class="n">cost</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
                <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nBuckets</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">cost</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">minCost</span><span class="p">)</span>
                    <span class="p">{</span>
                        <span class="n">minCost</span> <span class="o">=</span> <span class="n">cost</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                        <span class="n">minCostSplitBucket</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span>
                <span class="kt">float</span> <span class="n">leafCost</span> <span class="o">=</span> <span class="n">objects</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="c1">//直接将当前所有图元也就是三角形都检测一遍的时间成本</span>
                <span class="c1">//如果当前图元数量大于一个节点允许的最大图元数量，那就需要按桶序号来划分两个区域</span>
                <span class="c1">//或者使用区域划分的时间成本确实小于将当前图元不划分的时间成本，那也要划分</span>
                <span class="c1">//但这个maxPrimsInNode设置为1.所以都会执行这段代码，甚至size为2的时候都轮不到执行这块代码</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">objects</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">maxPrimsInNode</span> <span class="o">||</span> <span class="n">minCost</span> <span class="o">&lt;</span> <span class="n">leafCost</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="k">auto</span> <span class="n">pmid</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">partition</span><span class="p">(</span><span class="n">objects</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">objects</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="n">Object</span><span class="o">*</span> <span class="n">pi</span><span class="p">){</span>
                            <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="n">nBuckets</span> <span class="o">*</span> <span class="n">centroidBounds</span><span class="p">.</span><span class="n">Offset</span><span class="p">(</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">getBounds</span><span class="p">().</span><span class="n">Centroid</span><span class="p">())[</span><span class="n">dim</span><span class="p">];</span>
                            <span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">==</span> <span class="n">nBuckets</span><span class="p">)</span> <span class="n">b</span> <span class="o">=</span> <span class="n">nBuckets</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
                            <span class="k">return</span> <span class="n">b</span> <span class="o">&lt;=</span> <span class="n">minCostSplitBucket</span><span class="p">;</span>
                        <span class="p">});</span>
                    <span class="k">auto</span> <span class="n">beginning</span> <span class="o">=</span> <span class="n">objects</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
                    <span class="k">auto</span> <span class="n">ending</span> <span class="o">=</span> <span class="n">objects</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>

                    <span class="k">auto</span> <span class="n">leftshapes</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">beginning</span><span class="p">,</span> <span class="n">pmid</span><span class="p">);</span>
                    <span class="k">auto</span> <span class="n">rightshapes</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">pmid</span><span class="p">,</span> <span class="n">ending</span><span class="p">);</span>

                    <span class="n">assert</span><span class="p">(</span><span class="n">objects</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="p">(</span><span class="n">leftshapes</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="n">rightshapes</span><span class="p">.</span><span class="n">size</span><span class="p">()));</span>

                    <span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">recursiveBuild</span><span class="p">(</span><span class="n">leftshapes</span><span class="p">);</span>
                    <span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">recursiveBuild</span><span class="p">(</span><span class="n">rightshapes</span><span class="p">);</span>

                    <span class="n">node</span><span class="o">-&gt;</span><span class="n">bounds</span> <span class="o">=</span> <span class="n">Union</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">bounds</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">-&gt;</span><span class="n">bounds</span><span class="p">);</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="c1">//如果这个划分效果还不如直接算，那就不break，直接执行下面的的</span>
                <span class="c1">//但是我的maxPrimsInNode设置的是1，所以无论如何都用sah，所以就先break下</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">case</span> <span class="n">SplitMethod</span><span class="o">::</span><span class="n">NAIVE</span> <span class="p">:</span>
            <span class="p">{</span>   <span class="k">switch</span> <span class="p">(</span><span class="n">dim</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">case</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">objects</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">objects</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="k">auto</span> <span class="n">f1</span><span class="p">,</span> <span class="k">auto</span> <span class="n">f2</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="n">f1</span><span class="o">-&gt;</span><span class="n">getBounds</span><span class="p">().</span><span class="n">Centroid</span><span class="p">().</span><span class="n">x</span> <span class="o">&lt;</span>
                    <span class="n">f2</span><span class="o">-&gt;</span><span class="n">getBounds</span><span class="p">().</span><span class="n">Centroid</span><span class="p">().</span><span class="n">x</span><span class="p">;</span>
                    <span class="p">});</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">objects</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">objects</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="k">auto</span> <span class="n">f1</span><span class="p">,</span> <span class="k">auto</span> <span class="n">f2</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="n">f1</span><span class="o">-&gt;</span><span class="n">getBounds</span><span class="p">().</span><span class="n">Centroid</span><span class="p">().</span><span class="n">y</span> <span class="o">&lt;</span>
                    <span class="n">f2</span><span class="o">-&gt;</span><span class="n">getBounds</span><span class="p">().</span><span class="n">Centroid</span><span class="p">().</span><span class="n">y</span><span class="p">;</span>
                    <span class="p">});</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">objects</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">objects</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="k">auto</span> <span class="n">f1</span><span class="p">,</span> <span class="k">auto</span> <span class="n">f2</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="n">f1</span><span class="o">-&gt;</span><span class="n">getBounds</span><span class="p">().</span><span class="n">Centroid</span><span class="p">().</span><span class="n">z</span> <span class="o">&lt;</span>
                    <span class="n">f2</span><span class="o">-&gt;</span><span class="n">getBounds</span><span class="p">().</span><span class="n">Centroid</span><span class="p">().</span><span class="n">z</span><span class="p">;</span>
                    <span class="p">});</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">auto</span> <span class="n">beginning</span> <span class="o">=</span> <span class="n">objects</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
            <span class="k">auto</span> <span class="n">middling</span> <span class="o">=</span> <span class="n">objects</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="p">(</span><span class="n">objects</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
            <span class="k">auto</span> <span class="n">ending</span> <span class="o">=</span> <span class="n">objects</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>

            <span class="k">auto</span> <span class="n">leftshapes</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">beginning</span><span class="p">,</span> <span class="n">middling</span><span class="p">);</span>
            <span class="k">auto</span> <span class="n">rightshapes</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">middling</span><span class="p">,</span> <span class="n">ending</span><span class="p">);</span>

            <span class="n">assert</span><span class="p">(</span><span class="n">objects</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="p">(</span><span class="n">leftshapes</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="n">rightshapes</span><span class="p">.</span><span class="n">size</span><span class="p">()));</span>

            <span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">recursiveBuild</span><span class="p">(</span><span class="n">leftshapes</span><span class="p">);</span>
            <span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">recursiveBuild</span><span class="p">(</span><span class="n">rightshapes</span><span class="p">);</span>

            <span class="n">node</span><span class="o">-&gt;</span><span class="n">bounds</span> <span class="o">=</span> <span class="n">Union</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">bounds</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">-&gt;</span><span class="n">bounds</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>


    <span class="p">}</span>

    <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p><a href="https://imgse.com/i/pCTuAL6" class="img-link shimmer" ><img data-src="https://s1.ax1x.com/2023/07/18/pCTuAL6.jpg" alt="pCTuAL6.jpg" class="lazyload" data-proofer-ignore></a></p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/computer-graphics/'>Computer Graphics</a>, <a href='/categories/games101/'>GAMES101</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/" class="post-tag no-text-decoration" >图形学</a> <a href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-tag no-text-decoration" >学习笔记</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=GAMES101-Lecture%2014%20Ray%20Tracing%202(Acceleration%20&%20Radiometry)%20&%20%E4%BD%9C%E4%B8%9A6%20-%20CALL1CE&url=%2Fposts%2FGAMES101-Lecture-14-Ray-Tracing-2-%26-%25E4%25BD%259C%25E4%25B8%259A6%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=GAMES101-Lecture%2014%20Ray%20Tracing%202(Acceleration%20&%20Radiometry)%20&%20%E4%BD%9C%E4%B8%9A6%20-%20CALL1CE&u=%2Fposts%2FGAMES101-Lecture-14-Ray-Tracing-2-%26-%25E4%25BD%259C%25E4%25B8%259A6%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=%2Fposts%2FGAMES101-Lecture-14-Ray-Tracing-2-%26-%25E4%25BD%259C%25E4%25B8%259A6%2F&text=GAMES101-Lecture%2014%20Ray%20Tracing%202(Acceleration%20&%20Radiometry)%20&%20%E4%BD%9C%E4%B8%9A6%20-%20CALL1CE" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" data-title-succeed="链接已复制！"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">最近更新</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/GAMES105-Lecture-02-Math-Background/">GAMES105-Lecture 02 Math Background</a><li><a href="/posts/GAMES105-Lecture-03-Character-Kinematics/">GAMES105-Lecture 03 Character Kinematics</a><li><a href="/posts/GAMES105-Lecture-01-Introduction-to-Character-Animation/">GAMES105-Lecture 01 Introduction to Character Animation</a><li><a href="/posts/GAMES104-Lecture-12-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E7%B2%92%E5%AD%90%E5%92%8C%E5%A3%B0%E6%95%88%E7%B3%BB%E7%BB%9F/">GAMES104-Lecture 12 游戏引擎中的粒子和声效系统</a><li><a href="/posts/GAMES101-Lecture-16-Ray-Tracing-4-&-%E4%BD%9C%E4%B8%9A7/">GAMES101-Lecture 16 Ray Tracing 4(Monte Carlo Path Tracing) & 作业7</a></ul></div><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a> <a class="post-tag" href="/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/">图形学</a> <a class="post-tag" href="/tags/%E6%A8%A1%E6%8B%9F/">模拟</a> <a class="post-tag" href="/tags/%E8%B4%AA%E5%BF%83/">贪心</a> <a class="post-tag" href="/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/">哈希表</a> <a class="post-tag" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/">二叉树的遍历</a> <a class="post-tag" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a> <a class="post-tag" href="/tags/%E5%9B%9E%E6%BA%AF/">回溯</a> <a class="post-tag" href="/tags/%E6%8E%92%E5%BA%8F/">排序</a> <a class="post-tag" href="/tags/%E6%95%B0%E5%AD%A6/">数学</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">文章内容</div><nav id="toc"></nav></div><script src="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.js"></script></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4 mt-5"><div id="related-posts" class="mb-2 mb-sm-4"><h3 class="pt-2 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/GAMES101-Lecture-01-Overview-of-Computer-Graphics/"><div class="card-body"> <em class="small" data-ts="1658288400" data-df="YYYY/MM/DD" > 2022/07/20 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>GAMES101-Lecture 01 Overview of Computer Graphics</h3><div class="text-muted small"><p> 1. What is Computer Graphics?     涉及到的领域： Video Game Movies Animations Design Visualization Virtual Reality Augumented Reality ...</p></div></div></a></div><div class="card"> <a href="/posts/GAMES101-Lecture-02-Review-of-Linear-Algebra/"><div class="card-body"> <em class="small" data-ts="1658555580" data-df="YYYY/MM/DD" > 2022/07/23 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>GAMES101-Lecture 02 Review of Linear Algebra</h3><div class="text-muted small"><p> 阅读材料：第 2 章（Miscellaneous Math）；第 5 章（Linear Algebra） 1. Graphics’ Dependencies 基础数学：线代、微积分、统计 基础物理：光学、力学 其它：信号处理、数值分析 2. This Course More dependent on li...</p></div></div></a></div><div class="card"> <a href="/posts/GAMES101-Lecture-03-Transformation/"><div class="card-body"> <em class="small" data-ts="1658586000" data-df="YYYY/MM/DD" > 2022/07/23 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>GAMES101-Lecture 03 Transformation</h3><div class="text-muted small"><p> Transformation Scale [\left[ \begin{matrix} x\prime y\prime \end{matrix}\right]= \left[ \begin{matrix} s_x &amp;amp; 0 0 &amp;amp; s_y \end{matrix}\right] \left[ \begin{matrix} x y \end{matrix}\right]] ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/GAMES101-Lecture-13-Ray-Tracing-1-&-%E4%BD%9C%E4%B8%9A5/" class="btn btn-outline-primary" prompt="上一篇"><p>GAMES101-Lecture 13 Ray Tracing 1(Whitted-Style Ray Tracing) & 作业5</p></a> <a href="/posts/GAMES101-Lecture-15-Ray-Tracing-3/" class="btn btn-outline-primary" prompt="下一篇"><p>GAMES101-Lecture 15 Ray Tracing 3(Light Transport & Global Illumination)</p></a></div></div></div></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a> <a class="post-tag" href="/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/">图形学</a> <a class="post-tag" href="/tags/%E6%A8%A1%E6%8B%9F/">模拟</a> <a class="post-tag" href="/tags/%E8%B4%AA%E5%BF%83/">贪心</a> <a class="post-tag" href="/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/">哈希表</a> <a class="post-tag" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/">二叉树的遍历</a> <a class="post-tag" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a> <a class="post-tag" href="/tags/%E5%9B%9E%E6%BA%AF/">回溯</a> <a class="post-tag" href="/tags/%E6%8E%92%E5%BA%8F/">排序</a> <a class="post-tag" href="/tags/%E6%95%B0%E5%AD%A6/">数学</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><footer><div class="container pl-lg-4 pr-lg-4"><div class="d-flex justify-content-between align-items-center text-muted ml-md-3 mr-md-3"><div class="footer-left"><p class="mb-0"> © 2024 <a href="https://github.com/username">CALL1CE</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span></p></div><div class="footer-right"><p class="mb-0">本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，采用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题。</p></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js"></script> <script> (function () { function updateMermaid(event) { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { const mode = event.data.message; if (typeof mermaid === "undefined") { return; } let expectedTheme = (mode === ModeToggle.DARK_MODE ? "dark" : "default"); let config = {theme: expectedTheme}; /* Re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function () { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } let initTheme = "default"; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Create mermaid tag */ $("pre").has("code.language-mermaid").each(function () { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<pre class=\"mermaid\">${svgCode}</pre>`); }); mermaid.initialize(mermaidConf); window.addEventListener("message", updateMermaid); })(); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lazysizes@5.3.2/lazysizes.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/zh.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { /* start/end delimiter pairs for in-line math */ inlineMath: [ ['$', '$'], ['\\(', '\\)'] ], /* start/end delimiter pairs for display math */ displayMath: [ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/unregister.js"></script>
