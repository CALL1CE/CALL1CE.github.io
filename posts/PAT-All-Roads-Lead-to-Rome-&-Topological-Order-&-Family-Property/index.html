<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="PAT-All Roads Lead to Rome &amp; Topological Order &amp; Family Property" /><meta name="author" content="CALL1CE" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="A1087 All Roads Lead to Rome" /><meta property="og:description" content="A1087 All Roads Lead to Rome" /><link rel="canonical" href="/posts/PAT-All-Roads-Lead-to-Rome-&-Topological-Order-&-Family-Property/" /><meta property="og:url" content="/posts/PAT-All-Roads-Lead-to-Rome-&-Topological-Order-&-Family-Property/" /><meta property="og:site_name" content="CALL1CE" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-08-14T14:46:00+00:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="PAT-All Roads Lead to Rome &amp; Topological Order &amp; Family Property" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"CALL1CE"},"dateModified":"2022-08-29T11:10:49+00:00","datePublished":"2022-08-14T14:46:00+00:00","description":"A1087 All Roads Lead to Rome","headline":"PAT-All Roads Lead to Rome &amp; Topological Order &amp; Family Property","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/PAT-All-Roads-Lead-to-Rome-&-Topological-Order-&-Family-Property/"},"url":"/posts/PAT-All-Roads-Lead-to-Rome-&-Topological-Order-&-Family-Property/"}</script><title>PAT-All Roads Lead to Rome & Topological Order & Family Property | CALL1CE</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="CALL1CE"><meta name="application-name" content="CALL1CE"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener('change', () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.notify(); } /* flipMode() */ } /* ModeToggle */ const modeToggle = new ModeToggle(); </script><body data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/config/CALL1CE.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title"> <a href="/">CALL1CE</a></div><div class="site-subtitle font-italic">一位正在练习敲代码的OW2玩家</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/CALL1CE" aria-label="github" target="_blank" rel="noopener noreferrer"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/" aria-label="twitter" target="_blank" rel="noopener noreferrer"> <i class="fab fa-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['563638083','qq.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>PAT-All Roads Lead to Rome & Topological Order & Family Property</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> </span> <span id="search-cancel" >取消</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>PAT-All Roads Lead to Rome & Topological Order & Family Property</h1><div class="post-meta text-muted"> <span> 发表于 <em class="" data-ts="1660488360" data-df="YYYY/MM/DD" data-toggle="tooltip" data-placement="bottom"> 2022/08/14 </em> </span> <span> 更新于 <em class="" data-ts="1661771449" data-df="YYYY/MM/DD" data-toggle="tooltip" data-placement="bottom"> 2022/08/29 </em> </span><div class="d-flex justify-content-between"> <span> 作者 <em> <a href=""></a> </em>, <em> <a href=""></a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="2438 字"> <em>13 分钟</em>阅读</span></div></div></div><div class="post-content"><h2 id="a1087-all-roads-lead-to-rome"><span class="mr-2">A1087 <a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805379664297984">All Roads Lead to Rome</a></span><a href="#a1087-all-roads-lead-to-rome" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
</pre><td class="rouge-code"><pre><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;unordered_map&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="c1">//邻接表中需要存的数据：</span>
<span class="k">struct</span> <span class="nc">node</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">v</span><span class="p">,</span> <span class="n">cost</span><span class="p">;</span><span class="c1">//城市编号（map存）、到这个地的花费(其实也就是路径长度)</span>
    <span class="n">node</span><span class="p">(</span><span class="kt">int</span> <span class="n">_v</span><span class="p">,</span> <span class="kt">int</span> <span class="n">_cost</span><span class="p">)</span> <span class="o">:</span> <span class="n">v</span><span class="p">(</span><span class="n">_v</span><span class="p">),</span> <span class="n">cost</span><span class="p">(</span><span class="n">_cost</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">maxn</span> <span class="o">=</span> <span class="mi">210</span><span class="p">;</span><span class="c1">//最大城市数量</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">inf</span> <span class="o">=</span> <span class="mh">0xfffffff</span><span class="p">;</span>
<span class="kt">bool</span> <span class="n">isVisited</span><span class="p">[</span><span class="n">maxn</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="nb">false</span> <span class="p">};</span><span class="c1">//访问数组</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">pre</span><span class="p">(</span><span class="n">maxn</span><span class="p">);</span><span class="c1">//记录前缀节点</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">node</span><span class="o">&gt;&gt;</span> <span class="n">neighbor</span><span class="p">(</span><span class="n">maxn</span><span class="p">);</span><span class="c1">//存邻接表</span>
<span class="kt">int</span> <span class="n">cost</span><span class="p">[</span><span class="n">maxn</span><span class="p">];</span><span class="c1">//存到每个城市的最少花费</span>
<span class="kt">int</span> <span class="n">happiness</span><span class="p">[</span><span class="n">maxn</span><span class="p">];</span><span class="c1">//存每个城市的幸福指数</span>
<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">;</span><span class="c1">//城市数目、路数</span>
<span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">map</span><span class="p">;</span><span class="c1">//名字到编号的映射0~n-1</span>
<span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">string</span><span class="o">&gt;</span> <span class="n">map2name</span><span class="p">;</span><span class="c1">//标号到名字的映射</span>

<span class="kt">void</span> <span class="nf">Dijkstra</span><span class="p">(</span><span class="kt">int</span> <span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//初始化数据</span>
    <span class="n">fill</span><span class="p">(</span><span class="n">cost</span><span class="p">,</span> <span class="n">cost</span> <span class="o">+</span> <span class="n">n</span><span class="p">,</span> <span class="n">inf</span><span class="p">);</span><span class="c1">//费用初始化为极大值</span>
    <span class="n">cost</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="c1">//出发点的费用初始化为0</span>
    <span class="c1">//遍历n个城市（求到每个城市的最低消费）</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">min</span> <span class="o">=</span> <span class="n">inf</span><span class="p">;</span>
        <span class="c1">//在没有访问过的节点中，选取cost最低的</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">isVisited</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="nb">false</span> <span class="o">&amp;&amp;</span> <span class="n">cost</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">min</span> <span class="o">=</span> <span class="n">cost</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
                <span class="n">u</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">u</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span><span class="c1">//说明不连通，或者已经遍历完了</span>
        <span class="n">isVisited</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="c1">//遍历u的邻居，看是否要更新值</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">node</span> <span class="n">nd</span> <span class="o">:</span> <span class="n">neighbor</span><span class="p">[</span><span class="n">u</span><span class="p">])</span>
        <span class="p">{</span>
            <span class="c1">//u作为中介节点到nd.v节点的花费小于之前存储的最小花费</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">cost</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="n">nd</span><span class="p">.</span><span class="n">cost</span> <span class="o">&lt;</span> <span class="n">cost</span><span class="p">[</span><span class="n">nd</span><span class="p">.</span><span class="n">v</span><span class="p">])</span>
            <span class="p">{</span>
                <span class="n">cost</span><span class="p">[</span><span class="n">nd</span><span class="p">.</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">cost</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="n">nd</span><span class="p">.</span><span class="n">cost</span><span class="p">;</span><span class="c1">//更新花费</span>
                <span class="c1">//更新前缀节点</span>
                <span class="n">pre</span><span class="p">[</span><span class="n">nd</span><span class="p">.</span><span class="n">v</span><span class="p">].</span><span class="n">clear</span><span class="p">();</span>
                <span class="n">pre</span><span class="p">[</span><span class="n">nd</span><span class="p">.</span><span class="n">v</span><span class="p">].</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">cost</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="n">nd</span><span class="p">.</span><span class="n">cost</span> <span class="o">==</span> <span class="n">cost</span><span class="p">[</span><span class="n">nd</span><span class="p">.</span><span class="n">v</span><span class="p">])</span><span class="c1">//如果出现了相同的花费</span>
            <span class="p">{</span>
                <span class="n">pre</span><span class="p">[</span><span class="n">nd</span><span class="p">.</span><span class="n">v</span><span class="p">].</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">//回溯寻找目标路径</span>
<span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="c1">//路径数量</span>
<span class="kt">int</span> <span class="n">tmpHappiness</span><span class="p">;</span><span class="c1">//临时存储幸福指数和</span>
<span class="kt">int</span> <span class="n">pathHappiness</span><span class="p">;</span><span class="c1">//最终幸福指数和</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">path</span><span class="p">;</span><span class="c1">//最终的路径</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">tmp</span><span class="p">;</span><span class="c1">//临时存放路径</span>
<span class="c1">//1.确认返回类型和参数</span>
<span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">rom</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//2.终止条件</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">rom</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="c1">//回到初始点 </span>
    <span class="p">{</span>
        <span class="n">ans</span><span class="o">++</span><span class="p">;</span>
        <span class="c1">//判断是否要更新为最终选择的路径</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ans</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span><span class="c1">//说明这是第一条</span>
        <span class="p">{</span>
            <span class="n">pathHappiness</span> <span class="o">=</span> <span class="n">tmpHappiness</span><span class="p">;</span>
            <span class="n">path</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">ans</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span><span class="c1">//说明最小花费的路径大于1条</span>
        <span class="p">{</span>
            <span class="c1">//如果总幸福指数更高</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">tmpHappiness</span> <span class="o">&gt;</span> <span class="n">pathHappiness</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">pathHappiness</span> <span class="o">=</span> <span class="n">tmpHappiness</span><span class="p">;</span><span class="c1">//更新指数</span>
                <span class="n">path</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span><span class="c1">//更新最终路径</span>
                <span class="n">path</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="c1">//如果总幸福指数一样，计算平均幸福指数并比较，如果这条路径的平均指数更高</span>
            <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">tmpHappiness</span> <span class="o">==</span> <span class="n">pathHappiness</span> <span class="o">&amp;&amp;</span> <span class="n">tmpHappiness</span> <span class="o">/</span> <span class="n">tmp</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">pathHappiness</span> <span class="o">/</span> <span class="n">path</span><span class="p">.</span><span class="n">size</span><span class="p">())</span>
            <span class="p">{</span>
                <span class="n">pathHappiness</span> <span class="o">=</span> <span class="n">tmpHappiness</span><span class="p">;</span><span class="c1">//更新指数</span>
                <span class="n">path</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span><span class="c1">//更新最终路径</span>
                <span class="n">path</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">//遍历</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">p</span> <span class="o">:</span> <span class="n">pre</span><span class="p">[</span><span class="n">rom</span><span class="p">])</span><span class="c1">//遍历每一个前缀节点</span>
    <span class="p">{</span>
        <span class="n">tmp</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">p</span><span class="p">);</span><span class="c1">//加入临时路径</span>
        <span class="n">tmpHappiness</span> <span class="o">+=</span> <span class="n">happiness</span><span class="p">[</span><span class="n">p</span><span class="p">];</span><span class="c1">//增加临时幸福指数和</span>
        <span class="n">dfs</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
        <span class="n">tmp</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span><span class="c1">//退出路径</span>
        <span class="n">tmpHappiness</span> <span class="o">-=</span> <span class="n">happiness</span><span class="p">[</span><span class="n">p</span><span class="p">];</span><span class="c1">//减少对应的幸福指数</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">k</span><span class="p">;</span>
    <span class="n">string</span> <span class="n">start</span><span class="p">;</span><span class="c1">//出发点</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">start</span><span class="p">;</span>
    <span class="n">map</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">map2name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
    <span class="n">happiness</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="c1">//此时只有n-1个城市（start算一个了，所以要-1）</span>
    <span class="p">{</span>
        <span class="n">string</span> <span class="n">_city</span><span class="p">;</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">_city</span> <span class="o">&gt;&gt;</span> <span class="n">happiness</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">map</span><span class="p">[</span><span class="n">_city</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span><span class="c1">//将该城市写入map，映射城市编号</span>
        <span class="n">map2name</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">_city</span><span class="p">;</span><span class="c1">//编号映射城市名字</span>
    <span class="p">}</span>
    <span class="c1">//读取路</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">string</span> <span class="n">_c1</span><span class="p">,</span> <span class="n">_c2</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">_cost</span><span class="p">;</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">_c1</span> <span class="o">&gt;&gt;</span> <span class="n">_c2</span> <span class="o">&gt;&gt;</span> <span class="n">_cost</span><span class="p">;</span>
        <span class="n">neighbor</span><span class="p">[</span><span class="n">map</span><span class="p">[</span><span class="n">_c1</span><span class="p">]].</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">node</span><span class="p">(</span><span class="n">map</span><span class="p">[</span><span class="n">_c2</span><span class="p">],</span> <span class="n">_cost</span><span class="p">));</span>
        <span class="n">neighbor</span><span class="p">[</span><span class="n">map</span><span class="p">[</span><span class="n">_c2</span><span class="p">]].</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">node</span><span class="p">(</span><span class="n">map</span><span class="p">[</span><span class="n">_c1</span><span class="p">],</span> <span class="n">_cost</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="c1">//迪杰斯特拉算法</span>
    <span class="n">Dijkstra</span><span class="p">(</span><span class="n">map</span><span class="p">[</span><span class="n">start</span><span class="p">]);</span>
    <span class="c1">//寻找目标路径</span>
    <span class="n">tmpHappiness</span> <span class="o">=</span> <span class="n">happiness</span><span class="p">[</span><span class="n">map</span><span class="p">[</span><span class="s">"ROM"</span><span class="p">]];</span><span class="c1">//提前加入rom的幸福指数</span>
    <span class="n">dfs</span><span class="p">(</span><span class="n">map</span><span class="p">[</span><span class="s">"ROM"</span><span class="p">]);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ans</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span> <span class="o">&lt;&lt;</span> <span class="n">cost</span><span class="p">[</span><span class="n">map</span><span class="p">[</span><span class="s">"ROM"</span><span class="p">]]</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span> <span class="o">&lt;&lt;</span> <span class="n">pathHappiness</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span> <span class="o">&lt;&lt;</span> <span class="n">pathHappiness</span> <span class="o">/</span> <span class="n">path</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">path</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">map2name</span><span class="p">[</span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">&lt;&lt;</span> <span class="s">"-&gt;"</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"ROM"</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>    这题真是写了好久，使用Dijkstra+dfs，麻了，又又又debug半天，好在我发现在牛客网上，提交出现错误了会告诉样例是啥，不然又不知道要debug多久，需要注意的点：</p><ul><li>初始化数据的时候，出发点的幸福指数默认应该是0，所以一定要初始化为0，不然一旦加了别的值，应付指数就不对了<li>遍历过的点，一定要记得设置isVisited数组为true<li>题目讲了，如果有多条最短花费路径，那就比总幸福指数，总幸福指数一样了，再比平均幸福指数，注意审题（好在这个点就只有3分，开始没拿到）<li>按我的方法，开始时，需要先加上Rom的幸福指数，我一开始直接加了100，但注意，rom的幸福指数可不一定是100！只是样例中的是100，还好这个不是100的测试点只有6分<li>在打印地名字的时候，注意是<code class="language-plaintext highlighter-rouge">map2name[path[i]]</code>不是<code class="language-plaintext highlighter-rouge">map2name[i]</code><li>在算平均幸福指数时，出发点是不算数的</ul><h2 id="a1146-topological-order"><span class="mr-2">A1146 <a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805343043829760">Topological Order</a></span><a href="#a1146-topological-order" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
</pre><td class="rouge-code"><pre><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;string&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">k</span><span class="p">;</span><span class="c1">//点数、边数、询问数</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">maxv</span> <span class="o">=</span> <span class="mi">1010</span><span class="p">;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">inDegree</span><span class="p">(</span><span class="n">maxv</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span><span class="c1">//记录每个点的入度</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">tmp</span><span class="p">;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">neighbor</span><span class="p">(</span><span class="n">maxv</span><span class="p">);</span><span class="c1">//邻接表</span>
<span class="kt">bool</span> <span class="nf">check</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">order</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">inDegree</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">//如果某个节点的入度大于0</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="n">order</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="c1">//该节点指向的所有点入度-1</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">:</span> <span class="n">neighbor</span><span class="p">[</span><span class="n">order</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
        <span class="p">{</span>
            <span class="n">tmp</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">m</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">;</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">v1</span> <span class="o">&gt;&gt;</span> <span class="n">v2</span><span class="p">;</span>
        <span class="n">neighbor</span><span class="p">[</span><span class="n">v1</span><span class="p">].</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">v2</span><span class="p">);</span>
        <span class="n">inDegree</span><span class="p">[</span><span class="n">v2</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">k</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ans</span><span class="p">;</span><span class="c1">//记录不是拓扑排序的序号</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">order</span><span class="p">(</span><span class="n">n</span><span class="p">);</span><span class="c1">//记录询问的顺序</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">order</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">check</span><span class="p">(</span><span class="n">order</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="n">ans</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ans</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ans</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="k">else</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span> <span class="o">&lt;&lt;</span> <span class="n">ans</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>

<span class="p">}</span>
</pre></table></code></div></div><p>    拓扑排序，有一处问题，就是读取数据时，读取order数组，<code class="language-plaintext highlighter-rouge">order[j]</code>写成<code class="language-plaintext highlighter-rouge">order[i]</code>了…..这种错误什么时候才能不犯啊……</p><h2 id="a1114-family-property"><span class="mr-2">A1114 <a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805356599820288">Family Property</a></span><a href="#a1114-family-property" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
</pre><td class="rouge-code"><pre><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;algorithm&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;set&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;cstdio&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">struct</span> <span class="nc">family</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="n">cnt</span><span class="p">;</span><span class="c1">//家庭最小id，家庭人数，</span>
    <span class="kt">double</span> <span class="n">avgSets</span><span class="p">,</span> <span class="n">avgArea</span><span class="p">;</span><span class="c1">//平均房产数量、面积</span>
    <span class="n">family</span><span class="p">(</span><span class="kt">int</span> <span class="n">_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">_cnt</span><span class="p">,</span> <span class="kt">double</span> <span class="n">_avgSets</span><span class="p">,</span> <span class="kt">double</span> <span class="n">_avgArea</span><span class="p">)</span> <span class="o">:</span><span class="n">id</span><span class="p">(</span><span class="n">_id</span><span class="p">),</span> <span class="n">cnt</span><span class="p">(</span><span class="n">_cnt</span><span class="p">),</span> <span class="n">avgSets</span><span class="p">(</span><span class="n">_avgSets</span><span class="p">),</span> <span class="n">avgArea</span><span class="p">(</span><span class="n">_avgArea</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="n">n</span><span class="p">;</span><span class="c1">//n行数据</span>
<span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ids</span><span class="p">;</span><span class="c1">//储存所有出现过的id</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">maxid</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">parent</span><span class="p">[</span><span class="n">maxid</span><span class="p">],</span> <span class="n">Rank</span><span class="p">[</span><span class="n">maxid</span><span class="p">],</span> <span class="n">estate</span><span class="p">[</span><span class="n">maxid</span><span class="p">],</span> <span class="n">area</span><span class="p">[</span><span class="n">maxid</span><span class="p">];</span><span class="c1">//父节点、并查集树的高度，某个id（一行数据的代表）房产，某个id的住房面积</span>
<span class="c1">//初始化并查集</span>
<span class="kt">void</span> <span class="nf">init</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">maxid</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">parent</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">fill</span><span class="p">(</span><span class="n">Rank</span><span class="p">,</span> <span class="n">Rank</span> <span class="o">+</span> <span class="n">maxid</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">//查找父节点</span>
<span class="kt">int</span> <span class="nf">find</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">parent</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">!=</span> <span class="n">p</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">parent</span><span class="p">[</span><span class="n">p</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="c1">//路径压缩</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">parent</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">!=</span> <span class="n">a</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">z</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">parent</span><span class="p">[</span><span class="n">a</span><span class="p">];</span>
        <span class="n">parent</span><span class="p">[</span><span class="n">z</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//合并两个家庭</span>
<span class="kt">void</span> <span class="nf">Union</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="n">q</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span><span class="c1">//不处理-1的情况</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">p</span><span class="p">);</span> 
    <span class="n">q</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
    <span class="c1">//根据rank来看谁做主树，谁高谁做主</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Rank</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">Rank</span><span class="p">[</span><span class="n">q</span><span class="p">])</span>
    <span class="p">{</span>
        <span class="n">parent</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">Rank</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">Rank</span><span class="p">[</span><span class="n">p</span><span class="p">])</span>
    <span class="p">{</span>
        <span class="n">parent</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">q</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span><span class="c1">//rank一样，p做主</span>
    <span class="p">{</span>
        <span class="n">parent</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
        <span class="n">Rank</span><span class="p">[</span><span class="n">p</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kt">bool</span> <span class="nf">comp</span><span class="p">(</span><span class="n">family</span> <span class="n">f1</span><span class="p">,</span> <span class="n">family</span> <span class="n">f2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">f1</span><span class="p">.</span><span class="n">avgArea</span> <span class="o">!=</span> <span class="n">f2</span><span class="p">.</span><span class="n">avgArea</span> <span class="o">?</span> <span class="n">f1</span><span class="p">.</span><span class="n">avgArea</span> <span class="o">&gt;</span> <span class="n">f2</span><span class="p">.</span><span class="n">avgArea</span> <span class="o">:</span> <span class="n">f1</span><span class="p">.</span><span class="n">id</span> <span class="o">&lt;</span> <span class="n">f2</span><span class="p">.</span><span class="n">id</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">init</span><span class="p">();</span><span class="c1">//初始化</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">m</span><span class="p">;</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">id</span> <span class="o">&gt;&gt;</span> <span class="n">f</span> <span class="o">&gt;&gt;</span> <span class="n">m</span><span class="p">;</span>
        <span class="n">ids</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">id</span><span class="p">);</span>
        <span class="n">ids</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
        <span class="n">ids</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
        <span class="n">Union</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
        <span class="n">Union</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
        <span class="c1">//小孩</span>
        <span class="kt">int</span> <span class="n">k</span><span class="p">;</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">k</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">k</span><span class="o">--</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">int</span> <span class="n">kid</span><span class="p">;</span>
            <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">kid</span><span class="p">;</span>
            <span class="n">ids</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">kid</span><span class="p">);</span>
            <span class="n">Union</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">kid</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">estate</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="n">area</span><span class="p">[</span><span class="n">id</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="c1">//清除ids中的-1</span>
    <span class="n">ids</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="c1">//遍历每一个ids中的id，找到他们的父亲</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">tmp</span><span class="p">[</span><span class="n">maxid</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">id</span> <span class="o">:</span> <span class="n">ids</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">tmp</span><span class="p">[</span><span class="n">find</span><span class="p">(</span><span class="n">id</span><span class="p">)].</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">id</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">family</span><span class="o">&gt;</span> <span class="n">fa</span><span class="p">;</span>
    <span class="c1">//把tmp数组抽象出来，形成一个家族</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">id</span> <span class="o">:</span> <span class="n">ids</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="n">id</span><span class="p">].</span><span class="n">empty</span><span class="p">())</span> <span class="k">continue</span><span class="p">;</span><span class="c1">//说明这个id不是parent</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">members</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="n">id</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">totalEstate</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">totalArea</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">familyID</span> <span class="o">=</span> <span class="n">members</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cnt</span> <span class="o">=</span> <span class="n">members</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">m</span> <span class="o">:</span> <span class="n">members</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">&lt;</span> <span class="n">familyID</span><span class="p">)</span> <span class="n">familyID</span> <span class="o">=</span> <span class="n">m</span><span class="p">;</span>
            <span class="n">totalEstate</span> <span class="o">+=</span> <span class="n">estate</span><span class="p">[</span><span class="n">m</span><span class="p">];</span><span class="c1">//m是某一行数据的代表，并不会每个人都有房产</span>
            <span class="n">totalArea</span> <span class="o">+=</span> <span class="n">area</span><span class="p">[</span><span class="n">m</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="n">fa</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">family</span><span class="p">(</span><span class="n">familyID</span><span class="p">,</span> <span class="n">cnt</span><span class="p">,</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">totalEstate</span> <span class="o">/</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">cnt</span><span class="p">,</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">totalArea</span> <span class="o">/</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">cnt</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="n">sort</span><span class="p">(</span><span class="n">fa</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">fa</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">comp</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">fa</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">family</span><span class="o">&amp;</span> <span class="n">f</span> <span class="o">:</span> <span class="n">fa</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%04d %d %.3lf %.3lf</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">f</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="n">f</span><span class="p">.</span><span class="n">cnt</span><span class="p">,</span> <span class="n">f</span><span class="p">.</span><span class="n">avgSets</span><span class="p">,</span> <span class="n">f</span><span class="p">.</span><span class="n">avgArea</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>    这道题目是关于并查集的，有点难度，需要注意的点：</p><ul><li><p>一定一定要记得init，别光写init函数了，结果再main里没调用</p><li><p>要搞清除id之间的关系，在储存某个id的房产时，其实就相当于存了当中某一行的房产</p><li><p>注意-1，-1代表没有父母，所以不能union，并且读取完数据，要从set中删除</p><li><p>这个解中，用了很多大数组，不要在意，能接算出答案就行了</p></ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/'>算法刷题</a>, <a href='/categories/pat/'>PAT</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/dijkstra/" class="post-tag no-text-decoration" >Dijkstra</a> <a href="/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/" class="post-tag no-text-decoration" >拓扑排序</a> <a href="/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/" class="post-tag no-text-decoration" >并查集</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=PAT-All%20Roads%20Lead%20to%20Rome%20&%20Topological%20Order%20&%20Family%20Property%20-%20CALL1CE&url=%2Fposts%2FPAT-All-Roads-Lead-to-Rome-%26-Topological-Order-%26-Family-Property%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=PAT-All%20Roads%20Lead%20to%20Rome%20&%20Topological%20Order%20&%20Family%20Property%20-%20CALL1CE&u=%2Fposts%2FPAT-All-Roads-Lead-to-Rome-%26-Topological-Order-%26-Family-Property%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=%2Fposts%2FPAT-All-Roads-Lead-to-Rome-%26-Topological-Order-%26-Family-Property%2F&text=PAT-All%20Roads%20Lead%20to%20Rome%20&%20Topological%20Order%20&%20Family%20Property%20-%20CALL1CE" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" data-title-succeed="链接已复制！"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">最近更新</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/CSAPPLAB-DATALAB/">CSAPPLAB-DATALAB</a><li><a href="/posts/GAMES105-Lecture-02-Math-Background/">GAMES105-Lecture 02 Math Background</a><li><a href="/posts/GAMES105-Lecture-03-Character-Kinematics/">GAMES105-Lecture 03 Character Kinematics</a><li><a href="/posts/GAMES105-Lecture-01-Introduction-to-Character-Animation/">GAMES105-Lecture 01 Introduction to Character Animation</a><li><a href="/posts/GAMES104-Lecture-12-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E7%B2%92%E5%AD%90%E5%92%8C%E5%A3%B0%E6%95%88%E7%B3%BB%E7%BB%9F/">GAMES104-Lecture 12 游戏引擎中的粒子和声效系统</a></ul></div><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a> <a class="post-tag" href="/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/">图形学</a> <a class="post-tag" href="/tags/%E6%A8%A1%E6%8B%9F/">模拟</a> <a class="post-tag" href="/tags/%E8%B4%AA%E5%BF%83/">贪心</a> <a class="post-tag" href="/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/">哈希表</a> <a class="post-tag" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/">二叉树的遍历</a> <a class="post-tag" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a> <a class="post-tag" href="/tags/%E5%9B%9E%E6%BA%AF/">回溯</a> <a class="post-tag" href="/tags/%E6%8E%92%E5%BA%8F/">排序</a> <a class="post-tag" href="/tags/%E6%95%B0%E5%AD%A6/">数学</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">文章内容</div><nav id="toc"></nav></div><script src="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.js"></script></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4 mt-5"><div id="related-posts" class="mb-2 mb-sm-4"><h3 class="pt-2 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/PAT-Online-Map-&-Birds-in-Forest/"><div class="card-body"> <em class="small" data-ts="1660570740" data-df="YYYY/MM/DD" > 2022/08/15 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>PAT-Online Map & Birds in Forest</h3><div class="text-muted small"><p> A1111 Online Map 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63...</p></div></div></a></div><div class="card"> <a href="/posts/PAT-Build-A-Binary-Search-Tree-&-Root-of-AVL-Tree-&-Social-Clusters/"><div class="card-body"> <em class="small" data-ts="1660145880" data-df="YYYY/MM/DD" > 2022/08/10 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>PAT-Build A Binary Search Tree & Root of AVL Tree & Social Clusters</h3><div class="text-muted small"><p> A1099 Build A Binary Search Tree #include&amp;lt;iostream&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;queue&amp;gt; using namespace std; struct node { int val, left, right; }; co...</p></div></div></a></div><div class="card"> <a href="/posts/PAT-Forever-&-Merging-Linked-Lists-&-Postfix-Expression-&-Dijkstra-Sequence/"><div class="card-body"> <em class="small" data-ts="1661767920" data-df="YYYY/MM/DD" > 2022/08/29 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>PAT-Forever & Merging Linked Lists & Postfix Expression & Dijkstra Sequence</h3><div class="text-muted small"><p>     算法笔记基本上刷了一遍了（有些没看，哈夫曼树、欧几里得算法、组合数、提高篇（6）和专题扩展都没看），这几天模拟训练下子，过几天回学校了把没看的看看。     2h22min91分，四道题都写完了，但第一题和第三题没拿满分，第一题差3分，第三题差6分。最后剩7min的时候，第一题查出问题了，94分，但第三题到最后也没改对。 A1160 Forever 1 2 3 4 5 6 7 ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/PAT-Emergency-&-Gas-Station/" class="btn btn-outline-primary" prompt="上一篇"><p>PAT-Emergency & Gas Station</p></a> <a href="/posts/PAT-Online-Map-&-Birds-in-Forest/" class="btn btn-outline-primary" prompt="下一篇"><p>PAT-Online Map & Birds in Forest</p></a></div></div></div></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a> <a class="post-tag" href="/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/">图形学</a> <a class="post-tag" href="/tags/%E6%A8%A1%E6%8B%9F/">模拟</a> <a class="post-tag" href="/tags/%E8%B4%AA%E5%BF%83/">贪心</a> <a class="post-tag" href="/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/">哈希表</a> <a class="post-tag" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/">二叉树的遍历</a> <a class="post-tag" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a> <a class="post-tag" href="/tags/%E5%9B%9E%E6%BA%AF/">回溯</a> <a class="post-tag" href="/tags/%E6%8E%92%E5%BA%8F/">排序</a> <a class="post-tag" href="/tags/%E6%95%B0%E5%AD%A6/">数学</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><footer><div class="container pl-lg-4 pr-lg-4"><div class="d-flex justify-content-between align-items-center text-muted ml-md-3 mr-md-3"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://github.com/username">CALL1CE</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span></p></div><div class="footer-right"><p class="mb-0">本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，采用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题。</p></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js"></script> <script> (function () { function updateMermaid(event) { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { const mode = event.data.message; if (typeof mermaid === "undefined") { return; } let expectedTheme = (mode === ModeToggle.DARK_MODE ? "dark" : "default"); let config = {theme: expectedTheme}; /* Re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function () { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } let initTheme = "default"; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Create mermaid tag */ $("pre").has("code.language-mermaid").each(function () { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<pre class=\"mermaid\">${svgCode}</pre>`); }); mermaid.initialize(mermaidConf); window.addEventListener("message", updateMermaid); })(); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lazysizes@5.3.2/lazysizes.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/zh.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/unregister.js"></script>
