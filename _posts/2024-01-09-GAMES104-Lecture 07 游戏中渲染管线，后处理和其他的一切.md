---
title: GAMES104-Lecture 07 游戏中渲染管线，后处理和其他的一切
date: 2024-01-09 16:48:00 +0800
categories: [Computer Graphics, GAMES104]
tags: [图形学, 学习笔记]

pin: false
author: 
    name: CALL1CE
    link: https://space.bilibili.com/9330604
toc: true
comments: true
math: true
mermaid: true

---

## Ambient Occlusion

* 在每一个可看见的点处，它的可看见的正半球面，只有部分可以看到天光，另一部分被周围的几何遮挡住了

[![pFp4EqO.jpg](https://s11.ax1x.com/2024/01/09/pFp4EqO.jpg)](https://imgse.com/i/pFp4EqO)

### Precomputed AO

* 提前烘培出的一张AO纹理

### Screen Space Ambient Occlusion(SSAO)

[![pFp4AsK.jpg](https://s11.ax1x.com/2024/01/09/pFp4AsK.jpg)](https://imgse.com/i/pFp4AsK)

* 首先从screen打出一条ray，hit到一个点p，从那个点处生成一个球，在这个球的范围内采样多个点

* 从camera分别向上一步中的采样点发出射线，看是交到screen的哪个像素，取出该像素的depth buffer并与采样点的深度对比，采样点更深说明p被遮挡

* 根据采样点更深和更浅的数量的比例来估计AO

* 问题是这个球不太对，应该是半球，沿着法线方向的半球(SSAO+)

### HBAO - Horizon-based Ambient Occlusion

[![pFp4kM6.jpg](https://s11.ax1x.com/2024/01/09/pFp4kM6.jpg)](https://imgse.com/i/pFp4kM6)

* 从某个点发射ray，去找能看到天顶的最大仰角，找一圈就能获得一个看不到天顶的区域

### GTAO - Ground Truth-based Ambient Occlusion

[![pFp4CGR.jpg](https://s11.ax1x.com/2024/01/09/pFp4CGR.jpg)](https://imgse.com/i/pFp4CGR)

* 使用一个多项式拟合方程来计算出一个值，作为AO

### Ray-Tracing Ambient Occlusion

* 射线

## Fog

### Depth Fog

* 从眼睛处看出去，随着距离的增加，降低透明度
  
  * Linear、Exp、Exp Squared

### Height Fog

[![pFp4PR1.jpg](https://s11.ax1x.com/2024/01/09/pFp4PR1.jpg)](https://imgse.com/i/pFp4PR1)

* 有一个高度，高度以下都是最大的fog值，高度以上的fog以指数的速度递减

### Voxel-based Volumetric Fog

* 把相机空间进行Voxelize（非均匀），离眼睛近的地方切得更密

* 进行Ray-marching

## Anti-aliasing

### Reasons

* 本质是因为屏幕分辨率是有限的

* 几何的边只要不是横平竖直就会产生aliasing

* Texture采样（使用mipmap）

* 高光采样

### Super-sample Anti-aliasing(SSAA) and Multi-sample AA(MSAA)

* SSAA：4倍渲染分辨率、4倍z-buffer、4倍frame-buffer、4倍光栅化，最后再滤波

* MSAA：4倍z-buffer、4倍frame-buffer、4倍光栅化，最后只对需要的像素计算权重来shading（边缘）

### FXAA(Fast Approximate Anti-aliasing)

[![pFp4ixx.jpg](https://s11.ax1x.com/2024/01/09/pFp4ixx.jpg)](https://imgse.com/i/pFp4ixx)

* 先把颜色转换到亮度空间，然后用一个十字形滤波找到边界：对于一个像素M，找到其上下左右四个像素NSWE，然后算出这五个像素的最大值和最小值，如果最大值和最小值的差大于设定的阈值，就是边界

[![pFp4uid.jpg](https://s11.ax1x.com/2024/01/09/pFp4uid.jpg)](https://imgse.com/i/pFp4uid)

* 然后对边界处横向和纵向算一下Offset Direction（哪个方向的颜色变化大），横向计算和纵向计算的卷积核有略微的差距，横向计算的卷积核中间一列是负的，纵向计算的卷积核中间一行是负的；对比后先确认是横向还是纵向，确认后再对比是向右还是向左（向上或者向下）

[![pFp4KJA.jpg](https://s11.ax1x.com/2024/01/09/pFp4KJA.jpg)](https://imgse.com/i/pFp4KJA)

* 然后进行Edge Searching Algorithm：
  
  * 把刚才找到的边缘像素对（比如M和N像素是一对）作为初始像素对，然后从垂直方向开始search（比如MN像素对，就是往左右开始找），找到和自己这个像素对差距比较大的两组像素对作为这个边的两端
  
  * 然后比较左右两端的到M这个像素对的长度，根据长度进行运算，到底是听自己的还是听其他像素的（也就是要混合）

[![pF9MLU1.jpg](https://s11.ax1x.com/2024/01/10/pF9MLU1.jpg)](https://imgse.com/i/pF9MLU1)

[![pF9MHb9.jpg](https://s11.ax1x.com/2024/01/10/pF9MHb9.jpg)](https://imgse.com/i/pF9MHb9)

### TAA(Temporal Anti-aliasing)

* 这一帧，使用前一帧进行运算，时序上的抗走样

## Post-process

### Bloom 光晕

* 人眼类似相机，不能完美聚焦在一个平面

* 人眼的材质更像是半透明材质，光进来会发撒

* 方法：
  
  * 先取出高亮部分：计算Luminace，超过某个阈值就算高亮
  
  * 先降采样，然后上一个Gaussian Blur，放大后再加回去（有权重）

[![pF9MqER.jpg](https://s11.ax1x.com/2024/01/10/pF9MqER.jpg)](https://imgse.com/i/pF9MqER)

### Tone Mapping 曝光

[![pF9M43T.jpg](https://s11.ax1x.com/2024/01/10/pF9M43T.jpg)](https://imgse.com/i/pF9M43T)

* 为了解决阳光直射的地方亮度太高，阴影地方亮度太低，比如天空过曝

* 使用Filmic s-curve将一个范围，如[0,40]的颜色映射到[0,1]

* ACES曲线，更加专业

### Color Grading 调色

* Lookup Table(LUT)：原始的一个颜色和我想调到的一个色相空间的映射

## Rendering Pipeline

[![pF9M5gU.jpg](https://s11.ax1x.com/2024/01/10/pF9M5gU.jpg)](https://imgse.com/i/pF9M5gU)

### Forward Rendering

* 按顺序渲染：遍历每一个mesh，遍历每一束光，计算shading

* Transparent Sorting
  
  * 有透明物质的话，先绘制不透明物质，多个透明物质需要由远及近地绘制

### Deferred Rendering

[![pF9M7DJ.jpg](https://s11.ax1x.com/2024/01/10/pF9M7DJ.jpg)](https://imgse.com/i/pF9M7DJ)

* 延迟渲染

* 先把所有的物体渲染一遍，写到G-Buffer

* 然后对于每一个像素，计算每一个光的效果

* 优点：方便加点光源，容易Debug

* 缺点：G-Buffer很费

### Tile - based Rendering

[![pF9MIvF.jpg](https://s11.ax1x.com/2024/01/10/pF9MIvF.jpg)](https://imgse.com/i/pF9MIvF)

* 将画面分成块

* 光也会被切到每一块里

[![pF9MTu4.jpg](https://s11.ax1x.com/2024/01/10/pF9MTu4.jpg)](https://imgse.com/i/pF9MTu4)

* depth-range optimization：按深度分出一个区域，一个光源只照一个范围内的物体

### Forward+(Tile - based Forward) Rendering

### Cluster-based Rendering

[![pF9LsbR.jpg](https://s11.ax1x.com/2024/01/11/pF9LsbR.jpg)](https://imgse.com/i/pF9LsbR)

### Visibility Buffer

[![pF9L6V1.jpg](https://s11.ax1x.com/2024/01/11/pF9L6V1.jpg)](https://imgse.com/i/pF9L6V1)

* 把几何信息和材质信息剥离，用Visibility Buffer把几何信息存下来

* 查询效率更高

## Real Rendering Pipeline

* 资源管理，当pipeline很复杂的时候就很难进行资源管理

* Vulkan等api开放硬件的api，因为有很多多线程，如果锁加不好就会出问题

### Frame Graph

[![pF9LDKJ.jpg](https://s11.ax1x.com/2024/01/11/pF9LDKJ.jpg)](https://imgse.com/i/pF9LDKJ)

* 表达渲染本身的前后关系、依赖关系

## Render to Monitor

### Screen Tearing

[![pF9Lrr9.jpg](https://s11.ax1x.com/2024/01/11/pF9Lrr9.jpg)](https://imgse.com/i/pF9Lrr9)

* 画面撕裂，因为引擎渲染的每一帧时间是不一致的，但屏幕的帧率是一样

* V-Sync Technology：等frame buffer写完以后，等到显示器刷新后一整个显示

### Variable Refresh Rate

* 游戏渲染帧率和显示器刷新率同步
