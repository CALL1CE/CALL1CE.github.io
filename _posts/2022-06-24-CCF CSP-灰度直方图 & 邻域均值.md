---
title: CCF CSP-灰度直方图 & 邻域均值
date: 2022-06-24 18:06:00 +0800
categories: [算法刷题, CCF CSP]
tags: [模拟, 数字图像处理]

pin: false
author: 
    name: CALL1CE
    link: https://space.bilibili.com/9330604
toc: true
comments: true
math: false
mermaid: true

---

    听说山大夏令营要机试，内容是csp类型的题，暂时就先停停PAT吧，等8月份再开刷，到时候也没项目做了，可以专心准备机试了，估计还有大概一周左右山大就要开营了，先刷一周CSP好了，熟悉下题型。 争取每天两三道吧。

## 202104-1. [灰度直方图](http://118.190.20.162/view.page?gpid=T128)

```cpp
#include<iostream>
#include<vector>
using namespace std;
int main()
{

    int n, m, L;//n行m列，灰度级L
    cin>>n>>m>>L;
    vector<int>  diagram(L, 0);
    for(int i = 0; i < n*m; i++)
    {
        int tmp;//储存灰度 
        cin>>tmp;
        diagram[tmp]++;
    }
    for(int i = 0; i < L; i++)
    {
        if(i == 0) cout<<diagram[i];
        else cout<<" "<<diagram[i];
    }

} 
```

    这道题不难，就是鼓捣了半天DevC++这个编译器，不得不说，有点点难用，不过捣鼓好了，接下来就是刷题了。

## 202104-2. [邻域均值](http://118.190.20.162/view.page?gpid=T127)

```cpp
#include<iostream>
#include<vector>
using namespace std;
int main()
{
    //n图像宽高，L灰度级，r邻域半径，t阈值（L好像是用不到的） 
    int n,L,r,t;
    cin>>n>>L>>r>>t;//读取数据
    vector< vector<int> > bmp(n, vector<int>(n, 0)) ;
    //将像素数据储存到二维数组中 
    for(int i = 0; i < n; i++)
    {
        for(int j = 0; j < n; j++)
        {
            cin>>bmp[i][j];
        }
    }
    //统计每个像素 每一行的前缀和
    vector< vector<int> > prefixBmp(n, vector<int>(n, 0));
    for(int i = 0; i < n; i++)
    {
        int sum = 0;//每行都归0
        for(int j = 0; j < n; j++)
        {
            //等于这像素之前的灰度和 + 本像素的灰度 
            prefixBmp[i][j] = sum + bmp[i][j];
            sum = prefixBmp[i][j];
        } 

    }
    //开始统计较暗处的个数
    int ans = 0;
    //判断每个像素是不是暗处 
    for(int i = 0; i < n; i++)
    {
        for(int j = 0; j < n; j++)
        {
            //统计该位置的邻域大小
            int a,b,c,d;//分别代表邻域的 起始终止 列序号 和 行序号 
            a = (j - r >= 0 ) ? (j - r) : 0;//如果起始列越界那就0
            b = (j + r < n) ? (j + r) : (n - 1);//如果终止列号越界那就n-1
            c = (i - r >= 0) ? (i - r) : 0;//如果起始行越界，那就0
            d = (i + r < n) ? (i + r) : (n - 1);//如果中止行越界，那就n - 1；
            //统计这片区域的大小，即像素个数
            int areaCnt = (b - a + 1) * (d - c + 1);
            //统计这片区域的灰度和
            int greySum = 0;
            //算每一行即可 
            for(int p = c; p <= d; p++)
            {
                //利用前缀和数组 
                greySum += prefixBmp[p][b] - prefixBmp[p][a] + bmp[p][a];
            } 
            //判断是否小于等于阈值 
            if(greySum <= t * areaCnt) ans++;
        }
    } 
    cout<<ans;

}
```

    一遍AC，不愧是数字图像处理拿优秀的我哈哈哈哈。使用前缀和数组节省开销，别的就没什么需要注意的了。
