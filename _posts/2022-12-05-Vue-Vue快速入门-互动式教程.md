---
title: Vue快速入门-互动式教程
date: 2022-12-05 2:33:00 +0800
categories: [前端, Vue]
tags: [学习笔记]

pin: false
author: 
    name: CALL1CE
    link: https://space.bilibili.com/9330604
toc: true
comments: true
math: true
mermaid: true

---

    把[互动式教程](https://cn.vuejs.org/tutorial/#step-1)过了一遍，里面涉及了很多基础内容，整理一下，方便以后查阅

## 1. 声明式渲染

```
<script>
export default {
  data() {
    return {
      message: 'Hello World!',
      counter: {
        count: 0
      }
    }
  }
}
</script>

<template>
  <h1>{{ message }}</h1>
  <p>Count is: {{ counter.count }}</p>
</template>
```

    `data` 组件选项声明响应式状态，该选项应该是一个返回对象的函数，我目前的理解就是，data函数返回的变量像是一个类的成员，在`export defaul`的作用域内都需要用`this`来调用，但在模板中却不需要。响应式大概就是当这些变量发生变化时，就会响应并刷新

    每两个变量要用`,`隔开，不然会报错甚至无法运行

## 2. Attribute绑定

```
<script>
export default {
  data() {
    return {
      titleClass: 'title'
    }
  }
}
</script>

<template>
  <h1 :class="titleClass">Make me red</h1>
  <h1 v-bind:class="titleClass">Make me red</h1>
</template>

<style>
.title {
  color: red;
}
</style>
```

    **指令**是由 `v-` 开头的一种特殊 attribute。它们是 Vue 模板语法的一部分。

    就是把某个值绑定到该元素的某个属性上，比如把`titleClass`这个变量的值`title`赋给`h1`这一行的元素的class属性

## 3. 事件监听

```
<script>
export default {
  data() {
    return {
      count: 0
    }
  },
  methods: {
    increment() {
      this.count++
    }
  }
}
</script>

<template>
  <button v-on:click="increment">{{ count }}</button>
  <button @click="increment">count is: {{ count }}</button>
</template>
```

    我们可以使用 `v-on` 指令监听 DOM 事件(文档对象模型)：

## 4. 表单绑定

```
<script>
export default {
  data() {
    return {
      text: ''
    }
  }
}
</script>

<template>
  <input v-model="text" placeholder="Type here">
  <p>{{ text }}</p>
</template>
```

    表单绑定，其实就是把input输入的值动态地赋给text，使用`v-model`就可以，相当方便

## 5. 条件渲染

```
<script>
export default {
  data() {
    return {
      awesome: true
    }
  },
  methods: {
    toggle() {
      this.awesome = !this.awesome
    }
  }
}
</script>

<template>
  <button @click="toggle">toggle</button>
  <h1 v-if="awesome">Vue is awesome!</h1>
  <h1 v-else>Oh no 😢</h1>
</template>
```

    if判断而已，很简单，注意，此处使用了methods选项，一般把函数方法都放在这里面

## 6. 列表渲染

```
<script>
// 给每个 todo 对象一个唯一的 id
let id = 0

export default {
  data() {
    return {
      newTodo: '',
      todos: [
        { id: id++, text: 'Learn HTML' },
        { id: id++, text: 'Learn JavaScript' },
        { id: id++, text: 'Learn Vue' }
      ]
    }
  },
  methods: {
    addTodo() {
      this.todos.push({ id: id++, text: this.newTodo })
      this.newTodo = ''
    },
    removeTodo(todo) {
      this.todos = this.todos.filter((t) => t !== todo)
    }
  }
}
</script>

<template>
  <form @submit.prevent="addTodo">
    <input v-model="newTodo">
    <button>Add Todo</button>    
  </form>
  <ul>
    <li v-for="todo in todos" :key="todo.id">
      {{ todo.text }}
      <button @click="removeTodo(todo)">X</button>
    </li>
  </ul>
</template>
```

    这里有一个难点，不提前知道的话，肯本不会做，就是这一行：`this.todos = this.todos.filter((t) => t !== todo)`，这个是什么意思呢，这个是正则表达式，第一次接触，相当于：

```javascript
fuction(x)
{
    return(x != todo)

}
```

    还有就是，往数组里面塞元素，直接塞个{}括住就行

## 7. 计算属性

```
<script>
let id = 0

export default {
  data() {
    return {
      newTodo: '',
      hideCompleted: false,
      todos: [
        { id: id++, text: 'Learn HTML', done: true },
        { id: id++, text: 'Learn JavaScript', done: true },
        { id: id++, text: 'Learn Vue', done: false }
      ]
    }
  },
  computed: {
    filteredTodos() {
      return this.hideCompleted
        ? this.todos.filter((t) => !t.done)
        : this.todos
    }
  },
  methods: {
    addTodo() {
      this.todos.push({ id: id++, text: this.newTodo, done: false })
      this.newTodo = ''
    },
    removeTodo(todo) {
      this.todos = this.todos.filter((t) => t !== todo)
    }
  }
}
</script>

<template>
  <form @submit.prevent="addTodo">
    <input v-model="newTodo">
    <button>Add Todo</button>
  </form>
  <ul>
    <li v-for="todo in filteredTodos" :key="todo.id">
      <input type="checkbox" v-model="todo.done">
      <span :class="{ done: todo.done }">{{ todo.text }}</span>
      <button @click="removeTodo(todo)">X</button>
    </li>
  </ul>
  <button @click="hideCompleted = !hideCompleted">
    {{ hideCompleted ? 'Show all' : 'Hide completed' }}
  </button>
</template>

<style>
.done {
  text-decoration: line-through;
}
</style>
```

    [计算属性](https://cn.vuejs.org/guide/essentials/computed.html)。我们可以使用 `computed` 选项声明一个响应式的属性，它的值由其他属性计算而来。计算属性会自动跟踪其计算中所使用的到的其他响应式状态，并将它们收集为自己的依赖。计算结果会被缓存，并只有在其依赖发生改变时才会被自动更新。

    在这也就是`hideCompleted`改变时才会更新

## 8. 生命周期和模板引用

```
<script>
export default {
  mounted() {
    this.$refs.p.textContent = 'mounted!'
  }
}
</script>

<template>
  <p ref="p">hello</p>
</template>
```

    这一行`<p ref="p">hello</p>`元素的模板引用ref属性设置为p，p也就加到了this.$refs，可以通过它来访问这个元素的内容，mounted的生命周期比较靠后，在挂载之后调用mounted，也就是`<p ref="p">hello</p>`出现后才会调用，而且会在最后一次出现之后调用

## 9. 侦听器

```
<script>
export default {
  data() {
    return {
      todoId: 1,
      todoData: null
    }
  },
  methods: {
    async fetchData() {
      this.todoData = null
      const res = await fetch(
        `https://jsonplaceholder.typicode.com/todos/${this.todoId}`
      )
      this.todoData = await res.json()
    }
  },
  mounted() {
    this.fetchData()
  },
  watch: {
    todoId() {
      this.fetchData()
    }
  }
}
</script>

<template>
  <p>Todo id: {{ todoId }}</p>
  <button @click="todoId++">Fetch next todo</button>
  <p v-if="!todoData">Loading...</p>
  <pre v-else>{{ todoData }}</pre>
</template>
```

    其实就是`watch` 选项来侦听 `count` 属性的变化，当 `count` 改变时，侦听回调将被调用

## 10. 组件

```
<script>
import ChildComp from './ChildComp.vue'

export default {
  components: {
    ChildComp
  }
}
</script>

<template>
  <ChildComp />
</template>
```

```
<template>
  <h2>A Child Component!</h2>
</template>
```

    先在子组件的`props`中声明一个变量，这个变量可以让父组件传值，使用绑定即可

## 11. Props

```
<script>
import ChildComp from './ChildComp.vue'

export default {
  components: {
    ChildComp
  },
  data() {
    return {
      greeting: 'Hello from parent'
    }
  }
}
</script>

<template>
  <ChildComp :msg="greeting" />
</template>
```

```
<script>
export default {
  props: {
    msg: String
  }
}
</script>

<template>
  <h2>{{ msg || 'No props passed yet' }}</h2>
</template>
```

    先在子组件的`props`中声明一个变量，这个变量可以让父组件传值，使用绑定即可

## 12. Emits

```
<script>
import ChildComp from './ChildComp.vue'

export default {
  components: {
    ChildComp
  },
  data() {
    return {
      childMsg: 'No child msg yet'
    }
  }
}
</script>

<template>
  <ChildComp @response="(msg) => childMsg = msg" />
  <p>{{ childMsg }}</p>
</template>
```

```
<script>
export default {
  emits: ['response'],
  created() {
    this.$emit('response', 'hello from child')
  }
}
</script>

<template>
  <h2>Child component</h2>
</template>
```

    `this.$emit()` 的第一个参数是事件的名称。其他所有参数都将传递给事件监听器。

    父组件可以使用 `v-on` 监听子组件触发的事件——这里的处理函数接收了子组件触发事件时的额外参数并将它赋值给了本地状态

## 13. 插槽

```
<script>
import ChildComp from './ChildComp.vue'

export default {
  components: {
    ChildComp
  },
  data() {
    return {
      msg: 'from parent'
    }
  }
}
</script>

<template>
  <ChildComp>Message: {{ msg }}</ChildComp>
</template>
```

```
<template>
  <slot>Fallback content</slot>
</template>
```

    在子组件中，可以使用 `<slot>` 元素作为插槽出口 (slot outlet) 渲染父组件中的插槽内容 (slot content)：

    就是msg传给了子组件的slot
