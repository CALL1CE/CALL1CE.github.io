---
title: GAMES104-Lecture 04 游戏引擎中的渲染实践
date: 2023-10-03 14:53:00 +0800
categories: [Computer Graphics, GAMES104]
tags: [图形学, 学习笔记]

pin: false
author: 
    name: CALL1CE
    link: https://space.bilibili.com/9330604
toc: true
comments: true
math: true
mermaid: true

---

## Rendering Sysytem in Games

### Theory

* 算法，辐射度算法，30fps算realtime，10fps算可交互

### chanllenges

* 想要是实现的效果都相当复杂，各种算法不一样，还要加后处理、光照运算

* 在游戏环境中要跑在现在的计算硬件中，所以不是光理论可行就行了

* 帧率是稳定的，高分辨率

* 只能使用10%的应用资源

### Rendering on Game Engine

* 工程技术更新迭代迅速，会随着硬件、环境的变化而迭代

* 实践的软件工程

### Outline of Rendering

* 基础gpu硬件、组织架构、可视裁剪

* 现代游戏中的光照模型、材质系统、shader模型

* 子系统：地形、天空、后处理

* 流水线、延迟渲染、绘制内容的管理、前言的tiled-base rendering

## Building Blocks of Rendering

* 流水线

* 介绍cg的部分......感觉可以可以转到games101

* 投影、光栅化、着色

* 纹理采样

## Understand the Hardware

* 使用独立的显卡来进行这些复杂的计算，极大地释放cpu

### SIMD and SIMT

[![pPOQ7yd.jpg](https://z1.ax1x.com/2023/10/03/pPOQ7yd.jpg)](https://imgse.com/i/pPOQ7yd)

* simd(single instruction Multiple Date)：单指令、多数据的数据运算，就是四维向量，也就是说一个指令同时完成四个加减法

* simt(single instruction Multiple Threads)：如歌计算内核很小，但有很多个，一个指令让很多核去计算，极可能使用同样的代码，每个核访问自己的数据，所以跑的非常快

### GPU Architecture

[![pPOQHOA.jpg](https://z1.ax1x.com/2023/10/03/pPOQHOA.jpg)](https://imgse.com/i/pPOQHOA)

+ 费米架构
  
  * GPC(Graphics Processing Cluster)：图形处理集群，专用硬件区用于计算、光栅化、着色、纹理
  
  * SM(Streaming Multiprocessor)：装了很多的core
  
  * Texture Units
  
  * CUDA Core
  
  * Warp

### Data Flow from CPU to GPU

* 尽可能数据单向传输，尽可能不从GPU读数据

* Cache：内存固然快，但依然比缓存慢百倍

### GPU Bounds

* ALU Bounds：数学运算太多了，导致其他步骤都在等数学运算

* Memory Bounds

* TMU(Texture Mapping Unit) Bound

* BW(BandWidth) Bound

### Architecture

* 硬件结构一直在变

* 手机的架构也不一样

[![pPOQTQH.jpg](https://z1.ax1x.com/2023/10/03/pPOQTQH.jpg)](https://imgse.com/i/pPOQTQH)

## Renderable

[![pPOQ5WD.jpg](https://z1.ax1x.com/2023/10/03/pPOQ5WD.jpg)](https://imgse.com/i/pPOQ5WD)

* 可绘制的，不是所有的go都要绘制

* Mesh、Vertex、Index

* 每个顶点都要存一个法向

* 材质
  
  * 材质模型：phong、pbr
  
  * 纹理

* shader：首先是源码，其次又是数据

## Render Objects

* 将顶点数据、材质、纹理交给gpu，再让gpu按shader执行，就会渲染出东西来

* Mesh会有subMesh，其中使用index来划分，有offset

[![pPOQoSe.jpg](https://z1.ax1x.com/2023/10/03/pPOQoSe.jpg)](https://imgse.com/i/pPOQoSe)

* 相同的材质和纹理放在pool管理，绘制物体时就会去找（享元模式）

[![pPOQqeI.jpg](https://z1.ax1x.com/2023/10/03/pPOQqeI.jpg)](https://imgse.com/i/pPOQqeI)

* 定义和实例：实例去引用定义

* 把整个场景的物体根据材质去排序，把相同材质的物体分组，设置一次材质就形成一组submesh，计算量相同，但速度会变快

* GPU Batch Rendering

## Visibility Culling

* 可见性裁剪

* 包围盒

* PVS(Potential Visibility Set)：先用BSP将房间分成小格子，每个格子通过Portal链接，在其中一个格子时，只看到部分的格子，从而减少绘制；这个思想还是很有用的

[![pPOQOTP.jpg](https://z1.ax1x.com/2023/10/03/pPOQOTP.jpg)](https://imgse.com/i/pPOQOTP)

* GPU Culling：显卡来做裁剪，生成遮挡物的深度图，然后选择是否丢掉

[![pPOQLwt.jpg](https://z1.ax1x.com/2023/10/03/pPOQLwt.jpg)](https://imgse.com/i/pPOQLwt)

## Texture Compression

* 纹理压缩

* 在游戏引擎里不能用诸如jpg这样很好的图片压缩算法，因为这些算法不能快速随机访问

* 所以都是基于Block Compression思想，分块压缩

[![pPO1Hat.jpg](https://z1.ax1x.com/2023/10/03/pPO1Hat.jpg)](https://imgse.com/i/pPO1Hat)

## Authoring Tools of Modeling

* 几何建模

* 雕刻

* 扫描

* 程序化生成

[![pPO1bIP.jpg](https://z1.ax1x.com/2023/10/03/pPO1bIP.jpg)](https://imgse.com/i/pPO1bIP)

## Cluster-Based Mesh Pipeline

* 可以用一个算法，基于数据凭空生成几何，并且根据距离来选择精度

* 可以产生无限的细节

[![pPO17VI.jpg](https://z1.ax1x.com/2023/10/03/pPO17VI.jpg)](https://imgse.com/i/pPO17VI)


