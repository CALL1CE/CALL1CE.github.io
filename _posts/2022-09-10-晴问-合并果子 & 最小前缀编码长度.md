---
title: 晴问-合并果子 & 最小前缀编码长度
date: 2022-09-10 12:22:00 +0800
categories: [算法刷题]
tags: [哈夫曼树]

pin: false
author: 
    name: CALL1CE
    link: https://space.bilibili.com/9330604
toc: true
comments: true
math: false
mermaid: true

---

    昨天上午有课，失策了，今天把哈夫曼树看了，没想到算法笔记里的哈夫曼树只是一笔带过了，并不难，今天就到此为止了哈哈，回去背专业课了，明天看看字符串hash和kmp算法（kmp算法之前在力扣刷过，相当于复习了）

## [合并果子](https://sunnywhy.com/sfbj/9/8)

```cpp
#include<iostream>
#include<vector>
#include<queue>
using namespace std;
priority_queue<int, vector<int>, greater<int>> q;//小顶堆
int n, ans, tmp;
int main()
{
	cin >> n;
	while (n--)
	{
		cin >> tmp;
		q.push(tmp);
	}
	while (q.size() > 1)
	{
		int x = q.top();
		q.pop();
		int y = q.top();
		q.pop();
		q.push(x + y);
		ans += x + y;
	}
	cout << ans;
}
```

    哈夫曼树思想的一种实际问题求解，其实没有用到构建树，有点像贪心。使用了小顶堆，非常不错。所谓哈夫曼树就是一棵，n个节点，都为叶子节点，带权路径最短的树。

## [最小前缀编码长度](https://sunnywhy.com/sfbj/9/8/373)

```cpp
#include<iostream>
#include<vector>
#include<queue>
using namespace std;
priority_queue<int, vector<int>, greater<int>> q;//小顶堆
int n, ans, tmp, v[26];
int main()
{
	string s;
	cin >> s;
	for (char c : s)
	{
		v[c - 'A']++;
	}
	for (int i : v)
	{
		if (i > 0) q.push(i);
	}
	while (q.size() > 1)
	{
		int x = q.top();
		q.pop();
		int y = q.top();
		q.pop();
		q.push(x + y);
		ans += x + y;
	}
	cout << ans;
}
```

    这道题依旧没有建哈夫曼树，直接用的小顶堆，直接把字母出现次数当作权值即可。
