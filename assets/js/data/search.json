[ { "title": "CSAPPLAB-DATALAB", "url": "/posts/CSAPPLAB-DATALAB/", "categories": "Computer Basic, CSAPPP", "tags": "Integer, Float", "date": "2025-12-01 00:00:00 +0000", "snippet": "1//1/* * bitXor - x^y using only ~ and &amp; * Example: bitXor(4, 5) = 1 * Legal ops: ~ &amp; * Max ops: 14 * Rating: 1 */int bitXor(int x, int y) { return ~(x &amp; y) &amp; (~((~x)&amp...", "content": "1//1/* * bitXor - x^y using only ~ and &amp; * Example: bitXor(4, 5) = 1 * Legal ops: ~ &amp; * Max ops: 14 * Rating: 1 */int bitXor(int x, int y) { return ~(x &amp; y) &amp; (~((~x)&amp;(~y)));}​\t这道题目，只允许使用~和&amp;来实现异或操作，首先异或就是两位不一样的时候，结果是1，也就是一个是0一个是1。​\t我先是遍历了所有可能的情况： x&amp;y：两位同时是1就是1，找到了两位同时是1的位 ~x&amp;y：y是1时，x是0结果是1，找到了y是1时，xy不同的位 x&amp;~y：x是1时，x是0结果是1，找到了y是1时，xy不同的位 ~x&amp;~y：xy同时是0结果就是1，找到了两位同时是0的位​\t其实这个时候，我发现用x&amp;y和~x&amp;~y可以找到两位同时是0或者1的位，那么除了这些情况，不就是二者不同的情况吗？2/* * tmin - return minimum two's complement integer * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 4 * Rating: 1 */int tmin(void) { return 1&lt;&lt;31;}​\t这个直接左移即可。3/* * isTmax - returns 1 if x is the maximum, two's complement number, * and 0 otherwise * Legal ops: ! ~ &amp; ^ | + * Max ops: 10 * Rating: 1 */int isTmax(int x) { int tmin = ~x; return !((1+x)^(tmin))&amp;!!(x^(~0));}//优化int isTmax(int x) { int y = x + 1; return !( (y ^ ~x) ) &amp; !!y;}​\t这道题目是利用tmax的性质： tmax+1=tmin ~tmax = tmin​\t但是还有一个值符合上面的性质，就是-1，那么直接排除掉-1即可​\t优化：我之前是用^直接对比-1这个值，但是实际上可以利用-1+1=0这个性质，这个写法会省两个操作4/* * allOddBits - return 1 if all odd-numbered bits in word set to 1 * where bits are numbered from 0 (least significant) to 31 (most significant) * Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 12 * Rating: 2 */int allOddBits(int x) { int a = 0xAA;\tint b = a &lt;&lt; 2;\tint c = b | a;\tint d = c &lt;&lt; 4;\tint e = d | c;\tint f = e &lt;&lt; 8;\tint g = f | e;\tint h = g &lt;&lt; 16;\tint i = h | g;\tint j = x &amp; i;\tint k = j ^ i; return !k;}//优化int allOddBits(int x) { int mask = 0xAA; // 00000000 00000000 00000000 10101010 mask = mask | (mask &lt;&lt; 8); // 00000000 00000000 10101010 10101010 -&gt; 0x0000AAAA mask = mask | (mask &lt;&lt; 16); // 10101010 10101010 10101010 10101010 -&gt; 0xAAAAAAAA return !((~x) &amp; mask);}​\t这道题就是判断所有奇数位是不是1，如果是，那么返回1，不是就返回0。​\t那么问题来了，怎么判断全部奇数位是不是1呢？ 只要让x和全部奇数位为1的数也就是0xAAAAAAAA进行一个&amp;，如果x的全部奇数位是1的话（不管偶数位是不是1），得到的答案就是0xAAAAAAAA，否则答案一定不是0xAAAAAAAA。​\t那么怎么返回0或者1呢？ 根据第3题的写法，使用^就能判断x&amp;0xAAAAAAAA是否是完全一样的，完全一样返回0，这时候取个！就可以了​\t那么允许使用的的int范围在0-255，怎么获得0xAAAAAAAA呢？ 就不断左移和|就可以了​\t优化：​\t我之前貌似对0xaa有点错误的理解……实际上只需要两次就可以做出来。​\t对x取~后，如果奇数位所有都是1，那么最后(~x) &amp; mask就是0，反之，但凡有一位奇数位是0，那么(~x) &amp; mask就会存在1。5/* * negate - return -x * Example: negate(1) = -1. * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 5 * Rating: 2 */int negate(int x) { return ~x+1;}​\t算负数，直接取反加1秒杀了。6//3/* * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters '0' to '9') * Example: isAsciiDigit(0x35) = 1. * isAsciiDigit(0x3a) = 0. * isAsciiDigit(0x05) = 0. * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 15 * Rating: 3 */int isAsciiDigit(int x) { return (!(x^0x30)|!(x^0x31)|!(x^0x32)|!(x^0x33)|!(x^0x34)|!(x^0x35)|!(x^0x36)|!(x^0x37)|!(x^0x38)|!(x^0x39));}​\t我先想到了暴力做法，通过^可以遍历一下x是不是‘0’-‘9’，是那么必然有一项是0其他都是大于0的数，取个！就能把这个关系变成1和0，再一|，但凡有一个1就是1，也就是说在‘0‘-‘9’。但是这不符合条件要求的15个ops。int isAsciiDigit(int x) { return (!((x+(~0x30+1)&gt;&gt;31) | ((0x39+(~x+1))&gt;&gt;31)));}​\t我又想到一个办法，就是让通过x-0x30&gt;=0和0x39&gt;=0同时满足就可以，之前我一直以为！是可以直接判断正负的，我以为大于0的取！会得到0，小于等于0的取！会得到1，然而事实是，0取！得到1，非0取！得到0。 通过x»31&amp;1可以判断正负，但是这里不需要&amp;1，因为最后会有！兜。int isAsciiDigit(int x) { int lower = x + (~0x30 + 1); // x - 0x30 int upper = 0x39 + (~x + 1); // 0x39 - x int sign = (lower | upper) &gt;&gt; 31; // 只要有一个为负，最高位就是1（-1） return !sign; // sign=0 → 在区间内 → 返回1；sign=-1 → 返回0}​\t这个方式可以少一个op。7/* * conditional - same as x ? y : z * Example: conditional(2,4,5) = 4 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 16 * Rating: 3 */int conditional(int x, int y, int z) { int a = ~(!x)+1; return (y &amp; (~a)) | (z &amp; a);} ​\t我首先想要实现的一点是y oprator expression = 全0或者本身，z同理，这样的话二者取 就可以得到y或者z了。 ​\t那么我又开始遍历了 y &amp; 0 = 0 y &amp; 全1 = y（全1其实也就是-1） y | -1 = -1 y | 0 = y​\t那么现在问题变成了怎么根据x的变换来获得0和-1，那么已知通过！可以根据x是否非0得到0或1，那么再取个负数，0还是0，1就变成全1了也就是-1，颗秒！邦邦邦邦！8/* * isLessOrEqual - if x &lt;= y then return 1, else return 0 * Example: isLessOrEqual(4,5) = 1. * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 24 * Rating: 3 */int isLessOrEqual(int x, int y) { int isOppositeSign = (x^y)&gt;&gt;31&amp;1; int isxNeg = x&gt;&gt;31&amp;1; int sameSign = (y + (~x + 1))&gt;&gt;31&amp;1; //conditional(isOppositeSign, isxNeg, !sameSign) int a = ~(!isOppositeSign)+1; return (isxNeg &amp; (~a)) | (!sameSign &amp; a);}//优化：int isLessOrEqual(int x, int y) { int sx = (x &gt;&gt; 31) &amp; 1; // x 的符号：x&lt;0 → 1, 否则 0 int sy = (y &gt;&gt; 31) &amp; 1; // y 的符号 int signDiff = sx ^ sy; // 符号是否不同：1 表示异号 int diff = y + (~x + 1); // y - x int sd = (diff &gt;&gt; 31) &amp; 1; // y-x 的符号：&lt;0 → 1, 否则 0 // 情况1：符号不同时，只要 x&lt;0,y&gt;=0 就一定 x&lt;=y // signDiff=1 且 sx=1 → x&lt;=y // 情况2：符号相同，则看 y-x 是否非负（sd=0） // signDiff=0 且 sd=0 → x&lt;=y return (signDiff &amp; sx) | ((!signDiff) &amp; (!sd));}​\t这道题直接复用上道题目的答案了。这道题其实本意还是判断正负，x&lt;=y挪过去，y-x&gt;=0也就是判断y-x的符号是否是正数即可，也就是说，右移31位&amp;1后，如果结果是0，那么这个不等式就成立了，这也是为什么没有把y往左挪的原因。如果是x-y&lt;=0，那么同样的方式右移31位&amp;1后，如果结果是1，只能说明x-y&lt;0，等于不在里面。​\t好了，现在要解决第二个问题，也就是溢出问题，那么现在开始考虑，什么时候会溢出？ xy同号的时候，肯定不会溢出，直接用上面的公式判断不等式结果即可 xy异号的时候，就可能会溢出了，那么异号又有两种情况 x正y负，上面的不等式肯定不成立，也就是返回0 x负y正，上面的不等式肯定成立，也就是返回1 ​\t那么现在问题变成了，先判断xy是同号还是异号，如果是同号，那么就走不等式判断正负的分支。如果xy是异号，那么就根据x是否是负数，来返回1或者0即可。​\t优化：其实类似conditionnal的判断，这样子省一些ops。9//4/* * logicalNeg - implement the ! operator, using all of * the legal operators except ! * Examples: logicalNeg(3) = 0, logicalNeg(0) = 1 * Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 12 * Rating: 4 */int logicalNeg(int x) { int y = ~x+1; return (((x&gt;&gt;31&amp;(~0)))|(y&gt;&gt;31&amp;(~0)))+1;}//优化：int logicalNeg(int x) { int y = ~x + 1; return ((x &gt;&gt; 31) | (y &gt;&gt; 31)) + 1;}//优化：int logicalNeg(int x) { return ((x | (~x + 1)) &gt;&gt; 31) + 1;}​\t这道题要利用0的特性，也就是0的负数还是0，但是正数和负数时相反数，但但是，tmin的负数还是本身，奇妙的是，如果用»31&amp;1的方式来判断正负的话，对于0而言就永远是0，所以对0取正负然后用»31&amp;1判断就只有一种情况也就是00（指的是正数符号是0，负数符号也是0），对于非0值x，当对x取负数的时候，x»31&amp;1有三种情况，就是11（如tmin正数负数都是本身，都是负数）、10、01，所以这样就把0和非0区分开了。​\t还有一点就是0要返回1，非0要返回0，这一点比较反人类，不能»31&amp;1得到x的正负数后直接用|，因为这样的结果是相反的，所以此处得用个小巧思，让判断正负的式子&amp;-1，这样的话，如果就变成了-1-1、-10、0-1、00，然后|之后加一就行了。​\t优化：补码中，正负数右移就是0x00000000 或 0xFFFFFFFF，不需要&amp;全1了。​\t优化：其实真正需要的就只有符号位罢了，所以先正负数|了，再取符号也可以，省ops。10/* howManyBits - return the minimum number of bits required to represent x in * two's complement * Examples: howManyBits(12) = 5 * howManyBits(298) = 10 * howManyBits(-5) = 4 * howManyBits(0) = 1 * howManyBits(-1) = 1 * howManyBits(0x80000000) = 32 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 90 * Rating: 4 */int howManyBits(int x) { int a = conditional(x&gt;&gt;31&amp;1,~x,x);\tint pos = 0;\tint bits16, bits8, bits4, bits2, bits1,bits0;\tbits16 = !!(a &gt;&gt; 16) &lt;&lt; 4;\ta = a &gt;&gt; bits16;\tbits8 = !!(a &gt;&gt; 8) &lt;&lt; 3;\ta = a &gt;&gt; bits8;\tbits4 = !!(a &gt;&gt; 4) &lt;&lt; 2;\ta = a &gt;&gt; bits4;\tbits2 = !!(a &gt;&gt; 2) &lt;&lt; 1;\ta = a &gt;&gt; bits2;\tbits1 = !!(a &gt;&gt; 1);\ta = a &gt;&gt; bits1; bits0 = !!(a);\tpos = bits16 + bits8 + bits4 + bits2 + bits1 + bits0;\treturn pos+1;}//优化：int howManyBits(int x) { int sign = x &gt;&gt; 31; // 0 or -1 int a = x ^ sign; // x&gt;=0 -&gt; a=x; x&lt;0 -&gt; a=~x int bits16, bits8, bits4, bits2, bits1, bits0; int pos; bits16 = !!(a &gt;&gt; 16) &lt;&lt; 4; a &gt;&gt;= bits16; bits8 = !!(a &gt;&gt; 8) &lt;&lt; 3; a &gt;&gt;= bits8; bits4 = !!(a &gt;&gt; 4) &lt;&lt; 2; a &gt;&gt;= bits4; bits2 = !!(a &gt;&gt; 2) &lt;&lt; 1; a &gt;&gt;= bits2; bits1 = !!(a &gt;&gt; 1); a &gt;&gt;= bits1; bits0 = a; // 此时 a 是 0 或 1 pos = bits16 + bits8 + bits4 + bits2 + bits1 + bits0; return pos + 1;}​\t这道题目首先要理解一个定义，也就是有效位。对于正数而言，有效位就是1所在最高位，因为最高位的1左侧的0只是拓展符号位，如000110这个二进制数的前3个0，相当于一个0的作用，也就是符号位，和0110值是一样的。对于负数而言，恰恰相反，有效位就是0所在的最高位，因为最高位0左侧的1相当于拓展符号位，如11101，左边3个1相当于一个1的作用，也就是和101值是一样的。​\t正数还好理解，负数怎么理解呢？其实可以这么想，对于11101来说，相当于\\(-2^4+2^3+2^2+2^0\\)​\t而前三项加起来，就是\\(-2^2\\)，这样的话，不就相当于101了吗，所以前置1都是拓展符号位。​\t所以对于负数，最开始取个~就能和正数一样计算了，算1所在下标，然后+1即可。​\t然后要解决的问题就是怎么算出来最高位的下标，用二分法即可。先判断是在高16位还是低16位，如果在高16位，那么就把这个数右移16位，否则就不用管。然后在去判断是在当前这个数的高8位还是低8位，以此类推，就能得到最高位1所在的下标。​\t对于0和-1这两个数来说，符号位也可以作为数字位，可以想象1这个二进制数，作为补码，也就是\\(-2^0\\)，不就是-1吗。​\t优化：用^全0或者全1，就可以得到本身或者取~。11//float/* * floatScale2 - Return bit-level equivalent of expression 2*f for * floating point argument f. * Both the argument and result are passed as unsigned int's, but * they are to be interpreted as the bit-level representation of * single-precision floating point values. * When argument is NaN, return argument * Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while * Max ops: 30 * Rating: 4 */unsigned floatScale2(unsigned uf) {\tunsigned s = uf &gt;&gt; 31 &amp; 1;\tunsigned maskSExp = (~0 &lt;&lt; 23);\tunsigned exp = (uf &amp; maskSExp) &lt;&lt; 1 &gt;&gt; 24;\tunsigned maskM = ~maskSExp;\tunsigned m1 = uf &amp; maskM;\tunsigned newExp;\tunsigned newM1;\tif (!(exp | 0)) {\t\tnewExp = m1 &gt;&gt; 22 &amp; 1;\t\tnewM1 = m1 &lt;&lt; 1;\t}\telse {\t\tnewExp = exp + !!(exp ^ 0xff);\t\tnewM1 = m1;\t}\treturn (s &lt;&lt; 31) | (newExp &lt;&lt; 23) | (newM1 &amp; maskM);}//优化：unsigned floatScale2(unsigned uf) { unsigned s = uf &amp; 0x80000000u; // 符号位 unsigned exp = (uf &gt;&gt; 23) &amp; 0xFF; // 指数字段 [0..255] unsigned frac = uf &amp; 0x7FFFFFu; // 尾数字段 // 情况 1：exp == 255，NaN 或 Inf，按题意原样返回 if (exp == 0xFF) { return uf; } // 情况 2：exp == 0，0 或 非规格化数 if (exp == 0) { // 非规格化：倍乘就是 frac 左移一位 frac &lt;&lt;= 1; // 如果左移后“顶到了隐藏位”，变成规格化数 if (frac &amp; 0x800000u) { // 检查 bit23 exp = 1; frac &amp;= 0x7FFFFFu; // 清掉 bit23，只保留 22:0 } } else { // 情况 3：规格化有限数：指数 +1 exp += 1; // 如果加到 255，说明溢出到 +Inf，尾数清零 if (exp == 0xFF) { frac = 0; } } return s | (exp &lt;&lt; 23) | frac;}​\t这道题首先要明白浮点数的定义和乘法和特殊条件。​\t首先，浮点数由三部分构成，S、Exp、M。其中S一位，表示符号位，Exp八位是阶码，M二十三位是尾数。​\t其次E=Exp-Bias，\\(Bias=2^k-1\\)，对于8位，就是127。​\t一个浮点数计算结果就是：\\((−1)^S*M*2^E\\)。​\t所以乘以2还是很容易的，一般情况下就直接让exp+1即可，这里需要考虑几个特殊情况，主要就是非规格化数部分。​\t第一，当exp全1的时候，那么乘以2，此时不需要+1，全1要么是正无穷或者负无穷，要么就是Nan。​\t第二，当exp全0的时候，那么乘以2，就不一定是+1了，此时还有两个情况，如果尾数没有前置1，那么只是把尾数左移即可，exp不用变。如果有前置1，仍然需要把尾数左移，只是这时候，从非规格化数到了规格化数，所以exp就要+1了，记得尾数左移要截断那个1，因为此时变成了潜在1。​\t优化：​\t首先，exp的算法可以直接用uf右移去算；其次，我疏忽了一个情况，就是exp=254，frac不为0，此时乘以2应该是inf，而不是Nan12/* * floatFloat2Int - Return bit-level equivalent of expression (int) f * for floating point argument f. * Argument is passed as unsigned int, but * it is to be interpreted as the bit-level representation of a * single-precision floating point value. * Anything out of range (including NaN and infinity) should return * 0x80000000u. * Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while * Max ops: 30 * Rating: 4 */int floatFloat2Int(unsigned uf) { unsigned s = uf &gt;&gt; 31; unsigned exp = (uf&gt;&gt;23) &amp; 0xff; unsigned frac = uf&amp;0x7fffff; unsigned m = (1u&lt;&lt;23)|frac; unsigned ans; int E = exp - 127; if(E &lt;= -1) return 0; if(E &gt; 30) return 0x80000000u; if(E&gt;=23){ ans = m&lt;&lt;(E-23); }else{ ans = m&gt;&gt;(23-E); } if(s) return ~ans+1; return ans;}​\t规格化数：E=exp-Bias(127)，非规格化数E=1-Bias，这道题完全不用考虑非规格化数，所以直接算规格化数即可，尾数是有个潜在1的，把这个注意好就可以。13/* * floatPower2 - Return bit-level equivalent of the expression 2.0^x * (2.0 raised to the power x) for any 32-bit integer x. * * The unsigned value that is returned should have the identical bit * representation as the single-precision floating-point number 2.0^x. * If the result is too small to be represented as a denorm, return * 0. If too large, return +INF. * * Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. Also if, while * Max ops: 30 * Rating: 4 */unsigned floatPower2(int x) { if(x &gt;= 128) return 0x7f800000; if(x &lt; -149) return 0; if(x&lt;=-127) return 1u &lt;&lt; (x+149); return (x + 127)&lt;&lt;23;}​\t这道题目主要就是考虑几个情况。​\t第一，x&gt;=128也就是当exp全1的时候，E=exp-Bias=255-127=128的时候就已经需要返回inf了，也就是正无穷。​\t第二，当x&lt;-149也就是当exp全0的时候，E=1-Bias=1-127=-126，然后尾数是1，-126-23=-149，此时是能取到的最小值，那么小于-149的，就返回0。​\t第三，当介于[-127,-149]之间的，都属于非规格化数，exp还是全0，尾数不停左移即可。​\t第三就是其他范围都属于规格化数，算出来exp即可，尾数就是全0。Results第一次全通过时的分数：Correctness Results Perf ResultsPoints Rating Errors Points Ops Puzzle1 1 0 2 7 bitXor1 1 0 2 1 tmin1 1 0 2 9 isTmax2 2 0 2 11 allOddBits2 2 0 2 2 negate3 3 0 2 12 isAsciiDigit3 3 0 2 7 conditional3 3 0 2 18 isLessOrEqual4 4 0 2 10 logicalNeg4 4 0 2 41 howManyBits4 4 0 2 23 floatScale24 4 0 2 17 floatFloat2Int4 4 0 2 9 floatPower2Score = 62/62 [36/36 Corr + 26/26 Perf] (167 total operators)" }, { "title": "GPU硬件架构、运行机制", "url": "/posts/GPU%E7%A1%AC%E4%BB%B6%E6%9E%B6%E6%9E%84-%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/", "categories": "Computer Graphics, HardWare", "tags": "图形学, 学习笔记", "date": "2024-06-29 06:55:00 +0000", "snippet": "1、GPU是如何与CPU协调工作的？ 将主存的处理数据复制到显存中 CPU指令驱动GPU GPU中的每个运算单元并行处理。此步会从显存存取数据 GPU将显存结果传回主存 2、GPU也有缓存机制吗？有几层？它们的速度差异多少？ 部分架构的GPU与CPU类似，也有多级缓存结构：寄存器、L1缓存、L2缓存、GPU显存、系统显存 存储类型 寄存...", "content": "1、GPU是如何与CPU协调工作的？ 将主存的处理数据复制到显存中 CPU指令驱动GPU GPU中的每个运算单元并行处理。此步会从显存存取数据 GPU将显存结果传回主存 2、GPU也有缓存机制吗？有几层？它们的速度差异多少？ 部分架构的GPU与CPU类似，也有多级缓存结构：寄存器、L1缓存、L2缓存、GPU显存、系统显存 存储类型 寄存器 共享内存 L1缓存 L2缓存 纹理、常量缓存 全局内存 访问周期 1 1~32 1~32 32~64 400~600 400~600 由此可见，shader直接访问寄存器、L1、L2缓存还是比较快的，但访问纹理、常量缓存和全局内存非常慢，会造成很高的延迟上面的多级缓存结构可被称为“CPU-Style”，还存在GPU-Style的内存架构：这种架构的特点是ALU多，GPU上下文（Context）多，吞吐量高，依赖高带宽与系统内存交换数据3、GPU的渲染流程有哪些阶段？它们的功能分别是什么？ 程序通过图形API(DX、GL、WEBGL)发出drawcall指令，指令会被推送到驱动程序，驱动会检查指令的合法性，然后会把指令放到GPU可以读取的Pushbuffer中 经过一段时间或者显式调用flush指令后，驱动程序把Pushbuffer的内容发送给GPU，GPU通过主机接口（Host Interface）接受这些命令，并通过前端（Front End）处理这些命令 在图元分配器(Primitive Distributor)中开始工作分配，处理indexbuffer中的顶点产生三角形分成批次(batches)，然后发送给多个GPCs(Graphics Processing Cluster)。这一步的理解就是提交上来n个三角形，分配给这几个GPC同时处理。 在GPC中，每个SM中的Poly Morph Engine负责通过三角形索引(triangle indices)取出三角形的数据(vertex data)，即图中的Vertex Fetch模块 在获取数据之后，在SM中以32个线程为一组的线程束(Warp)来调度，来开始处理顶点数据[SM的warp调度器会按照顺序分发指令给整个warp，单个warp中的线程会锁步(lock-step)执行各自的指令，如果线程碰到不激活执行的情况也会被遮掩(be masked out);warp中的指令可以被一次完成，也可能经过多次调度，例如通常SM中的LD/ST(加载存取)单元数量明显少于基础数学操作单元] 一旦warp完成了vertex-shader的所有指令，运算结果会被Viewport Transform模块处理，三角形会被裁剪然后准备栅格化，GPU会使用L1和L2缓存来进行vertex-shader和pixel-shader的数据通信 接下来这些三角形将被分割，再分配给多个GPC，三角形的范围决定着它将被分配到哪个光栅引擎(raster engines)，每个raster engines覆盖了多个屏幕上的tile，这等于把三角形的渲染分配到多个tile上面。也就是像素阶段就把按三角形划分变成了按显示的像素划分了 SM上的Attribute Setup保证了从vertex-shader来的数据经过插值后是pixel-shade是可读的 GPC上的光栅引擎(raster engines)在它接收到的三角形上工作，来负责这些三角形的像素信息的生成（同时会处理裁剪Clipping、背面剔除和Early-Z剔除） 接下来的阶段就和vertex-shader中的逻辑步骤完全一样，但是变成了在像素着色器线程中执行 最后一步，现在像素着色器已经完成了颜色的计算还有深度值的计算，在这个点上，我们必须考虑三角形的原始api顺序，然后才将数据移交给ROP(render output unit，渲染输入单元)，一个ROP内部有很多ROP单元，在ROP单元中处理深度测试，和framebuffer的混合，深度和颜色的设置必须是原子操作，否则两个不同的三角形在同一个像素点就会有冲突和错误 4、Early-Z技术是什么？发生在哪个阶段？这个阶段还会发生什么？会产生什么问题？如何解决？ 早期GPU的渲染管线的深度测试是在像素着色器之后才执行（下图），这样会造成很多本不可见的像素执行了耗性能的像素着色器计算，后来，为了减少像素着色器的额外消耗，将深度测试提至像素着色器之前（下图），这就是Early-Z技术的由来。 发生在光栅化阶段，此时光栅引擎(raster engines)负责接收到的三角形的像素信息的生成（同时会处理裁剪Clipping、背面剔除和Early-Z剔除）问题：深度数据冲突（depth data hazard）假设数值深度值5已经经过Early-Z即将写入Frame Buffer，而深度值10刚好处于Early-Z阶段，读取并对比当前缓存的深度值15，结果就是10通过了Early-Z测试，会覆盖掉比自己小的深度值5，最终frame buffer的深度值是错误的结果避免深度数据冲突的方法之一是在写入深度值之前，再次与frame buffer的值进行对比5、SIMD和SIMT是什么？它们的好处是什么？co-issue呢？SIMD_ADD c, a, bSIMD（Single Instruction Multiple Data）是单指令多数据，在GPU的ALU单元内，一条指令可以处理多维向量（一般是4D）的数据SIMT（Single Instruction Multiple Threads，单指令多线程）是SIMD的升级版，可对GPU中单个SM中的多个Core同时处理同一指令，并且每个Core存取的数据可以是不同的,上述指令会被同时送入在单个SM中被编组的所有Core中，同时执行运算，但a、b 、c的值可以不一样co-issueco-issue是为了解决SIMD运算单元无法充分利用的问题。例如下图，由于float数量的不同，ALU利用率从100%依次下降为75%、50%、25%为了解决着色器在低维向量的利用率低的问题，可以通过合并1D与3D或2D与2D的指令。例如下图，DP3指令用了3D数据，ADD指令只有1D数据，co-issue会自动将它们合并，在同一个ALU只需一个指令周期即可执行完但是，对于向量运算单元（Vector ALU），如果其中一个变量既是操作数又是存储数的情况，无法启用co-issue技术于是标量指令着色器（Scalar Instruction Shader）应运而生，它可以有效地组合任何向量，开启co-issue技术，充分发挥SIMD的优势6、GPU是并行处理的么？若是，硬件层是如何设计和实现的？是，SIMD和SIMT的设计不同，硬件中有很多执行单元并行执行shader指令SIMD：汇编代码会被GPU推送到执行上下文（Execution Context），然后ALU会逐条获取（Detch）、解码（Decode）汇编指令，并执行SIMT：汇编指令有所不同，变成了SIMT特定指令代码，并且Context以Core为单位组成共享的结构，同一个Core的多个ALU共享一组Context如果有多个Core，就会有更多的ALU同时参与shader计算，每个Core执行的数据是不一样的，可能是顶点、图元、像素等任何数据7、GPC、TPC、SM是什么？Warp又是什么？它们和Core、Thread之间的关系如何？ GPC（图形处理簇） TPC（纹理处理簇） SM（流多处理器） Warp（线程束）GPU被划分成多个GPCs(Graphics Processing Cluster)，每个GPC拥有多个SM（SMX、SMM）和一个光栅化引擎(Raster Engine)，它们其中有很多的连接，最显著的是Crossbar，它可以连接GPCs和其它功能性模块（例如ROP或其他子系统）程序员编写的shader是在SM上完成的。每个SM包含许多为线程执行数学运算的Core（核心）。例如，一个线程可以是顶点或像素着色器调用。这些Core和其它单元由Warp Scheduler驱动，Warp Scheduler管理一组32个线程作为Warp（线程束）并将要执行的指令移交给Dispatch UnitsTPC有多组SM8、顶点着色器（VS）和像素着色器（PS）可以是同一处理单元吗？为什么？在早期的GPU，顶点着色器和像素着色器的硬件结构是独立的，它们各有各的寄存器、运算单元等部件。这样很多时候，会造成顶点着色器与像素着色器之间任务的不平衡。对于顶点数量多的任务，像素着色器空闲状态多；对于像素多的任务，顶点着色器的空闲状态多于是，为了解决VS和PS之间的不平衡，引入了统一着色器架构（Unified shader Architecture）。用了此架构的GPU，VS和PS用的都是相同的Core。也就是，同一个Core既可以是VS又可以是PS这样就解决了不同类型着色器之间的不平衡问题，还可以减少GPU的硬件单元，压缩物理尺寸和耗电量。此外，VS、PS可还可以和其它着色器（几何、曲面、计算）统一为一体9、像素着色器（PS）的最小处理单位是1像素吗？为什么？会带来什么影响？不是，是2x2的最小单元像素块 简化和加速像素分派的工作 精简SM的架构，减少硬件单元数量和尺寸 降低功耗，提高效能比 无效像素虽然不会被存储结果，但可辅助有效像素求导函数这种设计虽然有其优势，但同时，也会激化过绘制（Over Draw）的情况，损耗额外的性能。比如下图中，白色的三角形只占用了3个像素（绿色），按我们普通的思维，只需要3个Core绘制3次就可以了，但是，由于上面的3个像素分别占据了不同的像素块（橙色分隔），实际上需要占用12个Core绘制12次，这就会额外消耗300%的硬件性能，导致了更加严重的过绘制情况10、Shader中的if、for等语句会降低渲染效率吗？为什么？会，SM中有多个core，对于simd来说，每个core有一个alu，由于simd特性，每个alu的数据不一样，导致if-else语句在某些ALU中执行的是true分支（黄色），有些ALU执行的是false分支（灰蓝色），这样导致很多ALU的执行周期被浪费掉了（即masked out），拉长了整个执行周期。最坏的情况，同一个SM中只有1/8（8是同一个SM的线程数，不同架构的GPU有所不同）的利用率。为什么1/8：因为simd只能并行执行相同的指令，所以当不同线程需要执行不同分支时，GPU必须按顺序执行每个分支，而不是并行执行11、如下图，渲染相同面积的图形，三角形数量少（左）的还是数量多（右）的效率更快？为什么？不同三角形的接缝处出现断层，说明同一个像素块如果分属不同的三角形，就会分配到不同的SM进行处理。由此推断，相同面积的区域，如果所属的三角形越多，就会导致分配给SM的次数越多，消耗的渲染性能也越多12、GPU Context是什么？有什么作用？ GPU Context代表了GPU计算的状态。 在GPU中拥有自己的虚拟地址。 GPU 中可以并存多个活跃态下的Context。越多Context可用就越可以提升运算单元的吞吐量由于SIMT技术的引入，导致很多同一个SM内的很多Core并不是独立的，当它们当中有部分Core需要访问到纹理、常量缓存和全局内存时，就会导致非常大的卡顿（Stall） 13、造成渲染瓶颈的问题很可能有哪些？该如何避免或优化它们？ 减少CPU和GPU的数据交换： 合批（Batch） 减少顶点数、三角形数 视锥裁剪 BVH Portal BSP OSP 避免每帧提交Buffer数据 CPU版的粒子、动画会每帧修改、提交数据，可移至GPU端。 减少渲染状态设置和查询 例如：glGetUniformLocation 会从GPU内存查询状态，耗费很多时间周期。 避免每帧设置、查询渲染状态，可在初始化时缓存状态。 启用GPU Instance 开启LOD 避免从显存读数据 减少过绘制： 避免Tex Kill操作 避免Alpha Test 避免Alpha Blend 开启深度测试 Early-Z 层次Z缓冲（Hierarchical Z-Buffering，HZB） 开启裁剪： 背面裁剪 遮挡裁剪 视口裁剪 剪切矩形（scissor rectangle） 控制物体数量 粒子数量多且面积小，由于像素块机制，会加剧过绘制情况 植物、沙石、毛发等也如此 Shader优化： 避免if、switch分支语句 避免for循环语句，特别是循环次数可变的 减少纹理采样次数 禁用clip或discard操作 discard 是在片段着色器（Fragment Shader）中使用的一条指令，用于丢弃当前片段。这意味着被 discard 的片段不会被写入帧缓冲区，也不会进行后续的深度测试、模板测试等操作 clip 是 HLSL（High-Level Shading Language）中的一个函数，用于丢弃片段。它的功能与 discard 类似，但 clip 可以接受一个浮点值作为参数。如果该值小于零，则丢弃当前片段 减少复杂数学函数调用 参考资料深入GPU硬件架构及运行机制" }, { "title": "GAMES105-Lecture 03 Character Kinematics", "url": "/posts/GAMES105-Lecture-03-Character-Kinematics/", "categories": "Computer Graphics, GAMES105", "tags": "图形学, 学习笔记", "date": "2024-04-20 06:55:00 +0000", "snippet": "PPT由于PPT内容非常非常丰富，博客里只贴几张最重要的，还有很多重要的还是直接去ppt里看吧本章节ppt地址Character KinematicsSkeleton 围绕joint旋转 joint之间叫body、bone、link Kinematics of Chain 正向运动学：每个关节局部坐标系的方向等价于夫关节的局部坐标系的方向乘以当前坐标系的旋转 Q就是每个关节...", "content": "PPT由于PPT内容非常非常丰富，博客里只贴几张最重要的，还有很多重要的还是直接去ppt里看吧本章节ppt地址Character KinematicsSkeleton 围绕joint旋转 joint之间叫body、bone、link Kinematics of Chain 正向运动学：每个关节局部坐标系的方向等价于夫关节的局部坐标系的方向乘以当前坐标系的旋转 Q就是每个关节局部坐标系的一个朝向 每个关节有一个局部坐标系，当Q0关节发生旋转，会带动后面所有关节旋转，此时Q1相对于Q0局部坐标系的相对位置是不会改变的，如果要计算Q1局部坐标系原点在世界坐标系的位置，等价于做一个变换，将相对于Q0局部坐标系下的位置转换到世界坐标系 Kinematics of a Character 可以把角色建模为由多个链条连接到同一个根节点构成的树形的一个结构 通常会把根节点设置在腰部 每个关节有不同的性质，比如旋转的范围和方式 膝盖、手肘：hinge、revolute joint（铰链、转动关节） 髋、肩：ball-and-socket joint(球状关节) 自由度：是指一个物理系统需要多少参数可以唯一、准确地描述它当前的状态 xyz的位移和旋转，就是6个自由度 Pose Parameters：root决定角色整体的位置和方向、每个内部关节旋转的表示 为了计算方便，对顺序也有要求，一个关节在参数列表的顺序要比它所有的子关节都要靠前 motion data in a file 在文件开头会先定义一个角色，在每个关节旋转=0的时候（通常叫做T-Pose），每个关节和他的父关节的相对位置关系，接下来就会描述在之前这个定义的基础之上，关节的旋转是多少 BVH files 用欧拉角表示关节旋转，所以也会定义欧拉角的顺序 Format FC AMC FBX Inverse Kinematics 应用比正向运动学更广泛 指定末端点的朝向，通过逆向运动学的算法自动算出每个关节的旋转 IK的解： 无解 多个解（大部分情况） 唯一解 Two-Joint IK 是一个非常简单的常见的问题，比如胳膊和腿 第一个方法： 画两个圆，求出交点，交点就是关节点1的位置 第二个方法： 旋转关节点1，使得关节点0到关节点2的距离等于关节点0到位置x的距离（通过这几个长度，使用余弦公式计算出夹角） 旋转关节点0，使得关节点2和x重合：相当于把向量02旋转到向量0x的位置，那么通过这两个向量做叉乘得到旋转轴，点乘得到旋转角 如果必要的话，以0x为旋转轴旋转关节点0（） IK as an Optimization Problem 解决一个机械臂末关节点的位置和朝向的问题先考虑位置 找到一些列参数θ，使得目标点的位置x减去f(θ) = 0，这是一个求根问题，这个求根问题可以转换成为一个优化问题，下面这个式子是求欧几里得范数也是L2范数，乘以1/2是为了求导时候和平方中和掉，留下一个没有额外系数的导数表达式 从初始位置开始，去找优化的最优点 因为这个优化函数是一个非线性函数，所以一般会用迭代的方法去解（梯度下降） 关键就是如何找到一个比较好的一个方向去更新参数，另外一个就是一个合适的距离去更新参数 找方向：坐标下降法（Coordinate Descent） 参数所对应的坐标轴的方向，沿着某个坐标轴更新参数，更新的距离是在坐标轴这个方向上所对应的目标值最小的那个点 完成更新之后可以换一个坐标轴做同样的行为，然后不断迭代 所以可以保证每次目标值不会增加 这个所谓坐标轴，就是说这个参数本身是一个维度，比如参数a，大小范围是[0,1]，那么就在这个范围去找一个使得目标值最小的a，然后切换到b轴，同理，之后再切回a轴 上面是只有两个轴的情况，多个轴也一样，不过是按顺序一次切换轴，最后循环，叫做(Cyclic Coordinate Descent:CCD)循环坐标下降法 如何从一个向量旋转到和另一个向量重合：先叉乘得到旋转轴，然后点乘得到旋转角度 优点是：实现简单、快 缺点是：因为没有考虑函数本身的性质，只是在坐标轴上变换，所以收敛速度有时候很慢，甚至不收敛；第一个点移动的是最多的；结果对初始点很敏感，在目标点移动过程中求解IK，姿势并不会很稳定 找方向：梯度下降法（Cradient Descent） 梯度算出来的是增长最快的方向，所以向反方向移动就好 对于IK的函数来说，计算它的梯度，就等于，前向运动学函数中对于每一个旋转参数的导数乘上当前这个位置和目标位置的距离差 前面的这个导数经常写成一个矩阵的形式，也就是雅可比矩阵，其中，每个元素是一个joint的所有参数 所以这个方法也叫Jacobian Transpose方法 求解Jacobian矩阵：可以用深度学习框架的自动求导方法来做、也可以通过差分的方法来逐步计算出Jacobian矩阵、还有一个方式，就是计算两个向量的叉乘（假设所有joints是hinge joint，那么关节1的旋转轴是第一个向量，关节1到末端点关节4的向量是第二个向量），得到的叉乘就是Jacobian矩阵的一列 如果不是hinge joint，而是ball joint，可以当成是三个hinge关节重叠在一起，所以一个关节体现在Jacobian矩阵中是三列，每一列就等于 某个欧拉角对应的旋转轴 和 当前关节指向末端点的向量 的叉乘 在做叉乘的这个向量是基于世界坐标系的，但欧拉角呢是基于局部坐标系的，所以欧拉角的坐标轴需要从局部坐标系转换到世界坐标系，x轴可以直接乘以父关节的朝向，但是y、z轴不行，因为y轴是基于x轴内部进行旋转的，所以y轴不仅要乘以父关节的朝向，还要乘以x轴的旋转，z轴除了这两个外还需要乘上y轴的旋转 Jacobian Transpose的方法比ccd收敛更快，但本质上还是一阶方法，所以收敛性还不是非常快，而且计算量大，因为每次迭代都要计算一次Jacobian矩阵的值 Optimality Condition：如果梯度为0，说明无论怎么移动函数值都不会变化，是一个局部极值点 Quadratic Programming 二次规划问题：一个函数是二次函数，A是正定的（是一个对称阵，对于任何一个θ，二次形式是大于等于0），然后可以找到极值点，ik问题可以转换成为一个二次函数求极值的问题，假设J成J的转置可逆，就可以消掉了 Gauss-Newton Method是在J的转置乘J结果是可逆的情况下，可解 Jacobian Inverse Method：使用Jacobian矩阵的伪逆；不同的J有不同的伪逆形式；优点：比Jacobian Transpose更快收敛，但是要计算逆，但逆可能不存在，导致求出的逆值很大，对应一个很大的移动，不稳定，所以在求逆之前，加上一个阻尼项，就有了： Damped Jacobian Inverse Method：而且可以通过给阻尼项乘上一个权重矩阵，来控制不同关节移动的权重 Character IK 很多个地方要移动位置，也可以写成一个优化函数的问题，求和，最后加一个正则项 但通常可以分开来算ik，比如将一个胳膊移动到一个位置x，选定一个根节点（髋关节）和末端节点，也就是最后是整个上半身都会进行调整 FABRIK 启发式方法" }, { "title": "GAMES105-Lecture 02 Math Background", "url": "/posts/GAMES105-Lecture-02-Math-Background/", "categories": "Computer Graphics, GAMES105", "tags": "图形学, 学习笔记", "date": "2024-03-29 10:30:00 +0000", "snippet": "pdf地址：Math BackgroundMatrixRepresentations of 3D Rotation 对于旋转矩阵，因为是正交阵，所以旋转矩阵乘它的转置是单位阵，能得到6个式子，但有9个参数，所以自由度是3 因为旋转矩阵的行列式是+1，引入了一些约束，但只是让解空间从两瓣变成一瓣，并没有改变自由度Interpolation 平移的插值可以由线性插值解决 但是旋转插值不能...", "content": "pdf地址：Math BackgroundMatrixRepresentations of 3D Rotation 对于旋转矩阵，因为是正交阵，所以旋转矩阵乘它的转置是单位阵，能得到6个式子，但有9个参数，所以自由度是3 因为旋转矩阵的行列式是+1，引入了一些约束，但只是让解空间从两瓣变成一瓣，并没有改变自由度Interpolation 平移的插值可以由线性插值解决 但是旋转插值不能简单地由线性插值表示 好的旋转插值： 希望在每一时刻的旋转是合法的（不会变形） 旋转是以一个常数的速度进行插值（速度不会乱变） 旋转矩阵 难以构造 容易应用旋转 难以插值 欧拉角 两种公约：一是沿着局部坐标系的xyz轴旋转，另一种是沿着世界坐标系的xyz轴旋转 万向锁问题：在转的时候，两个轴共线，丢失一个自由度 需要三个参数、十二种顺序、以及两种公约 容易构造、容易应用旋转、容易插值 万向锁问题 如果插值在Π和-Π之间插值，有可能会瞬间转一圈 旋转向量/轴角表示 因为轴是个单位向量，角度是个常数，所以可以相乘得到一个旋转向量 想要旋转的话，需要先把这个旋转向量转化成旋转矩阵，然后用罗德里格旋转公式 难以做两个旋转向量的旋转组合，需要先变换成旋转矩阵然后相乘后再变回旋转向量 容易做插值，但不能保证旋转速度是恒定的，可以通过复杂点的计算来保证 容易构造、难以应用旋转（需要先转换为旋转矩阵）、容易插值、没有万向锁问题 四元数 对二维旋转的拓展 单位四元数和轴角表示涉及的信息是相同的 任何一个三维的旋转可以转为轴角表示 轴角表示可以转化为四元数表示 使用单位四元数对向量进行旋转，为什么是三明治乘法，乘了两个四元数，因为单位四元数里面是θ/2 乘法表示不唯一 旋转组合是两个单位四元数的积 四元数的插值 在四维球壳上找到一个曲线 线性插值后进行单位化得到一个合法四元数 缺点是旋转速度不是恒定的 SLER：Spherical Linear Interpolation来解决速度问题 容易构造、容易应用旋转、容易插值、没有万向锁 " }, { "title": "GAMES105-Lecture 01 Introduction to Character Animation", "url": "/posts/GAMES105-Lecture-01-Introduction-to-Character-Animation/", "categories": "Computer Graphics, GAMES105", "tags": "图形学, 学习笔记", "date": "2024-03-28 10:30:00 +0000", "snippet": "pdf地址：Introduction to Character Animation3D Computer Animation Simulation: rigid bodies,deformable solids,ropes, thin shells, cloth,fluid, smoke, sound…Phenomenon Character Animation: humans, ani...", "content": "pdf地址：Introduction to Character Animation3D Computer Animation Simulation: rigid bodies,deformable solids,ropes, thin shells, cloth,fluid, smoke, sound…Phenomenon Character Animation: humans, animals,virtual creatures,hands, robots,crowds…Behavior 一般一个角色只有二三十个关节数，50到100+参数 把劳动密集型的民工活-&gt; 计算密集型的计算机活 Character Animation Pipeline Forward Kinematics Inverse Kinematics Interpolation Motion Capture Motion Retargeting Motion Graphs/State Machines:重用已有数据，生成新的动作 问题：太复杂，容易出bug Motion Matching:不是完整地播放一个动作，而是在更加细粒度的情况下，比如每一帧结束后，通过一个最近邻搜索，去找到一个新的姿态，同时满足要控制的目标、与当前角色的动作不能差太远保证动作连续性 Learning-based Approaches Motion Generative Models Cross-Modal Motion Synthesis：跨模态动作生成 Problems of Kinematic Methods 物理问题，如穿模 与环境交互的意外动作，动作库中没有 Motion Reconstuction with Sparse 3 Point Tracking Proportional-Derivative(PD) Control trajectory crafting - NaturalMotion: 设计轨迹，然后再根据类似pd控制的方法去进行物理仿真 Spacetime/Trajectory Optimization Abstract Models-simbicon DRL-based Tracking Controllers" }, { "title": "C++高级特性和性能优化", "url": "/posts/C++%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E5%92%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/", "categories": "C++", "tags": "学习笔记", "date": "2024-03-27 07:32:00 +0000", "snippet": "移动语义(C++11) 编译器通过”移动“资源而不是复制它们，来优化临时对象和处理大型的数据结构 两个关键概念： 移动构造函数：参数是右值引用(&amp;&amp;表示)，移动后，源对象通常处于有效但未指定的状态，也就是说这个对象的生命周期还没有结束，它仍然可以被赋予新的资源，或者被销毁，如果对象的生命周期结束，它的析构函数会被调用 移动赋值运算符：类似移动构...", "content": "移动语义(C++11) 编译器通过”移动“资源而不是复制它们，来优化临时对象和处理大型的数据结构 两个关键概念： 移动构造函数：参数是右值引用(&amp;&amp;表示)，移动后，源对象通常处于有效但未指定的状态，也就是说这个对象的生命周期还没有结束，它仍然可以被赋予新的资源，或者被销毁，如果对象的生命周期结束，它的析构函数会被调用 移动赋值运算符：类似移动构造函数，不过是把括号换成了等号 对比值语义，值语义也就是复制资源再赋值，是内置类型(int float double…)的默认行为 RVO与移动区别： MyClass b = MyClass(); 这行代码实际上涉及到了一个叫做“返回值优化”（Return Value Optimization，RVO）的编译器优化技术，而不是移动操作。为了提高效率，编译器可能会选择不创建这个临时对象，而是直接在 b 的存储位置构造这个对象 两种语义的优缺点： 移动语义优点： 减少复制产生的开销，有利于处理大型数据结构或资源密集型对象 简化资源管理（动态分配内存、文件句柄、网络连接）、防止资源泄露、并确保对象超出作用域或重置时被正确清理 针对临时对象进行优化 移动语义缺点： 复杂，实现移动语义需要额外的代码，如移动构造函数和移动赋值函数 有效但未指定的状态，移动后的源对象仍然可用，但内容可能已经无了，处理不当可能出意外 值语义的优点 简单易懂，代码少 可预测，具有值语义的对象生命周期明确，在作用域结束时销毁 独立，修改一个对象不会影响到另一个对象的状态 值语义的切到吗 对于大型数据结构和资源密集型对象，很慢 不适合共享资源，例如不可赋值的文件句柄就不可能使用值语义对象 std::forwarding 允许函数模板将其参数完美转发给另一个函数，保留原始类型（包括是左值还是右值） 如果 CreateObject 函数模板不使用 std::forward，那么即使 FString(“MyActor”) 是一个右值，它也会被当作左值传递给 FActor 的构造函数，这样就会调用左值引用版本的构造函数，而不是更高效的右值引用版本 在非模板函数倒是不会这样，传的是啥就是啥，模板函数会这样是因为在 CreateObject 函数模板中，参数 args 被声明为 Args&amp;&amp; 类型，这是一个通用引用（或转发引用），它可以绑定到左值和右值。但是，一旦参数被绑定到这些通用引用上，它们就变成了左值，因为它们有了名字``` CPPtemplate &lt;typename T, typename… Args&gt;T CreateObject(Args&amp;&amp;… args){ return T(std::forward(args)...);}class FActor{public: FActor(int32 id, FString&amp;&amp; name); // 右值引用构造函数 FActor(int32 id, const FString&amp; name); // 左值引用构造函数 // ...};FString actorName(“MyActor”);FActor actor1 = CreateObject(42, actorName); // 使用左值引用构造函数FActor actor2 = CreateObject(42, FString(\"MyActor\")); // 使用右值引用构造函数### 在UE4中的应用* 容器、字符串、指针、自定义类、结构体都可以，需要注意的是，在自定义类和结构体使用移动语义的时候需要自己实现移动构造函数和移动赋值操作符## 编译时编程* 模板、constexpr、静态断言、类型特征、模板元编程、内联函数和变量、常量折叠### constexpr(C++11)* 声明变量或者函数，在编译时计算表达式和计算值 * 用计算值替换表达式 * 简化、优化依赖这些常量值的代码，如循环展开、常量折叠 * 删除从未执行的分支或条件### 类型特征(C++11)* 类型特征是一组模板和类，在编译时确定类型的属性和特征* 需要头文件&lt;type_traits&gt;* 如std::is_integral&lt;T&gt;、std::is_arithmetic&lt;T&gt;、std::is_same&lt;T, U&gt;、std::is_pointer&lt;T&gt;、std::enable_if&lt;Condition,T&gt;```CPPtemplate &lt;typename T&gt;typename std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value, T&gt;::typesum(T a, T b) { return a + b;} 上面代码意思是，检查T是否是算术类型，如果是，就可以使用这个模板函数，如果不是，就会得到一个编译时错误 std::enable_if&lt;Condition,T&gt;的Condition如果是True，那么就创建T这个type，其type成员就是T std::is_arithmetic则是检查T是否为算术类型，如果是，那么其value成员就是True 为什么要使用类型特征： 实现模板的特化实现，从而提高性能 允许根据类型属性在编译时决策，生成更优化的代码 可以针对类型属性的优化，比如使用std::is_trivially_copyable检查一个类型是否可以通过简单的内存复制来复制其值。这种优化的一个例子是，当你需要复制一个大数组时，如果数组的元素类型是平凡可复制的，那么使用memcpy通常会比逐个元素调用复制构造函数要快得多。这是因为memcpy是专门优化过的，可以利用底层硬件的特性来快速移动大块内存。 类型特征可与SFINAE（替换失败不是错误）一起使用，根据类型的属性有选择地启用或禁用某些函数或类模板特化。这可以帮助避免不必要的运行时检查或分支，从而提高代码效率 编译时优化，生成更高效的代码 更好的代码组织 多态 编译时多态 Lambda函数(c++11)位集(bitset)共享指针容器" }, { "title": "GAMES104-Lecture 12 游戏引擎中的粒子和声效系统", "url": "/posts/GAMES104-Lecture-12-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E7%B2%92%E5%AD%90%E5%92%8C%E5%A3%B0%E6%95%88%E7%B3%BB%E7%BB%9F/", "categories": "Computer Graphics, GAMES104", "tags": "图形学, 学习笔记", "date": "2024-03-25 08:48:00 +0000", "snippet": "Particle 属性：位置、速度、大小、颜色、生命周期 Life Cycle particle emitter：粒子发射器 粒子系统：很多emitter的总和（火焰：spark、flame、smoke） Particle Spawn Position：限制粒子发射的空间 spawn mode可以设置 ...", "content": "Particle 属性：位置、速度、大小、颜色、生命周期 Life Cycle particle emitter：粒子发射器 粒子系统：很多emitter的总和（火焰：spark、flame、smoke） Particle Spawn Position：限制粒子发射的空间 spawn mode可以设置 simulate 重力、空气阻力、风的扰力 每一帧模拟，不需要很复杂的积分 高效的collision Particle Type： billboard particle：始终朝向摄像机 Mesh particle ribbon particle：光带，particle在生成的过程中会拉出一个个的节点，然后用带子连接起来，简单连接会变成折线，所以需要进行样条曲线插值（catmull-rom，这个能保证曲线会经过控制点） Paticle System Rendering Alpha Blending Order 要从最远端的透明物画到最近端的才会正常 Particle Sort 数量太多 全局进行排序，把所有的particle合在一起排，但开销太大， 按emitter排序 ###" }, { "title": "GAMES104-Lecture 11 物理系统：高级应用", "url": "/posts/GAMES104-Lecture-11-%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F-%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8/", "categories": "Computer Graphics, GAMES104", "tags": "图形学, 学习笔记", "date": "2024-02-04 08:48:00 +0000", "snippet": "Character Controller 是一个反物理的系统，摩擦力几乎是无限大的Build a Controller Kinematic Actor：不会受物理规则影响 Shape：胶囊、box、convex 胶囊外有一层边缘，防止和其他物体过近 Collide with environment 碰到环境比...", "content": "Character Controller 是一个反物理的系统，摩擦力几乎是无限大的Build a Controller Kinematic Actor：不会受物理规则影响 Shape：胶囊、box、convex 胶囊外有一层边缘，防止和其他物体过近 Collide with environment 碰到环境比如墙体不能前进时，会滑一下 Stepping：上台阶的时候，把capsule往上添加offset Slope limits：坡度限制 Controller Volume Update：在不同姿态controller体积要变换 Controller Push Objects Standing on Moving Platform：当controller和一个物体站在一起时，会在逻辑上将二者绑定起来 Ragdoll 布娃娃系统 Map Skeleton to Rigid Bodies：把骨骼绑定上Rigid Bodies 需要让TA细调constraints（约束） 用的是animation retargeting的思路，去把ragdoll和原骨骼匹配 参与的节点可以一一对应 Leaf joints沿用之前的animation就行 过渡性骨骼是由前后两根ragdoll的pose插值出来的 不可能永远是ragdoll，是动画和ragdoll混合的，会渐进地从动画转变到ragdoll Powered Ragdoll：Physics-Animation Blending Clothing Animation-based Cloth Simulation：往衣料放上骨骼 Rigid Body-based Cloth Simulation Mesh-based Cloth Simulation Physical Mesh的面片数要低于Render Mesh好几倍 Paint Cloth Simulation Constraints：会在每一个Physical Mesh上画出每一个顶点可以移动的范围 Mass-Spring system 弹簧质点模型 要用spring damping的力（类似摩擦力的东西，防止数值爆炸） 对每一个点受力：重力+风力+空气阻力（取决于速度）+周边所有的弹簧施加的力（弹力和damping力） Verlet积分：将速度转换成位置，数学是等价的，但是位置比速度更稳定 Position Based Dynamics(PBD) 拉格朗日数学 把所有的力学关系描述成了数学的约束，用约束直接解出位置 Self Collision 自穿插问题 加大布料的厚度 把布料仿真的解算得更细，拆出substeps，设置一个maximal speed，在每一个substep检测不要插得太深，弹出来 在布料里面设置一个负的立场，给进入里面的点推出去 Destruction Chunk Hierarchy：把碎片组成一个树状结构 每一层之间的碎片是有连接关系的，是一个图，edge的权重就是硬度，当冲量/硬度超过阈值就会破碎 damage计算，当打到一个点后，力会以圆形分散出去 Build Chunks by Voronoi Diagram 在空间中随机撒几个种子，把空间分割成到每个种子距离都对等的边界（每个点作为圆心，不断增加半径，直到互相碰到，就形成边界） 3D Mesh中 使用 Delauny Triangulation方法生成新的三角形 需要新的texture和coordinates来处理断口处的纹理 可以设置不同的断裂模式：比如均匀、极化 当碎块碎了之后会执行很多回调函数，比如出发音效、粒子效果、navigation更新 Issues： 碎片多了开销大，因为每个碎片都要互相作用，互相做解算 著名破坏系统应用：NVIDIA Blast、Havok Destruction、Chaos Destruction(Epic) Vehicle 载具模型：上面一个缸（车体），下面是轮子（弹簧，悬挂系统） Traction Force：驱动力 Engine会输出一个扭矩，扭矩大代表加速大 会写一个发动机转速、油门、扭矩之间的关系 变速箱、差速器把扭矩拆分到各个轮子 有了扭矩就可以算出驱动力 Suspension Force悬挂力 Tire Forces轮胎力 Longitudinal force：径向力 Lateral force：切向力 重心 太靠前就会不太稳定，飞出去的时候，会头朝下 会对转弯有影响，靠前的话转向力就会不足，因为转向力臂不够大，扭矩不够 Weight Transfer Steering angles：外侧轮转的少，内测多，因为车本身有宽度 Ackermann steering advanced wheel contact single raycast sphere raycast Advanced：PBD/XPBD 拉格朗日力学：把力学关系描述成一系列的约束，用约束反向定义运动 圆周运动约束： 位置约束：位置的模长-半径=0 速度约束：位置约束关于x的导数乘以圆周运动的速度=0 这个J就是夹克比(Jacobian)矩阵 Jacobian矩阵更多的是表达一个趋势的变化量（感觉跟梯度下降很相似） 弹簧约束 PBD-Constraints Projection jacobian矩阵就是算出当前姿态下，每一个joints需要进行扰动的趋势 然后不断迭代地去扰动（感觉像梯度下降找到最优解） 优点：解收敛快、稳定 Extended Position Based Dynamics （XPBD） 硬约束、软约束 " }, { "title": "GAMES104-Lecture 10 游戏引擎中物理系统的基础理论和算法", "url": "/posts/GAMES104-Lecture-10-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA%E5%92%8C%E7%AE%97%E6%B3%95/", "categories": "Computer Graphics, GAMES104", "tags": "图形学, 学习笔记", "date": "2024-02-04 08:48:00 +0000", "snippet": "Physics Actors and ShapesActor static actor dynamic actor Trigger：触发器 Kinematic(No Physics Law) Actor：根据游戏需要进行运动 Actor Shapes Soheres Capsules：用于角色 Box...", "content": "Physics Actors and ShapesActor static actor dynamic actor Trigger：触发器 Kinematic(No Physics Law) Actor：根据游戏需要进行运动 Actor Shapes Soheres Capsules：用于角色 Boxes Convex Meshes：凸包多面体 Triangle Mesh：静态物体，动态的话开销会很大 Height Fields：用于地形 使用上面这些shapes将object包起来 Shape Properties： Mass、Density Center of Mass质心 Friction &amp; Restitution摩擦力、弹力 Forces Gravity、Drag、Friction Impulse冲量（爆炸explosion center -&gt; explosion impulse） Movements 牛顿第一第二定律 Movement under Varying Force Time Integration Explicit(Forward) Euler’s Method:显示欧拉积分，用当前的力算下一时刻的速度，用这一时刻的速度来计算下一个时刻的位置，问题就是积分过程是不收敛的，能量不守恒 Implicit(Backward)Euler’s Method：隐式欧拉法，用下一个时刻的力算出下一时刻的速度来计算下一个时刻的位置，但是能量会衰减。这是稳定的，并不会爆炸 Semi-implicit Euler‘s Method：半隐式欧拉法，用当前时刻的力计算下一时刻的速度，用下一时刻的速度计算下一时刻的位置，此时是假设这一时刻的力没有变化，稳定性高，计算效率高，但是在做简谐运动的时候，使用半隐式计算出来的周期会比ground truth的略长。目前这个方法是性价比最高的 Rigid Body Dynamics Particle Dynamics：质点动力学 Rigid Body Dynamics：刚体动力学 Rotational Inertia：转动惯量 Angular Momentum角动量，角动量守恒 Torque力矩 台球案例 Collision DetectionTwo PhasesBroad Phase初筛 用AABB计算碰撞的可能性 BVH：当环境中的物体发生变化时，更新的成本非常低 Sort and Sweep：把每一个物体的bounding的每个轴的min和max排序，当至少两个轴产生交错的时候，就发现可能有交集；因为大量物体是不动的，所以只对局部会动的物体进行排序 Narrow Phase精细地判断 判断是否重叠 生成碰撞信息：估计橡胶的顶点、相交处的法线、相交的深度 Narrow Phase方案： Basic Shape Intersection Test 球球相交，计算距离和两个球的半径和 胶囊和球相交、胶囊相交 Minkowski Difference-based Methods 点集A+点集B会构造一个新的点集C 比如一个三角形点集B加了一个点A，得到新的点集就相当于三角形B加了一个位移 一个三角形点集B加了一条线点集A，得到新的点集相当于三角形B位移后相对于线进行了一个拖拽而形成了一个凸包 一个三角形点集B加了一个三角形点集A，得到新的点集相当于三角形B位移后相对于三角形A进行了一个拖拽而形成了一个凸包 点A减去三角形点集B，相当于A+（-B） 如果两个三角形点集有交点的话，那么他们相减得到的凸包点集一定会过原点，反之亦然 GJK Algorithm-Walkthrough 将两个凸包求交问题转换为一个凸包是否过原点问题 从A、B中选一个相反的方向，相减能得到凸包的一个顶点C 从顶点连接原点，从这个方向再从AB找两个顶点，获得凸包上一个点D 然后从CD垂直方向继续重复上面的方法，直到得到最后一个三角形CEF，若还没有找到原点，就说明不相交 Separating Axis Theorem(SAT)-Convexity 分离轴定律 判断两个凸多面体是否相交，如果两个没有相交，一定可以找到一个轴，使得两个凸多面体的投影被轴分开 所有的边都要找一遍 在三维case下，不仅要每个面检测，还要检测每一条边 Collision Resolution 在一些碰撞检测后，如何将碰撞的物体分开，是需要解决的问题 Applying Panalty Force：给物体添加力 constraints：约束，当发生碰撞时，给小冲量，然后使用拉格朗日约束进行迭代，迭代冲量 Scene QueryRay Cast Mutiple hits：一条射线出去，返回所有穿过的排序好的object Closest hit：最近的 Any hit：返回所有穿过的不用排序的object Sweep 一个体横扫过去Overlap 给一个shape，问在世界中有没有物体跟这个形状发生了碰撞Efficiency, Accuracy, and DeterminismSimulation Optimization island：将世界分成一个个的island sleep：如果一个地方的物体长时间不会动，那么在外力作用前会使其sleepContinuous Collidion Detection(CCD) 连续碰撞检测 解决穿墙问题，物体速度太快，墙体太薄导致穿墙 把墙做厚一点 CCD方法：做一个保守估计，即物体和环境碰撞的一个安全距离是多少，在安全距离外可以任意移动，在安全距离内就会把substep调密，做更精细的检测 Deterministic Simulation 确定性模拟 也就是说对物理的模拟，相同的操作结果相同（为了使得联网游戏中每个玩家看到的世界相同） requirement 希望不同的终端，物理模拟的步长是一致的（如每秒是60帧） 确定性的模拟顺序 浮点数的稳定性 " }, { "title": "GAMES104-Lecture 09 高级动画技术：动画树、IK和表情动画", "url": "/posts/GAMES104-Lecture-09-%E9%AB%98%E7%BA%A7%E5%8A%A8%E7%94%BB%E6%8A%80%E6%9C%AF-%E5%8A%A8%E7%94%BB%E6%A0%91-IK%E5%92%8C%E8%A1%A8%E6%83%85%E5%8A%A8%E7%94%BB/", "categories": "Computer Graphics, GAMES104", "tags": "图形学, 学习笔记", "date": "2024-02-03 08:48:00 +0000", "snippet": "Advanced Animation TechnologyAnimation Blend LERP：插值，在两种动画（clips）之间插值 根据两个动画的速度计算权重 Align Blend Timeline：把两个循环动画的时间归一化再插值 Blend Space 1D Blend Space：Directional Movement ...", "content": "Advanced Animation TechnologyAnimation Blend LERP：插值，在两种动画（clips）之间插值 根据两个动画的速度计算权重 Align Blend Timeline：把两个循环动画的时间归一化再插值 Blend Space 1D Blend Space：Directional Movement 多个采样点进行插值 2D Blend Space：两个1D正交 因为多个动画clips进行blend会比较费，所以选取离当前点最近的三个动画clips，然后使用重心坐标进行插值 Skeleton Masked Bleding 有些动作只会影响上半身或者下半身 将两种动画拼在一起 Additive Blending 在这个动画中，不仅作用到动画的局部，而且只存动画的变化量，而不存绝对量 作为修饰 但Additive Blending很容易造成不正常的结果 Animation State Machine(ASM) 比如跳跃情况，有三个状态，起跳，空中（jump loop），落地 ASM Definition Cross Fades：平滑切换、frozen切换 Cross Fades Curve Layered ASM：多层次状态机：角色身体的不同部分做不同的动画状态机 Animation Blend Tree 使用树来做运算 LERP Blend Node Additive Blend Node 使用blend tree来计算当前ASM下的一个pose Blend Tree Control Parameters：node search、named variable、control structureAnimation KinematicsInverse Kinematics(IK) Forward Kinematics(FK)正向运动学：是在给定所有关节角度的情况下计算链接结构（如一节人体的关节）的末端的空间位置的过程。这个过程比较简单，且是具有唯一解的 Inverse Kinematics反向运动学： 它是在给定末端的空间位置的前提下，求解关节需要成多少角度。 这个过程就较为困难，一般情况下，逆运动学问题没有解析解，而是会有很多或无限多个解（比如确定一个手的位置，然后反向去算其他joint的位置） End-effector：添加到一个骨骼上，使得这个骨骼可以一直在一个期望的位置（比如贴地的效果） Two Bones IK：两个骨骼的IK，大腿和小腿作为two bones，问题是会有多个解；解决方式是添加一个reference vector，在这个方向去找解 多joint的IK很复杂，自由度太高，高维非线性方程很难实时运算、可能有很多解、单一解、无解 首先判断能否到达终点 Constraints of Joints：人形骨骼的运动范围是有一个约束的 Heuristics Algorithm启发式算法 CCD(Cyclic Coordinate Decent)：依次固定除了end-effector的每个joint，然后使end-effector变换到最接近target的位置 Optimized CCD1：对每个joint添加tolerance regions Optimized CCD2：越靠近叶节点旋转复度越大，越靠近根节点，旋转复度越小 FABRIK (Forward And Backward Reaching Inverse Kinematics) 先强行把end-effector拉到目标点，然后更改骨骼的方向，然后依次修改对应的joint和骨骼直到根节点，这是一次forward backward就是再把根节点拉回原来的位置，再做类似上面的操作 迭代多次 都要设置一个tolerance FABRIK with Constraints：为每个joint设置一个可以旋转的角度范围，然后强行拉点的时候呢，不一定拉到target，而是拉到这个角度范围在target平面上投影的一点 Multiple End-Effectors IK with Multiple End-Effectors：使用上面那个方法会使得骨骼偏来偏去 Jacobian Matrix：是个逐渐逼近的过程（会在物理那一part详细讲） Other IK SolutionsAnimation PipelineFacial Animation Key Pose Blending Morph Target Animation：记录下每个部分相对于中性表情的位置，这样就可以自由地组合 facial skeleton UV Texture Facial Animation Muscle Model Animation Retargeting 采集一套动画可以应用到很多模型上 忽略骨骼之间的offset apply的是相对于原始的binding的joint的位移 Align Movement by Pelvis Height Retargeting with different skeleton hierarchy：在两个相同骨骼之间的所有骨骼进行一个映射 Unresolved problems 模型自穿插问题 自我接触约束问题（如鼓掌需要双手接触） target character的平衡 Morph Animation Retargeting " }, { "title": "GAMES104-Lecture 08 游戏引擎的动画技术基础", "url": "/posts/GAMES104-Lecture-08-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E7%9A%84%E5%8A%A8%E7%94%BB%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/", "categories": "Computer Graphics, GAMES104", "tags": "图形学, 学习笔记", "date": "2024-01-11 08:48:00 +0000", "snippet": "Challenges可交互性和动态变化的动画： 在游戏中不能预设玩家的行为 游戏中的动画要和很多gameplay互动 受制于周围的环境 实时： 每一帧都要计算 动画数据很大 真实度： 更生动 表情 Basics of Animation Technology2D Animation Spri...", "content": "Challenges可交互性和动态变化的动画： 在游戏中不能预设玩家的行为 游戏中的动画要和很多gameplay互动 受制于周围的环境 实时： 每一帧都要计算 动画数据很大 真实度： 更生动 表情 Basics of Animation Technology2D Animation Sprite animation Sprite-like animation technique in pseudo-3D game：在各个视角采了一系列的位置，根据相机的位置播放不同的sprit动画 粒子系统：是一个序列帧 Live2D： 把角色的所有元素分解成一个一个的小图元，通过旋转、放缩、变形 给所有的图元设置深度 给每一个图元生成一个控制网格 设置key frame 3D Animation DoF(Degrees of Freedom) 6DoFs：平移的三个自由度（xyz），旋转的三个自由度（xyz） Rigid Hierarchical Animation：层次结构刚体动画 问题是骨骼转的时候mesh彼此会穿插 Per-vertex Animation：顶点动画 把每个顶点的offset按时间序列存在一个texture里面 横轴是每个顶点的offset（有时也会把法线存下来） 纵轴是时间 Morph Target Animation（也是一种顶点动画） 在顶点之间的Key Frame去插值 3D Skinned Animation 蒙皮动画，每个顶点受到多根骨骼的影响，来保证在运动的时候是水密性的，不会互相穿插 2D Skinned Animation Physics-based Animation 布娃娃系统Ragdoll 衣料模拟 Inverse Kinematics(IK)反向动力学 给定一个指定点，角色该怎么运动才最自然 Animation Content Creation 在编辑器里手key动画 动作捕捉 Skinned Animation Implementation How to Animate a Mesh Mesh：先做一个网格 Skeleton：为网格适配一套骨骼 Skinning/Rig：刷上一层蒙皮，给每一个顶点设置骨骼的权重（也就是顶点收到哪个骨骼影响大，影响小） Pose：让骨骼按照指定的动作动画 Animation Different Spaces World Space Model Space：以模型为中心的space Local Space：局部坐标系，每一根骨骼会平移旋转，每个骨骼的坐标系是不同的，坐标系会传递 把Local坐标系从根节点，一路积分上来，才能算出model space，然后考虑模型的位置和旋转，才能再转换成世界坐标系，然后才能被渲染 Skeleton for Creature 人的骨骼，root一般在胯部，Pelvis，脊椎末端 Joint vs. Bone Joint关节：会直接存储关节的数据，因为关节会带动bone动，不会直接存储bone的数据 joint是有很多自由度的 joint是一个刚体，不会被twist（扭曲），但Bone会 Humaniod Skeleton in Real Game 人脸上可能要加很多骨骼来做细节、翅膀、斗篷的骨骼 所以要提前设定好标准骨骼数是多少 Joints for Game Play 武器要mount（镶嵌）到手上的武器joint上 Root Joint 脚的中心，用来判断离地高度 Pelvis joint是root joint的第一个child joint Horse Skeleton 四足动物的尾椎骨是Pelvis joint root在肚子下面 Bind Animation for Objects 一些object是有父子关系的，有些动画是绑定的 在人的身上有一个Mount的joint，马鞍位置也有一个Mount的joint，这两个joint重合在一起，不仅是位置重合，旋转也是重合的；人和车也有 Bind Pose - T-pose vs. A-pose T-pose角色的肩膀部分其实是挤压的，所以目前一般就会给A-pose，这样肩胛处精度会高一点 Skeleton Pose 骨骼一个动作静止的状态叫做pose 把pose连在一起就是一个动画 在真正表达一个动画的pose的时候是有9个自由度的9DoFs，也就是放缩 Math of 3D Rotation 2D Orientation Math 3D Orientation Math Euler Angle：Yaw航向角、Pitch攻角、Roll横滚角 转的顺序不同，效果也不同 Gimbal Lock万向结 陀螺仪：可以用来测导弹的轨迹 稳定器 Degeneration of Euler Angle 当一个轴转了90度时死锁 Problems of Euler Angle 难以插值 欧拉角的叠加很难 容易沿着xyz轴转，但难以沿着其他轴转 Quaternion 四元数 Complex Number（复数）and 2D Rotation Quaternion，模、共轭（虚部全部取负数）、逆（normalized的四元数的共轭就是它的逆） 在做旋转的时候，需要先乘以q转换为四元数，旋转完后再乘以q^-1 Rotation Math by Quaternion Given Axis Rotation by QuaternionJoint Pose Orientation（朝向，其实rotation就是改变Orientation） 大部分骨骼动画是旋转 Position：Pelvis、facial joints和一些特殊的joints才会发生位置的变化 Scale：面部变化可能会使用scale Affine Matrix：joint表达的核心仿射矩阵，与透视矩阵不同的是不需要除以w，因为这是在一个永远正交的空间中进行变换（应该是最后光栅化的时候才会做投影） 关节在变换的时候，其所有父关节local space变换矩阵的乘积等于当前关节model space的变换矩阵 为什么要把所有的坐标信息存到局部坐标系呢？ 如果在model space进行插值，进行的是平移变换，那么骨头的长度会发生变换 而在local space进行插值，进行的是旋转，所以此时骨头长度是正常的没有发生长度的变化 Single Jpint Skinning 每一个顶点都可以用一个权重参数被绑定在一个或多个joint上面（但最好不要超过4个，一般会用一个byte来存这个限制数量） 当关节在动的时候，绑定在这个joint的顶点也要跟着移动才对 Skinning Matrix：动画矩阵，当一个顶点绑定了某个joint后，顶点的原位置乘上这些joint的Skinning Matrix就可以获得变换后的位置 Skinning Matrix Pallette：动画矩阵的表，有三部分，首先是模型坐标系到世界坐标系的变换矩阵，依赖的joint在模型坐标系下的最终pose，绑定的joint模型坐标系下变换矩阵的逆 Weighted Skinning with Multi-joints 如果绑定了多个关节，那么权重和要为1 Weighted Skinning Blend：分别算出顶点关于每个joint变换后的位置（根据上面的方法），然后根据权重插值（必须要在模型空间，不能在local space，因为每个joint的local space是不同的） Interpolation between Poses 对于位移和scale，使用线性插值就可以 但是对于旋转不行，需要在q1和q2的插值基础上做一个Normalization，这样就能得到正确的插值，这个方法叫做NLERP；问题是这个旋转的速度是不均匀的，所以有了SLERP Shortest Path Fixing of NLERP：最短路径的插值，因为一个位置转到另外一个位置，有两种转法，一个是直接最短路径转到，另一个是转一圈后才转到 SLERP：Uniform Rotation Interpolation 找到两个q（四元数）之间的夹角，根据当前位置的θ角进行一个插值，但缺点就是反三角函数的运算比较费（因为要查表去算） 用sinθ做分母是不稳定的 所以最终的措施是结合NLERP和SLERP 夹角小用NLERP，夹角大用SLERP Simple Animation Runtime Pipeline 首先有大量动画的clips 根据上一帧和下一帧来插值出当前的pose 转换到model space里 计算出每个骨骼的Skinning Matrix Palatte 然后进入gpu，计算顶点位置 Animation Compression 动画数据存储数据量很大 每个人的模型有70个关节，每个关节要在每秒钟存30个pose，每个pose包含平移旋转和放缩 但是很多数据其实是不变的，比如scale，很多情况下都是1，很多位移的local position也是不变的，变的最多的是rotation，rotation中也有经常变和不经常变的 Simplest Compression - DoF Reduction 丢弃掉不变的track，比如scale track，在人形骨骼中，除了面部基本都不会变 丢弃掉translate track，在人形骨骼中，除了pelvis、facial joint和特殊的joints外也基本不变 Keyframe keyframe extraction-Linear Keys Reduction：剔除原来pose里的非关键帧，根据插值出来的pose和实际pose来算error，只要error在阈值之下就选取作为关键帧，优点是线性插值计算简单，缺点就是为了减小error往往要打很多的关键帧 Ctamull-Rom Spline：一个三阶多项式曲线，这个曲线很平滑 Float Quantization：浮点数32bit，存储量很大，所以可以把float的值先映射到(0,1)，然后再映射到(0,65535)，也就是一个16bit的无符号整型 Quaternion Quantization：如何对一个四元数进行定点压缩呢？ 当对四元数归一化压缩后，虽然每一个数都有可能在[-1,1]，但如果把最大值丢掉，那么另外三个数一定在 $ [-\\frac{1}{\\sqrt {2}},\\frac{1}{\\sqrt {2}}] $ ，那么就需要只用2个bit记录下哪一位是最大值，然后记录剩下的三个值，最后根据归一化反向算法（其实就是根据记录的三个值算剩下一个值），算出所有值，也就是说，每一个虚部只需要使用15bit，所以最后存一个四元数就用3个无符号整型就可以，也就是48bit；反之，如果用4个float存，那就是128bit Error Propagation：error会传递下去，前几个error还行，当传到最后几个骨骼的时候，error就会很大了，所以压缩算法可能出现这样的问题； Joint Sensitivity to Error：不同的joints对error的敏感度不同，比如在手的地方，压缩算法做不好就会动画抖动 Measuring Accuracy data error visual error：难以去计算每个顶点的visual error，在每一个joint设置两个垂直于它的点，通过设置offset的大小来控制error，因为不同骨骼对于error敏感度不同，设置的offset就可以不同 Error Compensation-In Place Correction 因为计算是传递的，所以下一个joint对上一个joint产生的error进行补偿 产生的问题就是，在末端骨骼的动画数据一般是平滑的低频数据，但是为了给上面的joint补偿而变得高频，比如产生抖动 Animation DCC Process Mesh：先构建mesh，美术构建的是高精度mesh，但是做动画会使用low poly；在动画关节的地方会额外加几圈mesh Skeleton binding：在现代的软件中，搭好T-pose或者A-pose后，使用工具中的骨架然后一个个对上；加上武器、pelvis、root的骨骼 Skinning：现代软件都是自动计算，根据深度学习之类前沿的算法计算出来，动画师也可以自己调整，每一根骨骼对顶点的权重是多少 Animation creation：设置关键帧和关键帧之间的时间间隔 Exporting：root不会跟动画一起存下，而是会单独导出来一个位移曲线来给引擎用 " }, { "title": "GAMES104-Lecture 07 游戏中渲染管线，后处理和其他的一切", "url": "/posts/GAMES104-Lecture-07-%E6%B8%B8%E6%88%8F%E4%B8%AD%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF-%E5%90%8E%E5%A4%84%E7%90%86%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E4%B8%80%E5%88%87/", "categories": "Computer Graphics, GAMES104", "tags": "图形学, 学习笔记", "date": "2024-01-09 08:48:00 +0000", "snippet": "Ambient Occlusion 在每一个可看见的点处，它的可看见的正半球面，只有部分可以看到天光，另一部分被周围的几何遮挡住了Precomputed AO 提前烘培出的一张AO纹理Screen Space Ambient Occlusion(SSAO) 首先从screen打出一条ray，hit到一个点p，从那个点处生成一个球，在这个球的范围内采样多个点 从ca...", "content": "Ambient Occlusion 在每一个可看见的点处，它的可看见的正半球面，只有部分可以看到天光，另一部分被周围的几何遮挡住了Precomputed AO 提前烘培出的一张AO纹理Screen Space Ambient Occlusion(SSAO) 首先从screen打出一条ray，hit到一个点p，从那个点处生成一个球，在这个球的范围内采样多个点 从camera分别向上一步中的采样点发出射线，看是交到screen的哪个像素，取出该像素的depth buffer并与采样点的深度对比，采样点更深说明p被遮挡 根据采样点更深和更浅的数量的比例来估计AO 问题是这个球不太对，应该是半球，沿着法线方向的半球(SSAO+) HBAO - Horizon-based Ambient Occlusion 从某个点发射ray，去找能看到天顶的最大仰角，找一圈就能获得一个看不到天顶的区域GTAO - Ground Truth-based Ambient Occlusion 使用一个多项式拟合方程来计算出一个值，作为AORay-Tracing Ambient Occlusion 射线FogDepth Fog 从眼睛处看出去，随着距离的增加，降低透明度 Linear、Exp、Exp Squared Height Fog 有一个高度，高度以下都是最大的fog值，高度以上的fog以指数的速度递减Voxel-based Volumetric Fog 把相机空间进行Voxelize（非均匀），离眼睛近的地方切得更密 进行Ray-marching Anti-aliasingReasons 本质是因为屏幕分辨率是有限的 几何的边只要不是横平竖直就会产生aliasing Texture采样（使用mipmap） 高光采样 Super-sample Anti-aliasing(SSAA) and Multi-sample AA(MSAA) SSAA：4倍渲染分辨率、4倍z-buffer、4倍frame-buffer、4倍光栅化，最后再滤波 MSAA：4倍z-buffer、4倍frame-buffer、4倍光栅化，最后只对需要的像素计算权重来shading（边缘） FXAA(Fast Approximate Anti-aliasing) 先把颜色转换到亮度空间，然后用一个十字形滤波找到边界：对于一个像素M，找到其上下左右四个像素NSWE，然后算出这五个像素的最大值和最小值，如果最大值和最小值的差大于设定的阈值，就是边界 然后对边界处横向和纵向算一下Offset Direction（哪个方向的颜色变化大），横向计算和纵向计算的卷积核有略微的差距，横向计算的卷积核中间一列是负的，纵向计算的卷积核中间一行是负的；对比后先确认是横向还是纵向，确认后再对比是向右还是向左（向上或者向下） 然后进行Edge Searching Algorithm： 把刚才找到的边缘像素对（比如M和N像素是一对）作为初始像素对，然后从垂直方向开始search（比如MN像素对，就是往左右开始找），找到和自己这个像素对差距比较大的两组像素对作为这个边的两端 然后比较左右两端的到M这个像素对的长度，根据长度进行运算，到底是听自己的还是听其他像素的（也就是要混合） TAA(Temporal Anti-aliasing) 这一帧，使用前一帧进行运算，时序上的抗走样Post-processBloom 光晕 人眼类似相机，不能完美聚焦在一个平面 人眼的材质更像是半透明材质，光进来会发撒 方法： 先取出高亮部分：计算Luminace，超过某个阈值就算高亮 先降采样，然后上一个Gaussian Blur，放大后再加回去（有权重） Tone Mapping 曝光 为了解决阳光直射的地方亮度太高，阴影地方亮度太低，比如天空过曝 使用Filmic s-curve将一个范围，如[0,40]的颜色映射到[0,1] ACES曲线，更加专业 Color Grading 调色 Lookup Table(LUT)：原始的一个颜色和我想调到的一个色相空间的映射Rendering PipelineForward Rendering 按顺序渲染：遍历每一个mesh，遍历每一束光，计算shading Transparent Sorting 有透明物质的话，先绘制不透明物质，多个透明物质需要由远及近地绘制 Deferred Rendering 延迟渲染 先把所有的物体渲染一遍，写到G-Buffer 然后对于每一个像素，计算每一个光的效果 优点：方便加点光源，容易Debug 缺点：G-Buffer很费 Tile - based Rendering 将画面分成块 光也会被切到每一块里 depth-range optimization：按深度分出一个区域，一个光源只照一个范围内的物体Forward+(Tile - based Forward) RenderingCluster-based RenderingVisibility Buffer 把几何信息和材质信息剥离，用Visibility Buffer把几何信息存下来 查询效率更高 Real Rendering Pipeline 资源管理，当pipeline很复杂的时候就很难进行资源管理 Vulkan等api开放硬件的api，因为有很多多线程，如果锁加不好就会出问题 Frame Graph 表达渲染本身的前后关系、依赖关系Render to MonitorScreen Tearing 画面撕裂，因为引擎渲染的每一帧时间是不一致的，但屏幕的帧率是一样 V-Sync Technology：等frame buffer写完以后，等到显示器刷新后一整个显示 Variable Refresh Rate 游戏渲染帧率和显示器刷新率同步" }, { "title": "GAMES104-Lecture 06 游戏中地形大气和云的渲染", "url": "/posts/GAMES104-Lecture-06-%E6%B8%B8%E6%88%8F%E4%B8%AD%E5%9C%B0%E5%BD%A2%E5%A4%A7%E6%B0%94%E5%92%8C%E4%BA%91%E7%9A%84%E6%B8%B2%E6%9F%93/", "categories": "Computer Graphics, GAMES104", "tags": "图形学, 学习笔记", "date": "2024-01-06 07:07:00 +0000", "snippet": "Environment Components Sky and Cloud Vegetation Terrain LODs Level of detailsTerrain RenderingSimple Idea - Heightfield height map + Contour map Adaptive Mesh Tessellatio...", "content": "Environment Components Sky and Cloud Vegetation Terrain LODs Level of detailsTerrain RenderingSimple Idea - Heightfield height map + Contour map Adaptive Mesh Tessellation 关心fov内的东西，fov内的三角形会被细化，fov外面和远处的三角形会分布得比较稀疏 瞄准镜就只是修改了fov，观察角度减小，相同的三角形，在更小的fov下占的像素会增加 2条优化黄金法则 近处密 远处稀疏，fov窄密 宽稀疏 与实际值的误差控制 Triangle-based subdivision 永远把等腰直角三角形最长的一边切一刀，得到两个新的等腰直角三角形，这是一个二叉树的结构 Subdivision and T-Junctions 这个问题就是指相邻两个三角形的共用边处，只对其中一个三角形细分而另一个没有，就会产生T-Junctions，解决方法就是没细分的三角形也被迫细分一下 QuadTree-Based subdivision 优点：容易构建、quad符合数据规范 缺点：也有T-Junctions（解决方法：Stitching，多的点吸附到其他点，形成退化三角形（面积为0）） Triangulated Irregular Network(TIN) 使用不规则的三角形， 优点：运行时快、三角形数量更少 缺点：需要预处理、很难重复利用 GPU-Based Tessellation Mesh Shader Pipeline Real Time Deformable Terrain Non-Heightfield Terrain Volumetric Representation体素化表达 Marching Cubes：扫描的点通过该算法构造出形状（三角面片集） Paint Terrain Materials Terrain Materials，材质混合，简单blend会不真实 Advanced Teture Splatting - Biased Sampling from Material Texture Array 存权重和材质索引 Parallax and displacement Mapping Expensive Material Blending 每个像素都要算一遍 Virtual Texture：减小显存中的texture，还可以pre-bake，从显存、内存、硬盘之间调度数据 VT Implementation， DirectStorage &amp; DMA：不经过内存，直接往显存里写数据 Floating-point Precision Error 浮点数溢出 解决方案：Camera-Relative Rendering 先把每个物体的位置减去相机的位置，然后对物体进行transform，最后把相机位置设置为0，更新mvp矩阵 Tree Rendering：每种树都有LODs Decorator Rendering：装饰性渲染，比如草 Road and decals Rendering decals类似子弹的弹坑，小贴图，把decals放在virtual texture里 AtmosphereAnalytic Atmosphere Appearance Modeling 公式有两个参数：向上看的方向与天顶的夹角θ，向上看的方向与太阳的夹角γ 优点：计算简单高效 缺点：局限于地面视角，不能模拟从空中看、参数不能自由修改 Participating Media 气体分子、气溶胶 光线与Participating Media的交互 Absorption 吸收 Out-scattering 散射 Emission 发光 In-scattering 附近的Participating Media的Out-scattering对打到自己 Radiative Transfer Equation(RTE) Volume Rendering Equation(VRE) Real Physics in Atmosphere Sun Light(不同波长) Air Molecules气体分子：N2、O2 Aerosols气溶胶分子：Dust、Sand Scattering Types Rayleigh Scattering 对于越短的波长（蓝光、紫光）散射得越厉害，长波长（红光）散射很少 λ是波长，θ是光线和介质的夹角，h是海拔高度（用来表示空气密度） Mie Scattering 有方向性，沿着光的方向会略强，不考虑波长的影响 比上面的方程多一个g，等于0就和上面的方程一样，大于0会有不同的效果 mie散射一般表现雾和光晕 Single Scattering &amp; Multi ScatteringVariant Air Molecules Absorption Ozone(O3)：吸收长波长的光 Methane(CH4)：吸收红光 Ray Marching 沿着视线，把沿途的效果一步一步地积分起来 计算复杂，那么就空间换时间，预先计算，存在表中 Precomputed Atmospheric Scattering： 大气模拟主要看两个参数：transmittance通透度、scattering散射 存 在地球上的任意一个点，视线与天顶的夹角 存 现在所在的海拔高度 然后transmittance LUT存的就是从这么一个点看向这个θ方向，直到大气层的边界处，这些大气的通透度 scattering散射要用三个角度算 Challenges： multi-scattering很贵 手机端不好生成transmittance LUT 不好生成动态的切换效果 Production Friendly Quick Sky and Atmosphere Rendering： 能表达动态的效果CloudCloud TypeMesh Based Cloud Modeling 高质量 整体计算昂贵、不支持动态天气 Billboard Cloud 直接上贴图，高效 效果不太好 Volumetric Cloud Modeling 优点：全动态、形状多变、可以飘 缺点：效率低，运算昂贵 Weather Texture：随机的云的分布+云的厚度 Noise Functions Perlin Noise：用一个多项式的时间 Worley Noise Cloud Desity Model Ray Marching: 从屏幕射出一条ray 在hit到cloud之前使用big step hit到cloud之后在云里面使用dense step(小一点的步长) 计算从太阳散射到云的radiance " }, { "title": "GAMES104-Lecture 05 渲染中光和材质的数学魔法", "url": "/posts/GAMES104-Lecture-05-%E6%B8%B2%E6%9F%93%E4%B8%AD%E5%85%89%E5%92%8C%E6%9D%90%E8%B4%A8%E7%9A%84%E6%95%B0%E5%AD%A6%E9%AD%94%E6%B3%95/", "categories": "Computer Graphics, GAMES104", "tags": "图形学, 学习笔记", "date": "2024-01-05 07:07:00 +0000", "snippet": "The Rendering EquationChallenges Visibility to Lights 阴影问题，如何获得任何方向的radiance Light Source Complexity 光源的复杂程度 Integral Efficiently 积分效率 Any matter will be light source 光源可以...", "content": "The Rendering EquationChallenges Visibility to Lights 阴影问题，如何获得任何方向的radiance Light Source Complexity 光源的复杂程度 Integral Efficiently 积分效率 Any matter will be light source 光源可以反弹 Simple Light Solution 环境光+主光+环境光贴图 漫反射+高光+环境 = Blinn-Phone 问题是能量不守恒（或者说保守） Shadow Map：光源看不到的地方就是阴影，将摄像机放在光源的位置，记录下一张深度图，也就是记录 从图片中每个像素打出的光线 到对应物体的 最小深度是多少，之后在摄像机原本的位置观察，对比 此时每个像素打出的视线 到对应物体的位置相对于光源视角的深度和深度图对应像素的深度，如果比深度图位置深度大，说明光源看不到，就是阴影 Pre-computer Global Illumination 预计算Spherical Harmonics函数 压缩光场SH Lightmap：Precomputer GI Lightmap： 优点：运行时效率快，产生很细节很微妙的效果 缺点：烘焙时间很长（lightmap farm），只能处理静态光，贴图太大占内存 Light Probes+Reflection Probes 在场景中撒很多点，对每个probe采样广场 优点：处理静态和动态光源，运行时效率高，处理漫反射和镜面发射 缺点：做不到lightmap那种细节 Physical-Based MaterialMicrofacet Theory 一个表面就是有无数个反射，能弹多少，体现在法线的分布，金属没有能力捕获光子，非金属有能力捕获光子，一部分光子会进入物体反弹几次 BRDF：ggx 漫反射+CookTorrance（DFG） D：法线分布方程D_ggx符合光的表达，光线过渡更加柔和；Roughness表示法线的分布 F：fresnel Equation菲涅尔效果 G：自遮挡 PBR Specular Glossiness Diffuse + Specular + GlossinessPBR Metallic Roughness Base Color + Roughness + Metallic 比SG模型更容易控制 缺点就是非金属和金属之间的过渡会产生白边 Image-Based Lighting(IBL) Diffuse Irradiance Map：预先计算好diffuse卷积的结果储存在图中 Specular Approximation：specular使用split sum进行估计，就是把三个方程相乘的积分估计成三个方程分别自己积分最后相乘 不同粗糙度积分不同，将不同粗糙度的结果存在不同的mip map中，根据roughness去查询 Classic Shadow SolutionCascade Shadow：层级阴影 不同层级之间要做插值 优点就是快、效果好、走样少 缺点：不能生成高分辨率的区域shadow，没有彩色阴影，半透明表面投射出不透明的阴影 PCF Percentage Closer Filter 用滤波的方法做软阴影PCSS Percentage Closer Soft ShadowVariance Soft Shadow MapSummary of Popular AAA Rendering Lightmap + Lightprobe PBR + IBL Cascade shadow + VSSM Modern WaveReal Time Ray-Tracing on GPUReal Time Global Illumination Screen-space GI SDF Based GI Voxel-Based GI RSM/RTX GI More Complex Material Model BSDF BSSRDF Virtual Shadow MapsShader Management Uber Shader and Variants：自动编译所有shader组合Close Platform Shader Complie" }, { "title": "力扣-双指针系列", "url": "/posts/%E5%8A%9B%E6%89%A3-%E5%8F%8C%E6%8C%87%E9%92%88%E7%B3%BB%E5%88%97/", "categories": "算法刷题", "tags": "双指针", "date": "2023-12-01 13:14:00 +0000", "snippet": "125. 验证回文串 - 力扣（LeetCode）class Solution {public: bool isPalindrome(string s) { int left = 0,right = s.size() - 1; while(left &lt;= right) { while(left &lt; s.size...", "content": "125. 验证回文串 - 力扣（LeetCode）class Solution {public: bool isPalindrome(string s) { int left = 0,right = s.size() - 1; while(left &lt;= right) { while(left &lt; s.size() &amp;&amp; !isalnum(s[left])) left++; while(right &gt;= 0 &amp;&amp; !isalnum(s[right]))right--; if(left&lt;= right &amp;&amp; tolower(s[left]) != tolower(s[right])) return false; left++; right--; } return true; }};    经典的双指针，需要注意的是两个指针的边界，一个小于s.size()，一个要大于0，而且在循环内注意保持left&lt;=right" }, { "title": "力扣-前缀和系列", "url": "/posts/%E5%8A%9B%E6%89%A3-%E5%89%8D%E7%BC%80%E5%92%8C%E7%B3%BB%E5%88%97/", "categories": "算法刷题", "tags": "前缀和", "date": "2023-12-01 09:14:00 +0000", "snippet": "523. 连续的子数组和 - 力扣（LeetCode）class Solution {public: bool checkSubarraySum(vector&lt;int&gt;&amp; nums, int k) { if(nums.size() &lt; 2) return false; unordered_map&lt;int, int&gt; mp...", "content": "523. 连续的子数组和 - 力扣（LeetCode）class Solution {public: bool checkSubarraySum(vector&lt;int&gt;&amp; nums, int k) { if(nums.size() &lt; 2) return false; unordered_map&lt;int, int&gt; mp; mp[0] = -1; if(nums[0] % k != 0)mp[nums[0] % k] = 0; for(int i = 1; i &lt; nums.size(); i++){ nums[i] += nums[i - 1]; int m = nums[i] % k; if(!mp.count(m)) mp[m] = i; else if(mp.count(m) &amp;&amp; i - mp[m] &gt;= 2) return true; } return false; }};    前缀和的题目，不仅需要前缀和，还需要设置一个哈希表，这种需要算相同k的倍数的子数组，要考虑两个前缀和是否同余，如果同余那么之间的子数组就可以是k的倍数了。525. 连续数组 - 力扣（LeetCode）class Solution {public: int findMaxLength(vector&lt;int&gt;&amp; nums) { if(nums.size() &lt; 2) return 0; vector&lt;int&gt; presum(nums.size() + 10, 0); unordered_map&lt;float, int&gt; m; for(int i = 1; i &lt;= nums.size(); i++){ presum[i] = presum[i-1] + nums[i - 1]; } int ret = 0; for(int i = 0; i &lt;= nums.size(); i++){ float k = (float)presum[i] - (float)i/(float)2; if(!m.count(k))m[k] = i; else ret = max(ret, i - m[k]); } return ret; }};    这也是一道前缀和加哈希表的题目，很巧妙的一个方法 因为元素仅有0和1，所以子数组的元素和即为1的数量，子数组长度-元素和=0的数量 所以可以符合题意的子数组满足公式 preSum[ j ]-preSum[ i ]=( j - i )/2; 移项得：preSum[ i ]-i/2=preSum[ j ]-j/2，即 newNums[ i ]=newNums[ j ]; 此时容易想到哈希表计数，问题解决。具体实现可以优化成一次遍历。" }, { "title": "力扣-BFS系列", "url": "/posts/%E5%8A%9B%E6%89%A3-BFS%E7%B3%BB%E5%88%97/", "categories": "算法刷题", "tags": "bfs", "date": "2023-12-01 09:14:00 +0000", "snippet": "433. 最小基因变化 - 力扣（LeetCode）class Solution {public: int minMutation(string startGene, string endGene, vector&lt;string&gt;&amp; bank) { if(startGene == endGene)return 0; char key[4] ...", "content": "433. 最小基因变化 - 力扣（LeetCode）class Solution {public: int minMutation(string startGene, string endGene, vector&lt;string&gt;&amp; bank) { if(startGene == endGene)return 0; char key[4] = {'A','C','G','T'}; unordered_set&lt;string&gt; bankset; unordered_set&lt;string&gt; visited; queue&lt;string&gt; qu; for(auto&amp; s : bank){ bankset.emplace(s); } qu.push(startGene); visited.emplace(startGene); int step = 1; while(!qu.empty()){ int sz = qu.size(); for(int i = 0; i &lt; sz; i++){ string curstr = qu.front(); qu.pop(); for(int i = 0; i &lt; 8; i++){ for(int j = 0; j &lt; 4; j++){ if(curstr[i] != key[j]){ string tmp = curstr; tmp[i] = key[j]; if(!visited.count(tmp) &amp;&amp; bankset.count(tmp)){ if(tmp == endGene)return step; qu.push(tmp); visited.emplace(tmp); } } } } } step++; } return -1; }};    每一次都要把当前队列排空算是一次步骤" }, { "title": "GAMES104-Lecture 04 游戏引擎中的渲染实践", "url": "/posts/GAMES104-Lecture-04-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E6%B8%B2%E6%9F%93%E5%AE%9E%E8%B7%B5/", "categories": "Computer Graphics, GAMES104", "tags": "图形学, 学习笔记", "date": "2023-10-03 06:53:00 +0000", "snippet": "Rendering Sysytem in GamesTheory 算法，辐射度算法，30fps算realtime，10fps算可交互chanllenges 想要是实现的效果都相当复杂，各种算法不一样，还要加后处理、光照运算 在游戏环境中要跑在现在的计算硬件中，所以不是光理论可行就行了 帧率是稳定的，高分辨率 只能使用10%的应用资源 R...", "content": "Rendering Sysytem in GamesTheory 算法，辐射度算法，30fps算realtime，10fps算可交互chanllenges 想要是实现的效果都相当复杂，各种算法不一样，还要加后处理、光照运算 在游戏环境中要跑在现在的计算硬件中，所以不是光理论可行就行了 帧率是稳定的，高分辨率 只能使用10%的应用资源 Rendering on Game Engine 工程技术更新迭代迅速，会随着硬件、环境的变化而迭代 实践的软件工程 Outline of Rendering 基础gpu硬件、组织架构、可视裁剪 现代游戏中的光照模型、材质系统、shader模型 子系统：地形、天空、后处理 流水线、延迟渲染、绘制内容的管理、前言的tiled-base rendering Building Blocks of Rendering 流水线 介绍cg的部分……感觉可以可以转到games101 投影、光栅化、着色 纹理采样 Understand the Hardware 使用独立的显卡来进行这些复杂的计算，极大地释放cpuSIMD and SIMT simd(single instruction Multiple Date)：单指令、多数据的数据运算，就是四维向量，也就是说一个指令同时完成四个加减法 simt(single instruction Multiple Threads)：如歌计算内核很小，但有很多个，一个指令让很多核去计算，极可能使用同样的代码，每个核访问自己的数据，所以跑的非常快 GPU Architecture 费米架构 GPC(Graphics Processing Cluster)：图形处理集群，专用硬件区用于计算、光栅化、着色、纹理 SM(Streaming Multiprocessor)：装了很多的core Texture Units CUDA Core Warp Data Flow from CPU to GPU 尽可能数据单向传输，尽可能不从GPU读数据 Cache：内存固然快，但依然比缓存慢百倍 GPU Bounds ALU Bounds：数学运算太多了，导致其他步骤都在等数学运算 Memory Bounds TMU(Texture Mapping Unit) Bound BW(BandWidth) Bound Architecture 硬件结构一直在变 手机的架构也不一样 Renderable 可绘制的，不是所有的go都要绘制 Mesh、Vertex、Index 每个顶点都要存一个法向 材质 材质模型：phong、pbr 纹理 shader：首先是源码，其次又是数据 Render Objects 将顶点数据、材质、纹理交给gpu，再让gpu按shader执行，就会渲染出东西来 Mesh会有subMesh，其中使用index来划分，有offset 相同的材质和纹理放在pool管理，绘制物体时就会去找（享元模式） 定义和实例：实例去引用定义 把整个场景的物体根据材质去排序，把相同材质的物体分组，设置一次材质就形成一组submesh，计算量相同，但速度会变快 GPU Batch Rendering Visibility Culling 可见性裁剪 包围盒 PVS(Potential Visibility Set)：先用BSP将房间分成小格子，每个格子通过Portal链接，在其中一个格子时，只看到部分的格子，从而减少绘制；这个思想还是很有用的 GPU Culling：显卡来做裁剪，生成遮挡物的深度图，然后选择是否丢掉Texture Compression 纹理压缩 在游戏引擎里不能用诸如jpg这样很好的图片压缩算法，因为这些算法不能快速随机访问 所以都是基于Block Compression思想，分块压缩 Authoring Tools of Modeling 几何建模 雕刻 扫描 程序化生成 Cluster-Based Mesh Pipeline 可以用一个算法，基于数据凭空生成几何，并且根据距离来选择精度 可以产生无限的细节 " }, { "title": "GAMES104-Lecture 03 如何构建游戏世界", "url": "/posts/GAMES104-Lecture-03-%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E6%B8%B8%E6%88%8F%E4%B8%96%E7%95%8C/", "categories": "Computer Graphics, GAMES104", "tags": "图形学, 学习笔记", "date": "2023-10-03 06:53:00 +0000", "snippet": "What does a game world consist of? 动态物 静态物 环境：天空、植被、地形 其他物：空气墙、trigger area、navigation mesh How should we describe these things? 属性 行为 继承 组件化：解决...", "content": "What does a game world consist of? 动态物 静态物 环境：天空、植被、地形 其他物：空气墙、trigger area、navigation mesh How should we describe these things? 属性 行为 继承 组件化：解决该继承谁的问题 让开发者好理解好维护 让艺术家好理解好使用 把游戏世界的所有东西抽象成了game object（go） 每个go由各种组件（component）组成 How are these things organized? 每个tick()把每个go的tick()执行一遍 现代引擎中是按系统（或者说是每种component）去tick()，有一个pipeline go之间的关系，最原始是hardCode，现代是Events事件机制（观察者模式） Events：发送事件给有关系的go，让go自己处理 管理： 不管理：每次发生爆炸，向所有go发送消息，判断爆炸半径 分治：把世界划分成格子，均匀格子、八叉树格子（层级查找） 空间数据管理： 二叉树、八叉树、BVH 很多tick是并行执行的，所以时序很重要，如果让go彼此互相通信，就会产生逻辑混乱，因此引入邮局 pretick和posttick就是解决时序问题" }, { "title": "GAMES104-Lecture 02 引擎架构分层与整体Pipeline", "url": "/posts/GAMES104-Lecture-02-%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84%E5%88%86%E5%B1%82%E4%B8%8E%E6%95%B4%E4%BD%93Pipelinemd/", "categories": "Computer Graphics, GAMES104", "tags": "图形学, 学习笔记", "date": "2023-09-28 08:33:00 +0000", "snippet": "A Glance of Game Engine Layers 工具层：现代游戏引擎的界面，各种编辑器 功能层：让这个世界看得见动起来 资源层：各种数据，动画、模型、音乐，负责加载管理这些资源，为功能层提供弹药 核心层：功能层各个部分都会调用相同的很基础底层的代码，就像是工具箱、瑞士军刀 平台层：最终发步到用户的设备上，平台不一...", "content": "A Glance of Game Engine Layers 工具层：现代游戏引擎的界面，各种编辑器 功能层：让这个世界看得见动起来 资源层：各种数据，动画、模型、音乐，负责加载管理这些资源，为功能层提供弹药 核心层：功能层各个部分都会调用相同的很基础底层的代码，就像是工具箱、瑞士军刀 平台层：最终发步到用户的设备上，平台不一样、输入不一样（键盘、手柄、体感） 中间件和第三方库：会集成到上面的各个层中，有sdk可以直接编译进去；还有是工具，在引擎之外 Resource 把资源的数据转换成引擎的高效数据：resource-&gt;assets；去掉无用信息 数据之间的关联reference是最重要的 guid：资产的全局唯一识别号，相当于身份证 需要一个实时的资产管理器，handle系统 资产会根据进度进行加载和卸载，guid和handle就是解决这个问题 延迟加载策略，比如材质从粗糙到细致的加载 Function tick就是我们构建的世界的普朗克时间 Tick函数 tickLogic：先把整个世界的物理规则算一遍，模拟出这个世界 tickRender：某个人看到的一副2d画面；会做裁剪、光照、阴影 多线程：前沿：job系统（多核并行，难点在于处理不同系统的前后关系） Core 数学库：数学效率 carmack’s 1/sqrt(x) sse：cpu并行运算向量 数据结构：在核心层做一套自己的数据结构，没有内存碎片 内存管理：开辟一大块内存自己管理，为追求最高的效率；cpu的缓存越大，取出数据效率越高； 内存管理三大步骤：把数据放在一起，尽可能地顺序访问数据，读写的时候尽可能一起去读写 Platform 掩盖掉平台差异度 Render Hardware Interface：重新定义一个api，把各个硬件sdk封装起来 不同设备架构不同，如Ps还有scpuTool 真正的生产力，开发方式比较灵活，以开发效率优先 工具层是允许别人使用，工具层的代码量很大 DCC(Digital Content Creation)：别人开发的资产生产工具（比如3dmax、maya、houdini） 从dcc到game engine的流程叫做asset condition pipeline，有导入器、导出器 Layered Architecture 封装，高层不知道底层的实现 底层与高层独立 底层的代码不要轻易改动，顶层可以；只允许上调用下Mini Engine-Pilot ecs framework（支持多线程）Takeaways 引擎是分层架构的： 平台层、核心层、资源层、功能层、工具层 越底层的代码越稳定质量越高，越高层的代码设计得越开放越灵活，能适应不同的游戏 游戏引擎的核心是tick函数 " }, { "title": "GAMES104-Lecture 01 游戏引擎导论", "url": "/posts/GAMES104-Lecture-01-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E5%AF%BC%E8%AE%BA/", "categories": "Computer Graphics, GAMES104", "tags": "图形学, 学习笔记", "date": "2023-09-26 08:33:00 +0000", "snippet": "Why We Need to Learn metahuman cinematic &amp; animation simulation digital twin History of Game Engine Early Age of Video Games：红白机 Father of Game Engine: Jo...", "content": "Why We Need to Learn metahuman cinematic &amp; animation simulation digital twin History of Game Engine Early Age of Video Games：红白机 Father of Game Engine: John Carmack Wolfenstein 3D doom Early Age of Modern Game Engine Quake(网络对战fps)，使用第一代显卡的第一代3d游戏 硬件的发展，算力提高了20万倍 Family of Game Engine Commercial Engine: Unreal、Unity、Cryengine In-house Engine: FrostBite3、Source、Infinity World、Rage、anvil next Free Engine: stride、Torque、Godot、3de Middlewares(中间件) physics&amp;Animation: havok、Physx Sound: Wwise、fmod Rendering: TrueSky、enlighten Other: speedtree、simplygon What is Game Engine 定义： 构建黑客帝国的底层框架 生产力工具 复杂性的艺术 Complexity of Simulation by 0/1 不只rendering realtime：在算力、内存、带宽、延迟等等的限制下还需要实时地演算 toolchain for Createors：提供一个强大的工具链，供艺术家和设计师使用 Developer Platform：二次开发能力、可协作能力 Upadate：更新的同时可以兼容过去的内容 How to Study 沿着主干道前进Course Content 游戏引擎的基础构建，如MVVM 游戏引擎分几层？ 看引擎代码先看update函数 rendering：把东西放在1/30s内显示出来，渲染管线，各种算法如何拼接和组合 animation：过渡怎么做、应变、一些列的动画如何组织起来，强调交互与玩法，让设计师能够理解 Physics：物理表达，刚体力学模拟运动，弹性力学，流体模拟 Gameplay：前面就是世界的模拟器，而gameplay就是好玩的规则，规则如何让计算机理解，而且需要设计师去使用，所有的游戏就是规则体系；编程不一定是写代码，制作逻辑就算编程 Misc. Systems：特效系统，寻路系统、相机系统 Tool set：构建工具体系，如反射体系，在更新的时候，过去与未来的设计能够兼容 Online Gaming：通过信息沟通，让每个平行宇宙发生的事情是一致的；异步同步算法、帧同步算法 Advanced Technology： Motion matching、PCG（自动生成） 面向数据的编程、多线程的任务系统，程序在多核运行 lumen光照技术、Nanite面片技术 References Game Engine Architecture" }, { "title": "GAMES101-Lecture 22 Animation(cont.)", "url": "/posts/GAMES101-Lecture-22-Animation(cont.)/", "categories": "Computer Graphics, GAMES101", "tags": "图形学, 学习笔记", "date": "2023-08-04 07:58:00 +0000", "snippet": "Single particle simulation 模拟一个粒子在速度场中如何运动 速度场：任何一个位置，都知道该粒子的速度 Ordinary Differential Equation (ODE) 常微分方程 常的意思就是只有一个变量（x，t不算），对x的微分，单变量的微分方程 Euler method 使用上一个时刻的量（速...", "content": "Single particle simulation 模拟一个粒子在速度场中如何运动 速度场：任何一个位置，都知道该粒子的速度 Ordinary Differential Equation (ODE) 常微分方程 常的意思就是只有一个变量（x，t不算），对x的微分，单变量的微分方程 Euler method 使用上一个时刻的量（速度，加速度）来计算当前时刻的量（位置、速度） 这个叫Explicit Euler或者Forward Euler 问题是不稳定 步长太长就会不准确，步长越小越精确 在一些特殊情况下，不管取多小的步长，都会偏移出去，比如螺旋形的速度场；头发型的速度场也会导致奇怪的结果，这种情况叫做正反馈，如果出现问题就会慢慢地无限放大 不稳定≠误差，因为无论多小的步长最后都会出问题 用数值的方法解微分方程会遇到的问题： 误差 不稳定 diverge(偏离) Combating Instability 中点法(Midpoint Method) 选取一个步长t计算出位置a 计算两点中点b 然后按中点b的速度和之前的步长t来计算位置，得到c 为什么中点法更准确一点，是因为计算中多了一个二次的项 自适应步长(Adaptive Step Size) 就是自适应减小步长，将一个步长一分为二，做两次欧拉，而是否要一分为二，取决于$X_T和X_{\\frac{T}{2}}$位置距离的远不远 最终的结果就是，在不同的位置会选用不同的步长来计算 隐式方法(Implicit Euler method也叫backward method) 当前一步使用下一个时间的derivatives(导数、梯度) 式子不好解 认为，当前位置和下一帧的加速度已知，两个式子解下一帧位置和下一帧速度 $ x^ {t+\\Delta t} $ = $ x^ {t} $ + $ \\Delta $ $ t\\dot x^ {t+\\Delta t} $ $\\dot x^ {t+\\Delta t} $ = $ \\dot x^ {t} $ + $ \\Delta $ $ t\\ddot x^ {t+\\Delta t} $ 如何定义/量化 局部的误差/累计误差 阶，也就是误差和步长$\\Delta t$之间的关系 隐式欧拉方法是一阶的：局部误差是$O(h^2)$，全局误差是$O(h)$，h就是步长 $O(h)$就是如果我把步长缩小到一半，那误差也缩小的一半 非基于物理的方法(Position - Based / Verlet Integration) 认为某一节弹簧，当被拉开后，会立刻回到原状，可以认为是一个劲度系数很大的弹簧，通过非物理的简化方式直接改变位置 Runge-Kutta Families 这是一类方法，很擅长解ODEs 这是4阶的方法，这个方法简称RK4 y就是一个位置，h是步长，每个k就是速度场中不同位置和时间的值，类似一个空间中的中点法 Rigid body simulation 刚体，不会发生形变，也就是会让内部所有的点按照同一种方式去运动 会考虑更多的物理量 角度、角速度、角加速度 Fluid simulationA Simple Position-Based Method key idea： 假设水是由刚体小球组成的 假设水都是不可压缩的，也就是水密度始终一致 直到水的分布就知道水的密度，当水的密度改变时，就需要将密度修正回来 就通过移动小球的位置来修正 我们需要知道任何一个点的密度对小球的位置的梯度，可以理解为，在一个点，小球的位置的改变会对密度产生改变，梯度就是衡量这个改变 然后就使用梯度下降法(gradient descent) 会产生停不下来的问题，所以在实际中人们会加入能量损失等方法来让模拟停止 Eulerian vs. Lagrangian 两种模拟一大堆物体的方法 上述模拟水的方法称为拉格朗日方法(Lagrangian)，俗称质点法，会盯着物体的变化 解常微分方程称为欧拉方法，也叫网格法，会盯着一个网格的变化 Material Point Method (MPM) 混合方法，两种方法都考虑在内 Lagrangian：认为每个粒子都有着一种材质属性 Eulerian：在格子中做融化过程 Interaction：最后把格子的信息写回粒子上 " }, { "title": "GAMES101-Lecture 21 Animation", "url": "/posts/GAMES101-Lecture-21-Animation/", "categories": "Computer Graphics, GAMES101", "tags": "图形学, 学习笔记", "date": "2023-08-03 08:08:00 +0000", "snippet": "Animation 是模型的拓展 电影：24 frames per second 视频：整体上都是30fps 虚拟现实：90fps（不晕的话） History 早期动画，把动画画在一个圆盘上 起初动画是为了科学研究，但渐渐发现人们喜欢看动态的东西，所以就向娱乐化发展 1963年就有计算机的动画了，19...", "content": "Animation 是模型的拓展 电影：24 frames per second 视频：整体上都是30fps 虚拟现实：90fps（不晕的话） History 早期动画，把动画画在一个圆盘上 起初动画是为了科学研究，但渐渐发现人们喜欢看动态的东西，所以就向娱乐化发展 1963年就有计算机的动画了，1972就有人脸的动画了，1993侏罗纪公园，1995玩具总动员…… Keyframe animation 关键帧动画 每一个帧有若干重要的点，这些重要的点在其他帧长什么样子，重要点之间的关系找到，然后通过插值的方式找出中间的部分来 希望有一种方式控制插值的效果（比如动作渐变），因此，曲线、样条应运而生 动画和几何是很有关联的 Physical simulation 使用牛顿定律 模拟的好的话，不会发生违反物理的原理（至少不会穿模 Mass Spring System 质点弹簧系统 x表示位置 $\\dot{x} = v$ 表示一阶导数 $\\ddot{x} = v $ 表示二阶导数 Simple motion damping简单运动阻尼 这个并没有考虑弹簧内部的损耗 Internal Damping for Spring 前面的 $\\frac{b-a}{   b-a   }$ 是用来算后面 $\\dot{b}-\\dot{a}$ 的方向的，也就是取正号还是负号，但是这个力必须得沿着速度方向投影，才算真正能作用到弹簧上的力，所以后面要点乘一个 $\\frac{b-a}{   b-a   }$ Structures from Springs 简单的弹簧sheet没有抗切变的力，也没有抗弯曲的力，所以不能正确模拟布 所以在每一格中加一条斜线，但是又不对称了，有了各向异性 再加一条斜线，但仍然不能正确抗弯曲 任何一个点和相隔的一个点连线，加一点点非平面的弯折 Aside: FEM(Finite Element Method) Instead of Springs 有限元方法Particle System 根据需要创建新的粒子 定义每个粒子受到的力 重力、电子力、斥力、弹力、牵引力、摩擦力、空气阻力、粘滞力 碰撞 更新粒子的位置和速度 移除死亡的粒子 渲染粒子 都是先模拟再渲染，水也可以是粒子模型 Simulated Flocking as an ODE 模拟鸟群Kinematics 运动学 骨骼系统：定义不同的关节 关节类型： Pin(一维旋转) Ball(二维旋转) Prismatic joint(可以移动) 定义好连接方式，就可以计算运动位置 Kinematics Pros 艺术家喜欢拖拽Inverse Kinematics 逆运动学 计算复杂，而且存在多解的问题 Rigging 对于木偶的一个操作，吊索 软选取、蒙皮 Blend Shape 定义若干不同的状态，中间是插值出来的Motion Capture 动作捕捉，加速获取控制点数据 缺点： 准备麻烦 捕捉出的动作不一定符合要求 数据不一定好 摄像机成本 身体遮挡 有多种动捕方法 Optical Magnetic Mechanical Challenges of Facial Animation 通过真实的动画生成方式产生了恐怖谷效应The Production Pipeline" }, { "title": "GAMES101-Lecture 20 Color and Perception", "url": "/posts/GAMES101-Lecture-20-Color-and-Perception/", "categories": "Computer Graphics, GAMES101", "tags": "图形学, 学习笔记", "date": "2023-07-31 07:49:00 +0000", "snippet": "Light Field / Lumigraph 光场：记录所有光可能的位置和方向The Plenoptic Function(全光函数) 从一个地方，往某个方向看（极坐标） 然后添加一个变量-波长（也就是添加了颜色） 然后再扩展一个时间t，那么现在就是电影 然后再扩展一个三维空间中任意的位置，也就是全息电影 首先定义光线：5...", "content": "Light Field / Lumigraph 光场：记录所有光可能的位置和方向The Plenoptic Function(全光函数) 从一个地方，往某个方向看（极坐标） 然后添加一个变量-波长（也就是添加了颜色） 然后再扩展一个时间t，那么现在就是电影 然后再扩展一个三维空间中任意的位置，也就是全息电影 首先定义光线：5D，极坐标2个参数代表方向，空间位置3个参数 可以缩减到4D，也就是位置改成2个，因为光路可逆，所以看物体，也就相当于物体的包围盒上一点与视点的连线，所以包围盒的坐标（2个参数）当成空间中的坐标 光场的好处就是从任意一个位置看向物体，都可以在光场中查询到物体的颜色值Lumigraph - Organization 参数化表达方法，再找一个平面，将两个平面的两个点进行计算，就能找到方向 st是世界 固定uv一个点，那么在st上就是看的uv上的固定的一个点，我觉得也可以理解成人在uv上看，看向st，看到的是整个世界的东西 固定st一个点，看向uv上每一个点，看到的是对于同一个物体，不同方向是什么，理解为人在uv上看向st，从各个方向看st的一个位置，相当于将st的irradiance拆成了从uv发射向st的radiance Integral Imaging (“Fly’s Eye” Lenslets) 光场摄像机，将一个像素收到的irradiance转换成radiance，某个方向的光经过透镜，radiance到一个点Light Field CameraThe Lytro Light Field Camera 先拍照，支持后期聚焦，后期改光圈 原理就是把原本吸收irradiance的像素改成微透镜，把irradiance分散到不同的方向去，在后面记录下来 有了光场之后就可以虚拟地移动相机的位置 缺点： 光场摄像机有分辨率不足的问题 高成本 ColorPhysical Basis of ColorSpectrum of Light 不同的波长对应不同的折射率Spectral Power Distribution(SPD) 光线在不同的波长，强度是多少 不同的光有不同的SPD SPD有线性的性质 Biological Basis of Color 视网膜上有感光细胞 棒状细胞感知光强度 锥形细胞感知颜色 又分成三种不同的细胞 S细胞感知小波长，高频率的光 M感知中波长 L感知长波长 Tristimulus Theory of Color SPD和人们感知细胞的积分得到的就是感知到的颜色Metamerism(同色异谱) 两种SPD不同的光，但被感知到的颜色确实相同的 通过一些方法混合成人类看起来一样的光，其背后的光谱不一定相同 Color Reproduction / Matching 加色系统 加色系数可能是负数 CIE RGB Color Matching Experiment 每种波长的颜色由三种颜色按不同系数相加得到Color Space Standardized RGB(sRGB) 广泛应用于成像设备 色域是有限的 CIE XYZ Y一定程度上表示颜色的亮度 将XYZ归一化，得到xyz，三者加起来是1，这样的话可视化xy即可 固定Y，可视化x，y Perceptually Organized Color SpacesHSV Color Space 专为艺术家而定 色调、饱和度、亮度 CIELAB Space L亮度 a轴两端是红色和绿色 b轴两端是蓝色和黄色 LAB认为一个轴两端是互补色 人脑会自动处理互补色（好玩 CMYK: A Subtractive Color Space 减色系统 蓝绿色、品红色、黄色和黑色 为什么一定要黑色，因为印刷要考虑成本，黑色墨水好造，便宜 " }, { "title": "GAMES101-Lecture 19 Cameras, Lenses and Light Fields", "url": "/posts/GAMES101-Lecture-19-Cameras,-Lenses-and-Light-Fields/", "categories": "Computer Graphics, GAMES101", "tags": "图形学, 学习笔记", "date": "2023-07-28 08:05:00 +0000", "snippet": "Pinhole Image Formation 针孔相机没有深度，每个地方都是清晰的，看不到虚化的地方 光线追踪的时候用的就是针孔摄像机的原理，所以就没有景深的效果 Field of View(FOV) 视场Effect of Focal Length on FOV fov和传感器大小和焦距有关，但默认传感器是有一个固定的大小，也就是说焦距是按照35mm的...", "content": "Pinhole Image Formation 针孔相机没有深度，每个地方都是清晰的，看不到虚化的地方 光线追踪的时候用的就是针孔摄像机的原理，所以就没有景深的效果 Field of View(FOV) 视场Effect of Focal Length on FOV fov和传感器大小和焦距有关，但默认传感器是有一个固定的大小，也就是说焦距是按照35mm的胶片(film)（也可以说是传感器）去定义的，其实传感器可能大小不同，但焦距都是按35mm的胶片去定义的 更长的焦距对应更小更远的视场 Effect of Sensor Size on FOV 更大的传感器，对应更大更近的视场 传感器sensor和胶片film区分： sensor吸收irradiance film用来决定最后存成什么样的格式 Exposure H = T * E Exposure(H)= time(T) * irradiance(E) 快门控制进光时间 光圈大小和焦距会影响到irradiance Exposure Controls Aperture size光圈大小：改变光圈大小来改变f-stop Shutter Speed快门速度：改变快门速度来改变感光时间 ISO gain感光度：后期处理，增加最后图片的曝光，可以调整硬件也可以调整软件，简单放大信号会同时放大噪声 为什么会有噪声，感光时间不足，光子就不足，就会产生noise ISO 线性增加F-Number(F-Stop) 不正式的理解：F数是光圈直径的倒数Side Effect Shutter Speed 会产生运动模糊 Rolling shutter：对于超级高速的东西产生扭曲 Constant Exposure: F-Stop vs Shutter SpeedThin Lens Approximation 薄透镜近似 使用透镜组来成像 实际的透镜很复杂，不一定理想 我们考虑的是理想化的透镜 基本假设： 平行光穿过透镜交于焦点 过焦点的光穿过透镜会平行 焦距可以修改(通过透镜组) 穿过透镜中心的光线，方向不会改变 焦距的倒数 = 相距的倒数 + 物距的倒数，也就是对于一个固定焦距的透镜来说，改变物距相距也一定会跟着改 通过相似三角形来获得上述的关系 这个叫高斯定理，也叫薄透镜的定理 Defocus Blur 和景深有关系了Computing Circle of Confusion(CoC) 物体的一个点根据薄透镜的定理，会成像到一个点，但是感光sensor Plane比那个成像点远的话，就会打成一片，也就成了一个圆 如果其他都确定了，那么这个C和A(aperture)有关 CoC和光圈大小成正比 所以大光圈就会有更模糊的效果 F数=焦距除以光圈的直径 N = f/ARay Tracing Ideal Thin Lenses 就是在ray tracing中模拟透镜的模糊效果Ray Tracing for Defocus Blur(Thin Lens) 首先定义感光器大小、透镜焦距、透镜大小 选择将透镜放在一个距离重拍摄平面Z0远的地方，也就是物距Z0 自然可以计算出像距Zi，也就是sensor距离透镜的距离 也就是下面$x\\prime$点来自于$x\\prime\\prime -&gt; x\\prime\\prime\\prime$打的光线，交于着色点 Depth of Field 模糊是有一个范围Circle of Confusion for Depth of Field 景深就是指在实际的场景中有一段深度，这段深度在经过透镜后，会在成像平面附近形成一个区域，在这块区域，我们认为，产生的CoC都是足够小的 可以通过公式将那个DoF解出来 " }, { "title": "GAMES101-Lecture 18 Advanced Topics in Rendering", "url": "/posts/GAMES101-Lecture-18-Advanced-Topics-in-Rendering/", "categories": "Computer Graphics, GAMES101", "tags": "图形学, 学习笔记", "date": "2023-07-27 08:05:00 +0000", "snippet": "Advanced Light TransportUnbiased light transport methods Unbiased无偏的，如果得到的期望是最后要的值一样，那就是无偏的 biased有偏的 Bidirectional path tracing (BDPT) 摄像机打出一条光线后反射，光源打出一条光线，将两个端点连接起来 这个方法...", "content": "Advanced Light TransportUnbiased light transport methods Unbiased无偏的，如果得到的期望是最后要的值一样，那就是无偏的 biased有偏的 Bidirectional path tracing (BDPT) 摄像机打出一条光线后反射，光源打出一条光线，将两个端点连接起来 这个方法对于接受间接光的场景很好 缺点： 实现困难 运行慢 Metropolis light transport (MLT) A Markov Chain Monte Carlo (MCMC) application 当被积函数和概率密度函数的形状一致时，会比较好，这个方法可以生成和被积函数形状相同的pdf 这是一个局部的方法，给一个路径生成相似的路径 当光路比较复杂的时候，也就是越难的场景，这个方法的效果越好 缺点： 不知道什么时候会收敛 像素收敛速度不一样，所以有的图像会比较脏 Biased light transport methodsPhoton mapping(光子映射) 适合做Specular-Diffuse-Specular(SDS) 适合做generating caustics 第一步，从光源出发，发射光线直到打到diffuse的物体 第二步，从摄像机出发，发射光线直到打到diffuse的物体 第三步，计算局部的密度估计，光子分布越集中的地方越亮 对于任何一个着色点，取它周围的最近的n个光子 除以光子占的面积（求面积有各种各样的方法） 很少的n，噪声就会很大 很大的n，就会变的模糊 这就是为什么就是有偏的的方法 因为我们该算一个点的密度，但实际算的是一个区域的密度，也就是说对密度的估计是个不对的估计 只有覆盖的面积无限小才会对，如果找同样的点数，那么发射的光子越多，越精确，也就是当发射足够多的光子时，就会得到正确的结果，所以这种方法就叫有偏的方法，也叫一致的方法consistent 对有偏的一个理解： 有偏的 == 模糊的 一致的 == 如果无限采样就不再模糊 Vertex connection and merging (VCM) 把双向路径追踪和光子映射结合起来 BDPT的子路径端点如果不能连线，就看能不能合并 使用光子映射的方式来处理合并附近的光子Instant radiosity (VPL / many light methods) 实时辐射度算法 先发射light sub-path(BDPT)，并且假设每一条sub-path的端点是虚拟光源(VPL)virtual point light 也就是说使用直接光照的方法就能得到间接光照的效果 问题： 有一些地方会莫名其妙的发光，和之前两个点的距离有关，当光源和物体表面的距离很接近就会除以一个接近0的数 VPL不能做Glossy的物体 Advanced Appearance ModelingNon-Surface ModelsParticipanting media 散射介质 光打到云里，会打到小冰晶然后分散到各个地方去，当然，小冰晶也可能接受到其他反射过来的光 有一些光传着传着就没了，比如乌云 所以光线进入云之后会发生两件事情 被吸收 被散射：均匀散、反向散、前向散 使用Phase Function相位函数来确定光线怎么散射（跟BRDF的key很像） 随机选一个弹射方向、选一个发射距离（根据介质），在每一个shading point与光源连线 Hair/fur/fiber(BCSDF) 对于头发而言，要考虑光和一个曲线作用，而不是面 头发有两种高光 一种无色的高光 一种有色的高光 Kajiya-Kay Model 一根光线打到圆柱上，然后会散射到一个圆锥上，于此同时，也会向四面八方散射 但这个类似blinn-phong，并不真实 Marschner Model 打到头发的光线，一部分会反射出去，另一部分会穿进头发里面去再穿出去（折射），叫TT，穿进头发后，打到头发内壁再反射回来，叫TRT 把头发当成玻璃的圆柱，由cuticle(表皮)和cortex(absorbs)组成，头发还有色素 考虑了三种光线传播: R、TT、TRT 要多次散射，计算量很大 人物的头发模型渲染到动物皮毛是不对的 头发有三层结构 cuticle cortex medulla（髓质）：更容易发生散射（我理解成云一样的材质） 人头发的medulla很少，但动物毛发的medulla很多，这就造成了不同Double Cylinder Model(Linqi Yan发明的) 这个模型考虑了medulla 除了有R、TT、TRT外，又新加了TTs(类似TT，但是更加散射)和TRTs(类似TRT，但更加散射)Granular material(颗粒材质) 一粒一粒的模型 运行时间很长 Surface ModelsTranslucent material(BSSRDF) 半透明材质，但是不只是有光被吸收，光进入后还会发生散射，在其他地方射出 玉石、水母 Subsurface Scattering 次表面散射 BSSRDF: 这次有四个参数，结合了BRDF后还加了入射点和出射点$S(x_i,w_i,x_0,w_0)$ 因为不仅要考虑光对某个方向的贡献，还要考虑对哪个点做的贡献，所以既要对方向进行积分，还要对面积进行积分 L( $ x_ {0} $ , $ \\omega _ {0} $ )= $ \\int _ {A} $ $ \\int _ {H^ {2}} $ S( $ x_ {i} $ , $ \\omega _ {i} $ , $ x_ {o} $ , $ \\omega _ {0} $ ) $ L_ {i} $ ( $ x_ {i} $ , $ \\omega _ {i} $ ) $ \\cos $ $ \\theta _ {i} $ d $ \\omega _ {i} $ dADipole Approximation 当光打在半透明的物体上时，就好像在物体内部有一个光源，但一个还不够，在外面也需要一个，这就是这个方法的key 会有珠圆玉润的效果 Cloth 由缠绕的纤维组成 纤维缠绕会形成股ply，股再缠绕形成线yarn BRDF Render as Participating Media 把cloth当成体积，分成一个小小的格子 Render as actual fibers 计算量很大 Detailed material(non-statistical BRDF) 需要处理路径采样的问题 使用BRDF over a pixel，使用p-NDF(说实话，我的理解就是根据normal map来生成一个像素的pdf分布) 波动光学（巨复杂，需要在负数域上积分）Procedural appearance 噪声函数，使用噪声函数来程序化生成纹理、地形、水面" }, { "title": "GAMES101-Lecture 17 Materials and Appearances", "url": "/posts/GAMES101-Lecture-17-Materials-and-AppearancesGAMES101-Lecture-17-Materials-and-Appearances/", "categories": "Computer Graphics, GAMES101", "tags": "图形学, 学习笔记", "date": "2023-07-26 03:30:00 +0000", "snippet": "Material == BRDF 材质就是：一个表面怎么被反射的Diffuse/Lambertian Material 满足能量守恒，假设一个着色点均匀地吸收多少能量就均匀地发出多少能量即radiance==irradiance 然后经过推导，算出BRDF也就是f_r是$1/\\pi$，这就是不吸收任何能量的BRDF 我们设定一个变量$\\rho$为alb...", "content": "Material == BRDF 材质就是：一个表面怎么被反射的Diffuse/Lambertian Material 满足能量守恒，假设一个着色点均匀地吸收多少能量就均匀地发出多少能量即radiance==irradiance 然后经过推导，算出BRDF也就是f_r是$1/\\pi$，这就是不吸收任何能量的BRDF 我们设定一个变量$\\rho$为albedo反射率，范围是[0,1] Glossy Material 金属类的材质，不会均匀反射而是往一个大致方向反射Perfect Specular Reflection 完美反射 方位角差$\\pi$ Specular Refraction - Snell’s Law 折射定律 根据折射率可以算出折射角 方位角差$\\pi$ 当入射的介质折射率大于折射的介质折射率就可能会出现没有折射，那么就是全反射 反射(BRDF)和折射(BTDF)可以统称BSDF，S代表的是散射Fresnel Reflection/Term(菲涅尔项) 入射光和物体表面法线的夹角越大，越多的光被反射，夹角越小，越多的光被折射而很少被反射 比如一个实际的例子，在车里，后排乘客看前车玻璃看到的是车内司机，看后车玻璃看到的是车外景 极化现象，但一般光是由s极化和p极化组成的（也叫s偏振和p偏振） 但对于导体而言，菲涅尔项不管角度如何都是很高的，也就是反射的光很多，这也是为什么会古代用铜和银做镜子 菲涅尔项公式，n1入射介质系数（折射率），n2折射介质系数，但公式太复杂，所以有了下面的简化公式 Schlick’s approximation：主旨就是拟合一条曲线，从一个值到1，绝缘体就从很小的数比如0开始，导体就从比较大的数开始，比如0.9，正常情况下，是个不错的近似 导体的折射率是负数，所以还要一个k系数 Microfacet Material(PBR) 当我们距离很远看一个物体表面时，很多微小的东西就看不到，最终能看到的是，表面对光的一个总体作用 每一个微表面理解成一个微小的镜面 也就是说，微表面模型，从远处看是材质外观，从近处看是几何 Microfacet BRDF 对于glossy材质，比较平，法线基本都朝上，所以法线会宏观得聚集在向上的一个小范围 对于diffuse材质，法线在方向上散的就比较开，所以分布范围就很广 BRDF: F(Fresnel term)：首先考虑一个菲涅尔项（也就是说能反射多少光出来） D(distribution of normals)：法线分布，就是解决，有多少微表面能把光从wi反射到wo，因为只有微表面的法线方向和半程向量一致时，才会反射（把微表面当成镜子），所以就是D(h)，在h方向上法线分布的一个查询 G(shadowing-masking term)：自阴影，有一些微表面被另一些微表面挡住了，而失去了它们反射光的作用，在入射光几乎是平着打在平面上时，最容易发生这个现象，我们称这个角度为grazing angle 微表面模型问题：diffuse项很少，有时人们要认为添加一些漫反射 有很多微表面模型 Isotropic(各向同性)/Anisotropic(各向异性) Materials(BRDFs) 各向同性：微表面并不存在一定的方向性，或者方向性很弱 各向异性：微表面有方向性 各向异性定义：如果入射出射角不变，只有方位角旋转，看到的BRDF不一样那就是各向异性的材质，反之如果一样就是各向同性的材质Anisotropic Brushed MetalAnisotropic BRDF: NylonAnisotropic BRDF: VelvetProperties of BRDFs 非负，他表示的是能量的分布 线性分布，可以拆成很多块，然后加起来 可逆性，入射方向和出射方向调换得到的brdf一模一样 能量守恒，能量不可能变多 各向同性和各向异性 如果是各项同性的材质，维度降低了一维 Measuring BRDFsImage-Based gonioreflectometer 枚举所有的出射方向和入射方向进行测量 提升效率的一些方法 各向同性降维 可逆性，砍半 采样若干点后其他点进行猜测 Representing Measuring BRDFs Tabular Representing" }, { "title": "GAMES101-Lecture 16 Ray Tracing 4(Monte Carlo Path Tracing) & 作业7", "url": "/posts/GAMES101-Lecture-16-Ray-Tracing-4-&-%E4%BD%9C%E4%B8%9A7/", "categories": "Computer Graphics, GAMES101", "tags": "图形学, 学习笔记", "date": "2023-07-25 08:22:00 +0000", "snippet": "Monte Carlo Integration WHY:我们想要算一个函数的积分，但积分难以写出表达公式，所以就用蒙特卡洛的方法求出定积分那个数值来 WHAT&amp;HOW:就是相当于离散化后求面积 其中f(Xi)相当于在Xi处的函数值，除以该函数值出现的概率，就相当于求出了以f(Xi)的值为长，概率密度函数p(Xi)的值为高，的一个矩形面积，就像这样不断采样...", "content": "Monte Carlo Integration WHY:我们想要算一个函数的积分，但积分难以写出表达公式，所以就用蒙特卡洛的方法求出定积分那个数值来 WHAT&amp;HOW:就是相当于离散化后求面积 其中f(Xi)相当于在Xi处的函数值，除以该函数值出现的概率，就相当于求出了以f(Xi)的值为长，概率密度函数p(Xi)的值为高，的一个矩形面积，就像这样不断采样，在积分域中采样n个，最后除以n，就是蒙特卡洛积分，任何积分都可以这么做Path Tracing 提出path tracing就是为了解决whitted-style ray tracing一些不正确的地方 whitted-style中ray打到diffuse就会停，但是实际上不应该停住 render equation是正确的 需要计算半球内的积分 需要递归 A Simple Monte Carlo Solution 把自发光去掉 其中pdf为啥是$1/2\\pi$，这是因为，球的立体角是$4\\pi$，半球就是一半 使用蒙特卡洛： 直接光照（没有考虑间接光照）的伪代码：Global Illumination 间接光照，使用递归即可 伪代码如下： 但这么做，会产生两个问题 首先是光线的数量会爆炸，数量级会不断增加，当n（也就是随机取的光线数量）为1时，不会爆炸，此时就叫做path tracing，问题就是噪声非常大 所以就需要向每个像素投射更多路径然后求平均，投射时也采用蒙特卡洛积分，向像素点随机选择n个位置 递归需要一个终止条件 此时，聪明的人类提出了一种方法：Russian Roulette俄罗斯轮盘赌 Russian Roulette (RR) 先前，我们总是会发射一条光线到shading point，然后道德shading结果Lo 现在，我们假设人为地设置一个概率P(0&lt;P&lt;1)，在概率P的可能下会发射一条光线并得到shading结果为Lo/P，在概率1-P的可能下不发射光线，结果也就是0 通过这种方法，仍然可以期望得到Lo $E=p(Lo/P)+(1-P)0=Lo$ 伪代码如下： 但这并不是很高效，因为有的光源很小，所以采样的时候发射很多光线才有可能打到，但这就浪费了很多其他光线，所以就引出了下面的方法：在光源上采样Sampling the Light(pure math) 需要把渲染方程写成在光源上的积分 也就是说需要找到dw和dA的关系 首先需要将光源转向着色点 然后除以dA和dw距离的平方 然后就能很快解决蒙特卡洛积分 所以现在的path tracing就分为两部分 一部分光线就进行对光源的采样积分 另外一部分反射不到光源的，就进行俄罗斯轮盘赌的蒙特卡洛积分 最后还有一步，要判断光源与着色点之间是不是有其他物体阻挡 伪代码： 尚存的问题 如何在半球进行均匀的采样，如何对一个函数采样 目前用的均匀的pdf是最好的方法吗 随机数有好坏之分吗（low discrepancy sequences的随机数生成的比较均匀） 结合对半球和光源的采样（multiple imp. sampling） 像素的radiance是所有路径radiance的平均，为什么？(pixel reconstruction filter) 像素的radiance就是像素的颜色吗？no（gamma correction, curves, color space） 作业7    在本次实验中，你只需要修改这一个函数: castRay(const Ray ray, int depth)in Scene.cpp: 在其中实现 Path Tracing 算法    可能用到的函数有： intersect(const Ray ray)in Scene.cpp: 求一条光线与场景的交点 sampleLight(Intersection pos, float pdf) in Scene.cpp: 在场景的所有光源上按面积 uniform 地 sample 一个点，并计算该 sample 的概率密度。 形参都是引用参数，也就是说我们需要传入pos交点和pdf变量然后通过这个函数来获取对光源采样的值。 这个函数的大致意思就是，统计整个scene的光源，然后根据每个光源的面积来作为贡献，挨个累加判断是否要对这个光源采样，所以其实这么采样的话，光源的顺序对最终结果是有影响的，不过该案例只有一个光源，所以没关系。正常来讲，需要让光源的顺序尽可能的随机 void Scene::sampleLight(Intersection &amp;pos, float &amp;pdf) const{ float emit_area_sum = 0; for (uint32_t k = 0; k &lt; objects.size(); ++k) { if (objects[k]-&gt;hasEmit()){ emit_area_sum += objects[k]-&gt;getArea(); } } float p = get_random_float() * emit_area_sum; emit_area_sum = 0; for (uint32_t k = 0; k &lt; objects.size(); ++k) { if (objects[k]-&gt;hasEmit()){ emit_area_sum += objects[k]-&gt;getArea(); if (p &lt;= emit_area_sum){ objects[k]-&gt;Sample(pos, pdf); break; } } }} sample(const Vector3f wi, const Vector3f N) in Material.hpp: 按照该材质的性质，给定入射方向与法向量，用某种分布采样一个出射方向 pdf(const Vector3f wi, const Vector3f wo, const Vector3f N) in Material.hpp: 给定一对入射、出射方向与法向量，计算 sample 方法得到该出射方向的概率密度 eval(const Vector3f wi, const Vector3f wo, const Vector3f N) in Material.cpp: 给定一对入射、出射方向与法向量，计算这种情况下的 f_r 值。关于这个eval值，需要特别说明一下 其中，wi是摄像机到物体obj的方向(也就是prime ray)，但是在Diffuse模型中不会用到，这个参数会在附加题微表面模型(Microfacet)中用到 wo就是物体obj指向光源或者物体obj2的方向，N就是光源或者obj2的法向量 那么欸，为什么上面的描述和图片上画的wi、wo反了呢？那是因为，描述的wi、wo是指函数形参的名字（和图是反的，也就是说，函数形参的wi对应的是图中的wo,那么问题来了，为什么一定要写反，我现在感觉是历史遗留问题，当年写的时候脑子里应该是一团浆糊，看教程这么写，我也这么写了，哎，谁要是不小心看了我的博客，那真的是倒大霉了，2024.3.15留） 需要注意的是，这是函数的方向图，在写代码的时候要注意写的方向是不是相反了，如果相反，那么在调用函数的时候需要在前面加个负号     可能用到的变量有： RussianRoulette in Scene.cpp: P_RR, Russian Roulette 的概率前言    这次作业有一定的难度，参考了很多博客和文章，这些文章将在最后给出链接，都讲的相当不错！虽然文档中说只需要修改castRay()函数，但其实蛮多地方需要修改的，伪代码的话就在上面的图中，那么现在开始简单介绍下我的工作    首先代码框架的get_random_float()需要改下，改成static后，就不会每次调用函数都创建变量了，运行速度更快，而且生成的随机数的质量更高inline float get_random_float(){ static std::random_device dev; static std::mt19937 rng(dev()); static std::uniform_real_distribution&lt;float&gt; dist(0.f, 1.f); // distribution in range [1, 6] return dist(rng);}Path Tracing 首先就是修改castRay函数，整个流程按照伪码来写就好，需要注意的就是伪码中各个变量的含义 shade函数其实就是castRay函数(形参depth没太大用，我是没用，但有的博主用了) 在计算直接光照L_dir时 L_i就是光源的emit，这个在Intersection对象中会有这个值 f_r 就是上面提到的eval函数计算出来的 $x\\prime$是光源的点 p是着色点，也就是交点 pdf_light就是用sampleLight函数计算出来的pdf概率 在计算间接光照L_indir时 P_PR就是轮盘赌的概率，其实就是RussianRoulette，这个是内置的成员变量，直接使用就好，默认是0.8 然后就是使用材质类的sample函数来获取通过采样来计算出的反射方向（这个方向就是要去射向obj2的射线） pdf_hemi是需要使用材质的pdf函数来计算出来的pdf概率 整体代码如下，注意，上面注释的代码是带有中文解释的，但是如果直接与运行带着这么多中文注释的代码的话，就会报错，报未定义标识符的错，我的建议是写英文注释或者写中文注释就一行一行写，写的规范点 Vector3f Scene::castRay(const Ray &amp;ray, int depth) const{ //// TO DO Implement Path Tracing Algorithm here //Intersection inter = intersect(ray); ////如果prime ray没有打到物体 //if (!inter.happened)return Vector3f(); ////prime ray打到物体了 ////0.如果prime ray打到了光源直接返回光源信息 //if (inter.m-&gt;hasEmission()) return inter.m-&gt;getEmission(); ////如果打到的不是光源而是一个物体obj，那么就需要求出直接光照和间接光照 //Vector3f L_dir;//默认构造函数是初始化为0 //Vector3f L_indir; //float EPLISON = 0.01; ////1.直接光照： //float light_pdf = 0.f;//初始化 //Intersection light_inter; //sampleLight(light_inter, light_pdf);//获得光源信息，光源的intersection和打到光源的的pdf // //auto p = inter.coords;//物体obj的坐标 //auto x = light_inter.coords;//光源的坐标 //auto ws = (p-x).normalized();//光源到物体obj的方向 //auto ws_dis = (p - x).norm();//光源到物体obj的距离 //auto N = inter.normal.normalized();//物体obj的法线 //auto NN = light_inter.normal.normalized();//光源的法线 //auto emit = light_inter.emit;//光源的光 //Ray ws_ray = Ray(p, -ws);//物体obj到光源发出的光线 //Intersection blocked = intersect(ws_ray); //if (ws_dis - blocked.distance &lt; EPLISON)//如果没有打到其他物体，也就是中间没有物体阻挡 //{ // L_dir = emit * inter.m-&gt;eval(ray.direction,-ws,N) // *dotProduct(-ws, N)*dotProduct(ws,NN) // /(ws_dis * ws_dis)/ light_pdf; //} ////2.间接光照： // // //float P_RR = get_random_float(); //if (P_RR &gt; RussianRoulette) return L_dir; ////如果赌赢了，就算间接光照 ////根据物体obj的材质、入射方向和法线来采样一个出射方向wi //Vector3f wi = inter.m-&gt;sample(ray.direction, N).normalized(); //Ray wi_ray(p, wi);//物体obj采样到的指向物体obj2的光线 //Intersection obj2_inter = intersect(wi_ray); ////如果该光线打到物体了而且该物体obj2不是发光物 //if (obj2_inter.happened &amp;&amp; !obj2_inter.m-&gt;hasEmission()) //{ // L_indir = castRay(wi_ray, depth+1) // * inter.m-&gt;eval(ray.direction, wi, N) * dotProduct(wi, N) // / inter.m-&gt;pdf(ray.direction, wi, N) / RussianRoulette; //} //return L_dir + L_indir; Intersection inter = intersect(ray); if (!inter.happened)return Vector3f(); if (inter.m-&gt;hasEmission()) return inter.m-&gt;getEmission(); Vector3f L_dir; Vector3f L_indir; float EPLISON = 0.01; float light_pdf; Intersection light_inter; sampleLight(light_inter, light_pdf); auto p = inter.coords; auto x = light_inter.coords; auto ws = (p - x).normalized(); auto ws_dis = (p - x).norm(); auto N = inter.normal.normalized(); auto NN = light_inter.normal.normalized(); auto emit = light_inter.emit; Ray ws_ray = Ray(p, -ws); Intersection blocked = intersect(ws_ray); if (ws_dis - blocked.distance &lt; EPLISON) { L_dir = emit * inter.m-&gt;eval(ray.direction, -ws, N) * dotProduct(-ws, N) * dotProduct(ws, NN) / (ws_dis * ws_dis) / light_pdf; } float P_RR = get_random_float(); if (P_RR &gt; RussianRoulette) return L_dir; Vector3f wi = inter.m-&gt;sample(ray.direction, N).normalized(); Ray wi_ray(p, wi); Intersection obj2_inter = intersect(wi_ray); if (obj2_inter.happened &amp;&amp; !obj2_inter.m-&gt;hasEmission()) { L_indir = castRay(wi_ray, depth + 1) * inter.m-&gt;eval(ray.direction, wi, N) * dotProduct(wi, N) / inter.m-&gt;pdf(ray.direction, wi, N) / RussianRoulette; } return L_dir + L_indir;}多线程 这个题目的话，参考两个博客即可 (23条消息) C++11 多线程（std::thread）详解_c++多线程_jcShan709的博客-CSDN博客 (23条消息) Games101：作业7（含提高部分）_games101作业7实现 microfacet模型_Q_pril的博客-CSDN博客 我就不做多解释了，看了第一篇博客，就会对多线程有一个初步的理解，然后可以看看第二个博主的实现过程，其实就是把图片横着分成24份，交给24个线程去做，速度确实有很大的提升 其中，需要注意的点，博主也讲了，就是progress是个所有线程都需要使用的变量，所以要加个mutex锁（其实我试过加atomic_t这样的锁，但是这样的话控制台打印进度的时候就会打一大堆符号，而且并不比上mutex锁快） 代码如下： 在Renderer.cpp文件中添加以下头文件和全局变量 #include &lt;thread&gt;#include &lt;mutex&gt;std::mutex mtx;int progress = 0;void Renderer::Render(const Scene&amp; scene){ std::vector&lt;Vector3f&gt; framebuffer(scene.width * scene.height); float scale = tan(deg2rad(scene.fov * 0.5)); float imageAspectRatio = scene.width / (float)scene.height; Vector3f eye_pos(278, 273, -800); int m = 0; // change the spp value to change sample ammount int spp = 16; std::cout &lt;&lt; \"SPP: \" &lt;&lt; spp &lt;&lt; \"\\n\"; //thread int thread = 24; int per = scene.height / thread; //40 std::thread th[24]; auto RenderRow = [&amp;](uint32_t row1, uint32_t row2) { for (uint32_t j = row1; j &lt; row2; ++j) { for (uint32_t i = 0; i &lt; scene.width; ++i) { // generate primary ray direction float x = (2 * (i + 0.5) / (float)scene.width - 1) * imageAspectRatio * scale; float y = (1 - 2 * (j + 0.5) / (float)scene.height) * scale; Vector3f dir = normalize(Vector3f(-x, y, 1)); for (int k = 0; k &lt; spp; k++) { framebuffer[(int)(j*scene.width + i)] += scene.castRay(Ray(eye_pos, dir), 0) / spp; } } mtx.lock(); progress++; UpdateProgress(progress / (float)scene.height); mtx.unlock(); } }; for (int i = 0; i &lt; thread; i++) { th[i] = std::thread(RenderRow, i * per, (i + 1) * per); } for (int i = 0; i &lt; thread; i++) { th[i].join(); } // no thread /* for (uint32_t j = 0; j &lt; scene.height; ++j) { for (uint32_t i = 0; i &lt; scene.width; ++i) { // generate primary ray direction float x = (2 * (i + 0.5) / (float)scene.width - 1) * imageAspectRatio * scale; float y = (1 - 2 * (j + 0.5) / (float)scene.height) * scale; Vector3f dir = normalize(Vector3f(-x, y, 1)); for (int k = 0; k &lt; spp; k++){ framebuffer[m] += scene.castRay(Ray(eye_pos, dir), 0) / spp; } m++; } UpdateProgress(j / (float)scene.height); } */ UpdateProgress(1.f); // save framebuffer to file FILE* fp = fopen(\"binary.ppm\", \"wb\"); (void)fprintf(fp, \"P6\\n%d %d\\n255\\n\", scene.width, scene.height); for (auto i = 0; i &lt; scene.height * scene.width; ++i) { static unsigned char color[3]; color[0] = (unsigned char)(255 * std::pow(clamp(0, 1, framebuffer[i].x), 0.6f)); color[1] = (unsigned char)(255 * std::pow(clamp(0, 1, framebuffer[i].y), 0.6f)); color[2] = (unsigned char)(255 * std::pow(clamp(0, 1, framebuffer[i].z), 0.6f)); fwrite(color, 1, 3, fp); } fclose(fp); } 单线程 多线程 1021s 91s Microfacet 这道题就有点高难度了，不单是实现，光是概念就有点难，公式推导也有点难度，但是网上做分析的很多，所以借鉴巨人们的肩膀，我们还是能窥见一点点世界的全貌 LearnOpenGL - Theory (23条消息) Games101,作业7（微表面模型）_微表面模型c++实现_Elsa的迷弟的博客-CSDN博客 从零开始学图形学：写一个光线追踪渲染器（二）——微表面模型与代码实现 - 知乎 (zhihu.com) 具体的一些解释还有方法在第二个博客都有讲，所以我就不展开讲咯 代码如下，这些代码都在Material.hpp /* 下面三个函数是计算微表面模型方程中的参数D、G(F直接使用框架提供的fresnel函数即可) */ //D float DistributionGGX(Vector3f N, Vector3f H, float roughness) { float a = roughness * roughness; float a2 = a * a; float NdotH = std::max(dotProduct(N, H), 0.f); float NdotH2 = NdotH * NdotH; float nom = a2; float denom = NdotH2 * (a2 - 1.f) + 1.f; denom = M_PI * denom * denom; //prevent divide by zero for roughness = 0 return nom / std::max(denom, 0.000001f); } //G(下面两个函数都是用来算G的) float GeometrySchlickGGX(float NdotV, float k) { float nom = NdotV; float denom = NdotV * (1.0 - k) + k; return nom / denom; } float GeometrySmith(Vector3f N, Vector3f V, Vector3f L, float roughness) { float r = (roughness + 1.0); float k = (r * r) / 8.0; float NdotV = std::max(dotProduct(N, V), 0.f); float NdotL = std::max(dotProduct(N, L), 0.f); float ggx2 = GeometrySchlickGGX(NdotV, k); float ggx1 = GeometrySchlickGGX(NdotL, k); return ggx1 * ggx2; } Vector3f Material::eval(const Vector3f &amp;wi, const Vector3f &amp;wo, const Vector3f &amp;N){ switch(m_type){ case DIFFUSE: { // calculate the contribution of diffuse model float cosalpha = dotProduct(N, wo); if (cosalpha &gt; 0.0f) { Vector3f diffuse = Kd / M_PI; return diffuse; } else return Vector3f(0.0f); break; } case MICROFACET: { //Disney PBR float cosalpha = dotProduct(N, wo); if (cosalpha &gt; 0.f) { float roughness = 0.40; Vector3f V = -wi; Vector3f L = wo; Vector3f H = normalize(V + L); //compute distribution of normals float D = DistributionGGX(N, H, roughness); //compute shaddoing masking term float G = GeometrySmith(N, V, L, roughness); //compute fresnel factor float F; float etat = 1.85; fresnel(wi, N, etat, F); Vector3f nominator = D * G * F; float denominator = 4 * std::max(dotProduct(N, V), 0.f) * std::max(dotProduct(N , L), 0.f); Vector3f specular = nominator / std::max(denominator, 0.001f); // conservation of energy float ks_ = F; float kd_ = 1.0f - ks_; Vector3f diffuse = Kd * 1.0 / M_PI; //ks_ = F, F is in specular return Ks * specular + kd_ * diffuse; } else return Vector3f(0.0f); break; } }} 如果要渲染球的话，需要修改Sphere.hpp中的代码：Intersection getIntersection(Ray ray){ Intersection result; result.happened = false; Vector3f L = ray.origin - center; float a = dotProduct(ray.direction, ray.direction); float b = 2 * dotProduct(ray.direction, L); float c = dotProduct(L, L) - radius2; float t0, t1; if (!solveQuadratic(a, b, c, t0, t1)) return result; if (t0 &lt; 0) t0 = t1; if (t0 &lt; 0) return result; //set accuracy if (t0 &gt; 0.5) { result.happened = true; result.coords = Vector3f(ray.origin + ray.direction * t0); result.normal = normalize(Vector3f(result.coords - center)); result.m = this-&gt;m; result.obj = this; result.distance = t0; } return result; } 然后就是在main函数中添加Sphere的代码 Material* whiteMicro = new Material(MICROFACET, Vector3f(0.0f)); whiteMicro-&gt;Kd = Vector3f(0.725f, 0.71f, 0.68f); Sphere* sphereDiffuse = new Sphere({ 130.f,80.f,200.f }, 80.f, white); Sphere* sphereMicro = new Sphere({ 420.f,80.f,200.f }, 80.f, whiteMicro); scene.Add(sphereDiffuse); scene.Add(sphereMicro); 不要忘记修改whiteMicro的Kd值，不然就会全黑 然后就是bunny，想要添加buuny需要改两处 参考博客(23条消息) Games101：作业7（含提高部分）_games101作业7实现 microfacet模型_Q_pril的博客-CSDN博客 首先是Triangle.hpp的构造函数，加两个形参，然后再改下vert MeshTriangle(const std::string&amp; filename, Material *mt = new Material(), Vector3f Trans = Vector3f(0.0f, 0.0f, 0.0f), Vector3f Scale = Vector3f(1.0f, 1.0f, 1.0f)) { objl::Loader loader; loader.LoadFile(filename); area = 0; m = mt; assert(loader.LoadedMeshes.size() == 1); auto mesh = loader.LoadedMeshes[0]; Vector3f min_vert = Vector3f{std::numeric_limits&lt;float&gt;::infinity(), std::numeric_limits&lt;float&gt;::infinity(), std::numeric_limits&lt;float&gt;::infinity()}; Vector3f max_vert = Vector3f{-std::numeric_limits&lt;float&gt;::infinity(), -std::numeric_limits&lt;float&gt;::infinity(), -std::numeric_limits&lt;float&gt;::infinity()}; for (int i = 0; i &lt; mesh.Vertices.size(); i += 3) { std::array&lt;Vector3f, 3&gt; face_vertices; for (int j = 0; j &lt; 3; j++) { auto vert = Vector3f(mesh.Vertices[i + j].Position.X, mesh.Vertices[i + j].Position.Y, mesh.Vertices[i + j].Position.Z); //for the bunny vert = Scale * vert + Trans; face_vertices[j] = vert; min_vert = Vector3f(std::min(min_vert.x, vert.x), std::min(min_vert.y, vert.y), std::min(min_vert.z, vert.z)); max_vert = Vector3f(std::max(max_vert.x, vert.x), std::max(max_vert.y, vert.y), std::max(max_vert.z, vert.z)); } triangles.emplace_back(face_vertices[0], face_vertices[1], face_vertices[2], mt); } bounding_box = Bounds3(min_vert, max_vert); std::vector&lt;Object*&gt; ptrs; for (auto&amp; tri : triangles){ ptrs.push_back(&amp;tri); area += tri.area; } bvh = new BVHAccel(ptrs); } 其次main函数MeshTriangle bunny(\"../models/bunny/bunny.obj\", white, Vector3f(300.f,0.f,300.f),Vector3f(2000.f, 2000.f, 2000.f));scene.Add(&amp;bunny); Diffuse Microfacet 看看bunny的臀部的话，还是能多少看出来一点Microfacet的小小震撼的23333参考文章 C++11 多线程（std::thread）详解_c++多线程_jcShan709的博客-CSDN博客 LearnOpenGL - Theory Games101：作业7（含提高部分）_games101作业7实现 microfacet模型_Q_pril的博客-CSDN博客 从零开始学图形学：写一个光线追踪渲染器（二）——微表面模型与代码实现 - 知乎 (zhihu.com) " }, { "title": "GAMES101-Lecture 15 Ray Tracing 3(Light Transport & Global Illumination)", "url": "/posts/GAMES101-Lecture-15-Ray-Tracing-3/", "categories": "Computer Graphics, GAMES101", "tags": "图形学, 学习笔记", "date": "2023-07-10 07:07:00 +0000", "snippet": "Radiometry（后半部分）Irradiance 单位面积上的能量，其中光的能量方向必须得与表面点垂直 单位面积指的是接受辐射的微小面积dA 对于之前的修正：Radiance 单位立体角、单位面积（projected unit area）上的光的能量，相当于单位面积上的Radiant Intensity，也相当于单位solid angle的Irradiance 单位面积指的是发...", "content": "Radiometry（后半部分）Irradiance 单位面积上的能量，其中光的能量方向必须得与表面点垂直 单位面积指的是接受辐射的微小面积dA 对于之前的修正：Radiance 单位立体角、单位面积（projected unit area）上的光的能量，相当于单位面积上的Radiant Intensity，也相当于单位solid angle的Irradiance 单位面积指的是发射辐射的微小面积dA 往solid angle方向辐射能量，$\\theta$指的是面的法线和solid angle的方向夹角Incident Radiance（入射） 单位立体角的Irradiance到达某个单位面积平面的能量 这里单位面积指的是光打到的平面，也就是接受辐射的微小面积dA Exiting Radiance 单位面积上的Radiant Intensity 这个跟上面的Radiance一样，单位面积也是接受辐射的微小面积dA，其实就是Radiance的另一种说法 Irradiance vs. Radiance 两者之间的差距就是方向性，irradiance接受的辐射是来自四面八方的，最后积分积一下，而Radiance接受的是来自单位角方向的辐射Light transportBidirectional Reflectance Distribution Function(BRDF双向反射分布函数) 为了解决，已知入射光能量和角度，射到物体表面会向各个方向辐射，辐射出去的能量和角度是不一样的，这个方法能求出给定方向的辐射的能量是多少，比如辐射到相机那里会有多少能量 也可以这么理解，一个表面把光线的能量吸收了，然后要再发出去 The reflection equation 下面这个公式是计算来自四面八方的入射光在Lr方向的能量贡献Chalenge：Recursive Equation 因为光线可能会弹射多次，因而一个着色点受到的光不一定只是来自光源，可能也来自其他物体，所以在计算的时候会是递归式的The rendering equation 渲染公式就是自发光+反射光 $H^2$和$\\Omega+$都是表示半球 虽然入射方向wi指向球心，但把w的方向都算成从球心（着色点）指向球外 把$\\cos\\theta$写成了$n\\cdot w_i$法线乘以radiance方向 一个点光源的简单情况： 多个点光源 面光源（积分一下） 其他物体反射 简写渲染方程，L是要算的东西，E是发光，K是反射操作符 然后推导，其中右边的L是(E+KL)，K算子具有泰勒展开的性质Global illumination 全局光照是直接和间接光照的集合 全局光照最终会收敛到一个亮度 " }, { "title": "GAMES101-Lecture 14 Ray Tracing 2(Acceleration & Radiometry) & 作业6", "url": "/posts/GAMES101-Lecture-14-Ray-Tracing-2-&-%E4%BD%9C%E4%B8%9A6/", "categories": "Computer Graphics, GAMES101", "tags": "图形学, 学习笔记", "date": "2023-07-07 06:32:00 +0000", "snippet": "Using AABBs to accelerate ray tracingUniform grids 主旨：多做光线与盒子求交 先把场景的BB框住，然后在BB里创建格子 记录每个有物体（表面）存在的格子(下图中右上角少画了一个格子) 判断跟光线相交的格子里有没有物体 如果有物体，那么说明光线可能和该物体相交，就计算交点 ...", "content": "Using AABBs to accelerate ray tracingUniform grids 主旨：多做光线与盒子求交 先把场景的BB框住，然后在BB里创建格子 记录每个有物体（表面）存在的格子(下图中右上角少画了一个格子) 判断跟光线相交的格子里有没有物体 如果有物体，那么说明光线可能和该物体相交，就计算交点 在光线的发射过程中（对于图中的光线），只需判断当前格子的上方和右方是否为光线下一个相交的格子 Grid Resolution 不能太稀疏（比如1*1*1的格子，相当于没做BBAA），也不能太密集，不然和格子也求交太多次，所以要有一个均衡 BBAA适合比较均匀的场景，不适合有大片空区域的场景，会产生“Teapot in a stadium”问题Spatial partitions(空间划分) 基于格子的不足之处进行优化，在物体分布稀疏的地方格子大一点，，分布密集的地方格子小一点 八叉树（Oct-Tree），对空间切三刀，然后如果某个小空间中物体比较多，继续切，直到空间内没物体或者物体数量差不多了，但维度再高的话，就是$2^n$叉树，这显然不好（我认为老师意思是说这么切下去还是切太多了），为解决这个问题，KD-Tree应运而生 KD-Tree：每次砍一刀，然后再根据情况在分出的一个空间内再砍一刀，这样就类似二叉树，每次水平一刀，竖直一刀，这样划分的相对均匀一点 BSP-Tree：不是横平竖直地砍，所以比较复杂 KD-Tree Pre-Processing 在做光追之前提前划分好，在中间节点记录它之后划分了什么样的格子，在叶子节点来实际存储和格子相交的物体（三角形） 首先，光线和整个BBAA*（A)有交点，那么对于子节点（也就是1和B）都判断是否有交点 都相交，但1也就到此为止，去计算1中所有物体是否与光线相交，然后去计算B的子节点2和C 还是都相交，但2也到此为止，去计算2中所有物体是否与光线相交，然后去计算C的子节点3和D 还是都相交，继续算 到4和5，其中5是没有交点的，所以就不计算了 有几个问题： 如何判断包围盒的格子到底和哪些三角形相交，这个问题比较困难处理 一个物体与多个包围盒相交，也就是多个叶子节点都要储存该物体 Object Partitions &amp; Bounding Volume Hierarchy(BVH) 解决了KD-Tree的两个问题，既不用求交，而且一个三角形不会与多个包围盒相交，只会存在一个包围盒中 但问题是包围盒有可能相交，怎么划分很讲究 怎样区分一个节点： 选择一个维度去划分（x、y、z轴） 总是沿着最长的轴去切 区分节点（切）的时候，从中间物体的位置切，快速找出中位数，使用快速选择算法，只需要O(n)的复杂度 如果是动态场景，就需要重新计算BVH了 BVH伪代码： Spatial VS Object Partitions 空间划分和物体划分的区别 空间： 划分了不重叠的空间区域 一个物体可能会被包含在多个空间中 物体： 物体被划分到不同的子集中 包围盒可能会重叠 Basic radiometry (辐射度量学)Motivation 为光赋予物理意义 定义了一些列的方法和单位来描述光照 准确计量光在空间中的各种属性 Radiant flux：光通量，单位时间内通过的光总量，单位watt或者lumen（lm） intensity：光强，单位立方角光通量，单位Watt/steradians，也就是candelas irradiance：辉度，单位面积光通量，瓦特/平方米 radiance：光亮度 Radiant Energy and Flux(Power) Radiant Energy：可以理解为光的能量，单位是焦耳 Radiant Flux(power)：单位时间的能量，单位是瓦特 Flux（另外一种解释）：光打到一个感光的平面，单位时间内通过的光子的数量 Important Light Measurements of Interest Radiant Intensity：光源散发的光 irradiance：一个平面接收的光 radiance：在传播中的光 Radiant Intensity 单位立体角的能量 二维中角度一般指弧度，单位是radians 三维中立体角：球上一块面积除以半径的平方，球有$4\\pi$的立体角，单位是steradians 单位立体角/微分立体角：微分面积/半径平方 之后会用单位立体角w来表示一个单位向量 Radiant Intensity就是单位立体角的能量作业6    在之前的编程练习中，我们实现了基础的光线追踪算法，具体而言是光线传输、光线与三角形求交。我们采用了这样的方法寻找光线与场景的交点：遍历场景中的所有物体，判断光线是否与它相交。在场景中的物体数量不大时，该做法可以取得良好的结果，但当物体数量增多、模型变得更加复杂，该做法将会变得非常低效。因此，我们需要加速结构来加速求交过程。在本次练习中，我们重点关注物体划分算法 Bounding Volume Hierarchy (BVH)。本练习要求你实现 Ray-BoundingVolume 求交与 BVH 查找。    首先，你需要从上一次编程练习中引用以下函数： Render() in Renderer.cpp: 将你的光线生成过程粘贴到此处，并且按照新框架更新相应调用的格式。 Triangle::getIntersection in Triangle.hpp: 将你的光线-三角形相交函数粘贴到此处，并且按照新框架更新相应相交信息的格式。     在本次编程练习中，你需要实现以下函数： IntersectP(const Ray&amp; ray, const Vector3f&amp; invDir,const std::array&lt;int, 3&gt;&amp; dirIsNeg) in the Bounds3.hpp: 这个函数的作用是判断包围盒 BoundingBox 与光线是否相交，你需要按照课程介绍的算法实现求交过程。 getIntersection(BVHBuildNode* node, const Ray ray)in BVH.cpp: 建立 BVH 之后，我们可以用它加速求交过程。该过程递归进行，你将在其中调用你实现的 Bounds3::IntersectP Render()函数 其实render函数已经写的差不多了，计算投射的光线已经算出来了，只需要再写一行代码调用函数即可，需要调用的是Scene类的castRay函数，与上一次作业不同，这次作业的形参做了修改，需要直接传入ray对象，至于深度depth，不用管，就是记录个射线的弹射次数，填0即可 framebuffer[m++] = scene.castRay(ray, 0);，加这行代码即可，完整代码如下： void Renderer::Render(const Scene&amp; scene){ std::vector&lt;Vector3f&gt; framebuffer(scene.width * scene.height); float scale = tan(deg2rad(scene.fov * 0.5)); float imageAspectRatio = scene.width / (float)scene.height; Vector3f eye_pos(-1, 5, 10); int m = 0; for (uint32_t j = 0; j &lt; scene.height; ++j) { for (uint32_t i = 0; i &lt; scene.width; ++i) { // generate primary ray direction float x = (2 * (i + 0.5) / (float)scene.width - 1) * imageAspectRatio * scale; float y = (1 - 2 * (j + 0.5) / (float)scene.height) * scale; // TODO: Find the x and y positions of the current pixel to get the // direction // vector that passes through it. // Also, don't forget to multiply both of them with the variable // *scale*, and x (horizontal) variable with the *imageAspectRatio* // Don't forget to normalize this direction! Vector3f dir = Vector3f(x, y, -1); // Don't forget to normalize this direction! dir = normalize(dir); Ray ray(eye_pos, dir); framebuffer[m++] = scene.castRay(ray, 0); } UpdateProgress(j / (float)scene.height); } UpdateProgress(1.f); // save framebuffer to file FILE* fp = fopen(\"binary.ppm\", \"wb\"); (void)fprintf(fp, \"P6\\n%d %d\\n255\\n\", scene.width, scene.height); for (auto i = 0; i &lt; scene.height * scene.width; ++i) { static unsigned char color[3]; color[0] = (unsigned char)(255 * clamp(0, 1, framebuffer[i].x)); color[1] = (unsigned char)(255 * clamp(0, 1, framebuffer[i].y)); color[2] = (unsigned char)(255 * clamp(0, 1, framebuffer[i].z)); fwrite(color, 1, 3, fp); } fclose(fp); }Triangle::getIntersection函数 这个部分说难吧也不难，说简单吧，倒也不好想，基本的算法已经是算完了，主要就是把算好的内容返回，那么返回的是一个Intersection对象，所以就需要了解下Intersection类，需要根据这个函数的计算结果来创建好要返回的Intersection对象，完整代码如下：inline Intersection Triangle::getIntersection(Ray ray){ Intersection inter; if (dotProduct(ray.direction, normal) &gt; 0) return inter; double u, v, t_tmp = 0; //下面的代码已经是Moller Trumbore Algorithm了 Vector3f pvec = crossProduct(ray.direction, e2);//该向量与三角形法线正交 double det = dotProduct(e1, pvec);//det 的几何意义是三角形两个边向量以及光线方向向量构成的三维矩阵的行列式。 if (fabs(det) &lt; EPSILON)//如果det接近0，说明两个边向量接近平行,从而导致三角形面积接近0,即三角形退化为线段或点 return inter; double det_inv = 1. / det; Vector3f tvec = ray.origin - v0; u = dotProduct(tvec, pvec) * det_inv; if (u &lt; 0 || u &gt; 1) return inter; Vector3f qvec = crossProduct(tvec, e1); v = dotProduct(ray.direction, qvec) * det_inv; if (v &lt; 0 || u + v &gt; 1) return inter; t_tmp = dotProduct(e2, qvec) * det_inv; // TODO find ray triangle intersection if (t_tmp &lt; 0) return inter; inter.happened = true;//是否相交 inter.coords = ray(t_tmp);//交点坐标 inter.normal = normal;//交点处三角形法线 inter.distance = t_tmp;//d inter.obj = this;//三角形 inter.m = m;//交点处三角形的材质 return inter;}IntersectP函数 其实这个就按课程上讲的过程来算就行了，算出光线进入时间和推出时间即可，我看有的博主使用vector相乘，规避了for循环，这点还是很不错的。有一个点让人比较费解，就是IntersectP函数的形参中有一个是const std::array&lt;int, 3&gt;&amp; dirIsNeg ，实际上我全程没用到这个函数。我的代码如下：inline bool Bounds3::IntersectP(const Ray&amp; ray, const Vector3f&amp; invDir, const std::array&lt;int, 3&gt;&amp; dirIsNeg) const{ // invDir: ray direction(x,y,z), invDir=(1.0/x,1.0/y,1.0/z), use this because Multiply is faster that Division // dirIsNeg: ray direction(x,y,z), dirIsNeg=[int(x&gt;0),int(y&gt;0),int(z&gt;0)], use this to simplify your logic // TODO test if ray bound intersects double t_enter, t_exit; double t_min[3]{}, t_max[3]{}; for (int i = 0; i &lt; 3; i++) { t_min[i] = std::min((pMin[i] - ray.origin[i]) * invDir[i], (pMax[i] - ray.origin[i]) * invDir[i]); t_max[i] = std::max((pMin[i] - ray.origin[i]) * invDir[i], (pMax[i] - ray.origin[i]) * invDir[i]); } t_enter = std::fmax(t_min[0], std::fmax(t_min[1],t_min[2])); t_exit = std::fmin(t_max[0], std::fmin(t_max[1], t_max[2])); if (t_enter &lt; t_exit &amp;&amp; t_exit &gt;= 0.0) return true; return false;}getIntersection函数 这个函数就照着课程ppt的伪码来做就行了，有几点让人费解，就是上面说的参数，有一个我就没用，还有就是光线方向的倒数，这个直接在ray对象那取出来就好，不用自己算，我一开始还在想怎么算，万一除以个0该怎么处理，实际上在ray的构造函数里就自己算了，而且就是简单的除以，没考虑除以0的情况，呃呃。代码如下：Intersection BVHAccel::getIntersection(BVHBuildNode* node, const Ray&amp; ray) const{ // TODO Traverse the BVH to find intersection Intersection inter; if (!node || !node-&gt;bounds.IntersectP(ray, ray.direction_inv, { 0,0,0 })) return inter; if (node-&gt;left == nullptr &amp;&amp; node-&gt;right == nullptr) { return node-&gt;object-&gt;getIntersection(ray); } Intersection inter1 = getIntersection(node -&gt; left, ray); Intersection inter2 = getIntersection(node-&gt;right, ray); return inter1.distance &lt; inter2.distance ? inter1 : inter2;}提高题：SAH 这个sah我搞了不少时间才弄懂，但就结果而言，提升并不是很高，具体过程我就不多赘述了，我挂两个我参考的链接，我在代码处有一些注释 BVH with SAH (Bounding Volume Hierarchy with Surface Area Heuristic) - lookof - 博客园 (cnblogs.com) (23条消息) 光线求交加速算法：边界体积层次结构(Bounding Volume Hierarchies)2-表面积启发式法(The Surface Area Heuristic)_0小龙虾0的博客-CSDN博客 BVHBuildNode* BVHAccel::recursiveBuild(std::vector&lt;Object*&gt; objects){ BVHBuildNode* node = new BVHBuildNode(); // Compute bounds of all primitives in BVH node Bounds3 bounds; for (int i = 0; i &lt; objects.size(); ++i) bounds = Union(bounds, objects[i]-&gt;getBounds()); if (objects.size() == 1) { // Create leaf _BVHBuildNode_ node-&gt;bounds = objects[0]-&gt;getBounds(); node-&gt;object = objects[0]; node-&gt;left = nullptr; node-&gt;right = nullptr; return node; } else if (objects.size() == 2) { node-&gt;left = recursiveBuild(std::vector{objects[0]}); node-&gt;right = recursiveBuild(std::vector{objects[1]}); node-&gt;bounds = Union(node-&gt;left-&gt;bounds, node-&gt;right-&gt;bounds); return node; } else { Bounds3 centroidBounds; for (int i = 0; i &lt; objects.size(); ++i) centroidBounds = Union(centroidBounds, objects[i]-&gt;getBounds().Centroid()); int dim = centroidBounds.maxExtent(); SplitMethod splitMethod = SplitMethod::NAIVE; switch (splitMethod) { case SplitMethod::SAH : { const int nBuckets = 12; const float SAHTravCost = 0.125f;//遍历花费的时间成本 //const float SAHInterCost = 1.f;//检查一个物体花费的时间成本,其实可以不算 BucketInfo buckets[nBuckets]; //遍历三角形，查看三角形的质心位于哪一个桶中 for (int i = 0; i &lt; objects.size(); i++) { //用来存当前图元也就是三角形质心位于几号桶中,dim是最松散的一个轴 int b = nBuckets * centroidBounds.Offset(objects[i]-&gt;getBounds().Centroid())[dim]; if (b == nBuckets) b = nBuckets - 1; buckets[b].count++; buckets[b].bounds = Union(buckets[b].bounds, objects[i]-&gt;getBounds()); } //下面计算最小成本 float cost[nBuckets - 1]{ 0.f }; //按i的序号，将桶分成两部分，所以不取最后一个桶 //因为如果左边取了最后一个桶，那么相当于右边没有桶了，这也是为啥cost数组长度为nBuckets - 1 for (int i = 0; i &lt; nBuckets - 1; i++) { Bounds3 b0, b1; int cnt0 = 0, cnt1 = 0; for (int j = 0; j &lt;= i; j++) { b0 = Union(b0, buckets[j].bounds); cnt0++; } for (int j = i + 1; j &lt;= nBuckets - 1; j++) { b1 = Union(b1, buckets[j].bounds); cnt1++; } cost[i] = SAHTravCost + (cnt0 * b0.SurfaceArea() + cnt1 * b1.SurfaceArea() ) / bounds.SurfaceArea(); } //找出最小时间成本的划分桶序号 //船新的找最小值下标方法，一行代码解决 int minCostSplitBucket = std::distance(cost, std::min_element(cost, cost + nBuckets - 1)); //下面是传统的找最小值方法 float minCost = cost[0]; for (int i = 1; i &lt; nBuckets - 1; i++) { if (cost[i] &lt; minCost) { minCost = cost[i]; minCostSplitBucket = i; } } float leafCost = objects.size();//直接将当前所有图元也就是三角形都检测一遍的时间成本 //如果当前图元数量大于一个节点允许的最大图元数量，那就需要按桶序号来划分两个区域 //或者使用区域划分的时间成本确实小于将当前图元不划分的时间成本，那也要划分 //但这个maxPrimsInNode设置为1.所以都会执行这段代码，甚至size为2的时候都轮不到执行这块代码 if (objects.size() &gt; maxPrimsInNode || minCost &lt; leafCost) { auto pmid = std::partition(objects.begin(), objects.end(), [=](Object* pi){ int b = nBuckets * centroidBounds.Offset(pi-&gt;getBounds().Centroid())[dim]; if (b == nBuckets) b = nBuckets - 1; return b &lt;= minCostSplitBucket; }); auto beginning = objects.begin(); auto ending = objects.end(); auto leftshapes = std::vector&lt;Object*&gt;(beginning, pmid); auto rightshapes = std::vector&lt;Object*&gt;(pmid, ending); assert(objects.size() == (leftshapes.size() + rightshapes.size())); node-&gt;left = recursiveBuild(leftshapes); node-&gt;right = recursiveBuild(rightshapes); node-&gt;bounds = Union(node-&gt;left-&gt;bounds, node-&gt;right-&gt;bounds); break; } //如果这个划分效果还不如直接算，那就不break，直接执行下面的的 //但是我的maxPrimsInNode设置的是1，所以无论如何都用sah，所以就先break下 break; } case SplitMethod::NAIVE : { switch (dim) { case 0: std::sort(objects.begin(), objects.end(), [](auto f1, auto f2) { return f1-&gt;getBounds().Centroid().x &lt; f2-&gt;getBounds().Centroid().x; }); break; case 1: std::sort(objects.begin(), objects.end(), [](auto f1, auto f2) { return f1-&gt;getBounds().Centroid().y &lt; f2-&gt;getBounds().Centroid().y; }); break; case 2: std::sort(objects.begin(), objects.end(), [](auto f1, auto f2) { return f1-&gt;getBounds().Centroid().z &lt; f2-&gt;getBounds().Centroid().z; }); break; } auto beginning = objects.begin(); auto middling = objects.begin() + (objects.size() / 2); auto ending = objects.end(); auto leftshapes = std::vector&lt;Object*&gt;(beginning, middling); auto rightshapes = std::vector&lt;Object*&gt;(middling, ending); assert(objects.size() == (leftshapes.size() + rightshapes.size())); node-&gt;left = recursiveBuild(leftshapes); node-&gt;right = recursiveBuild(rightshapes); node-&gt;bounds = Union(node-&gt;left-&gt;bounds, node-&gt;right-&gt;bounds); break; } } } return node;}" }, { "title": "GAMES101-Lecture 13 Ray Tracing 1(Whitted-Style Ray Tracing) & 作业5", "url": "/posts/GAMES101-Lecture-13-Ray-Tracing-1-&-%E4%BD%9C%E4%B8%9A5/", "categories": "Computer Graphics, GAMES101", "tags": "图形学, 学习笔记", "date": "2023-07-06 06:32:00 +0000", "snippet": "Why Ray Tracing 光栅化不能解决全局的效果 软阴影 Glossy reflection（光泽度反射）（打磨的比较光滑的金属，类似古代的铜镜） 间接光照 光追准确但很慢 光栅化：实时；光追：离线（一帧需要一万个...", "content": "Why Ray Tracing 光栅化不能解决全局的效果 软阴影 Glossy reflection（光泽度反射）（打磨的比较光滑的金属，类似古代的铜镜） 间接光照 光追准确但很慢 光栅化：实时；光追：离线（一帧需要一万个gpu小时） Basic Ray-Tracing AlgorithmLight Rays(假设的条件) 光线沿着直线传播 光线和光线不会发生碰撞 光线从光源发射最后弹到眼睛里，而且光路可逆 Ray Casting 通过从摄像机投射每一个像素来生成一张图 检查投射到的物体上的点，连接光源，判断是不是在阴影 其实这种效果和光栅化很相似，并没有弹射，只是不需要z-buffer了Recursive（Whitted-Style）Ray Tracing 可以进行多次弹射（反射、折射） 在每一个弹射的点都与光源连接，判断是不是在阴影，然后把不在阴影的颜色加起来 弹射的过程有能量损失，不然就过曝了 Ray-Surface IntersectionRay Equation 光线就是光源+一个方向向量 光线r在t时间从一个起点到一个方向的位置 Ray Intersection With Sphere(Implicit Surface) 点p是球上一点满足o+td，求t（二次函数） 需要满足实际意义，所以t得是正的，而且是个实数 相交时，要取更近的，取更小的t 按这个方法，隐式表面就很好算了Ray Intersection With Triangle Mesh(emplicit Surface) 可以判断一个点在物体内还是物体外，从点开始往任意一个方向发射一根射线，如果与物体的交点是奇数个，那么就说明在物体内（物体得是封闭的） 最普通的方法是遍历物体所有的三角形，来看看到底和哪个三角形相交了，找出最近的点，但速度会非常慢 那么如何计算和三角形的交点，分解成两个问题： 光线和平面求交（根据三角形的属性计算出三角形所在的平面） 找到交点后判断是否在三角形内 平面被定义为一个方向（法线）和一个点，满足下图公式的点p，就在平面上，平面就是一些列p点的集合 Moller Trumbore Algorithm 在上述式子中，右侧是使用重心坐标求得三角形p0p1p2平面的一个点，左侧是光线要交的点，只要通过式子求出t即可，那么点都是三维的，所以就是三个方程三个未知量（t、b1、b2） 解出b1、b2、1-b1-b2都是非负的，那就在三角形内 这样就可以直接求出光线是否和三角形有交点，但实际上本质还是先看是不是交在了三角形所在的平面上 Accelerating Ray-Surface IntersectionBouding Volumes(包围体积) 逻辑：如果光线和包围盒都不相交，那么更不可能和里面的物体相交 包围盒：三个对面形成的交集 长方体的每个轴沿着坐标轴，叫轴对齐包围盒 先把情况降维，算光线和二维的BB相交的情况 首先算和两条个平面的两个交点对应的tmin和tmax，再算出和两个y平面的交点所对应的tmin和tmax，然后求个交集，也就得到了光线穿过BB时的tmin和tmax 那么对于三维的BB来说，只有： 当光线进入三对面时才算进入了BB 当光线只要退出了一对面就算出了BB 先计算光线对于每一对面的$t_{min}$和$t_{max}$ $t_{enter} = max{t_{min}},t_{exit} = min{t_{max}}$ 如果$t_{enter}&lt;t_{exit}$，那么说明光线在这个BB里存在了一段时间，反之则没有穿过BB 如果$t_{exit}&lt;0$，说明盒子一定在光线的背后 如果$t_{exit}&gt;=0$且$t_{enter}&lt;0$，说明光线的起点在盒子中 总之，光线和AABB相交当且仅当$t_{enter}&lt;t_{exit} \\&amp;\\&amp; t_{exit}&gt;=0$ 为什么要axis-aligned呢 为了使计算相对容易 作业5 题目要求： 在这部分的课程中，我们将专注于使用光线追踪来渲染图像。在光线追踪中 最重要的操作之一就是找到光线与物体的交点。一旦找到光线与物体的交点，就 可以执行着色并返回像素颜色。在这次作业中，我们需要实现两个部分：光线的 生成和光线与三角的相交。本次代码框架的工作流程为： 从 main 函数开始。我们定义场景的参数，添加物体（球体或三角形）到场景 中，并设置其材质，然后将光源添加到场景中。 调用 Render(scene) 函数。在遍历所有像素的循环里，生成对应的光线并将 返回的颜色保存在帧缓冲区（framebuffer）中。在渲染过程结束后，帧缓冲 区中的信息将被保存为图像。 在生成像素对应的光线后，我们调用 CastRay 函数，该函数调用 trace 来 查询光线与场景中最近的对象的交点。 然后，我们在此交点执行着色。我们设置了三种不同的着色情况，并且已经 为你提供了代码。 你需要修改的函数是： Renderer.cpp 中的 Render()：这里你需要为每个像素生成一条对应的光 线，然后调用函数 castRay() 来得到颜色，最后将颜色存储在帧缓冲区的相 应像素中。 Triangle.hpp 中的 rayTriangleIntersect(): v0, v1, v2 是三角形的三个 顶点，orig 是光线的起点，dir 是光线单位化的方向向量。tnear, u, v 是你需 要使用我们课上推导的 Moller-Trumbore 算法来更新的参数。 第一，是第一个生成光线，这个需要找到每个像素的世界坐标，而这个过程是从像素坐标-&gt;NDC坐标-&gt;Screen坐标-&gt;世界坐标，在课程中并没有详细地讲，但其实在光栅化的时候说过。可是我还是不清楚，所以参考了博客光线追踪：生成相机光线 (scratchapixel.com) 只需要在Render函数的注释下面算出dir的x和y即可 for (int j = 0; j &lt; scene.height; ++j) { for (int i = 0; i &lt; scene.width; ++i) { // generate primary ray direction float x; float y; // TODO: Find the x and y positions of the current pixel to get the direction // vector that passes through it. // Also, don't forget to multiply both of them with the variable *scale*, and // x (horizontal) variable with the *imageAspectRatio* //这个地方的细节在课程中并没有提及，所以还是得查 //目标是将屏幕上的像素转换为世界坐标中 //首先先将像素转换到NDC空间中 x = ((float)i + 0.5f) / scene.width; y = ((float)j + 0.5f) / scene.height; //再将x，y转换到screen空间中 x = 2 * x - 1.f; y = -(2 * y - 1.f);//y轴方向向下，所以取个负值 //然后现在的坐标是在正方形中的坐标，要根据宽高比拉伸一下 x *= imageAspectRatio; //最后是计算在世界坐标系中的像素坐标,其实应该乘以相机到平面的距离，但是默认都是1，所以不用乘 x *= scale; y *= scale; Vector3f dir = Vector3f(x, y, -1); // Don't forget to normalize this direction! dir = normalize(dir); framebuffer[m++] = castRay(eye_pos, dir, scene, 0); } UpdateProgress(j / (float)scene.height); } 此时，生成的图片是有两个球体的： 第二，也就是通过Moller-Trumbore 算法来计算值，这个在课程有讲，所以直接套公式就行，其中算出来的t就是函数中的形参tnear，b1就是函数中的形参u，b2是函数中的形参vbool rayTriangleIntersect(const Vector3f&amp; v0, const Vector3f&amp; v1, const Vector3f&amp; v2, const Vector3f&amp; orig, const Vector3f&amp; dir, float&amp; tnear, float&amp; u, float&amp; v){ // TODO: Implement this function that tests whether the triangle // that's specified bt v0, v1 and v2 intersects with the ray (whose // origin is *orig* and direction is *dir*) // Also don't forget to update tnear, u and v. Vector3f e1 = v1 - v0; Vector3f e2 = v2 - v0; Vector3f s = orig - v0; Vector3f s1 = crossProduct(dir, e2); Vector3f s2 = crossProduct(s, e1); tnear = (1 / dotProduct(s1, e1)) * dotProduct(s2, e2); u = (1 / dotProduct(s1, e1)) * dotProduct(s1, s); v = (1 / dotProduct(s1, e1)) * dotProduct(s2, dir); if (u &gt; 0 &amp;&amp; v &gt; 0 &amp;&amp; u + v &lt; 1 &amp;&amp; tnear &gt; 0) { return true; } return false;} 在做的时候，我把更新tnear、u、v放在了检测出射线和三角形相交的代码块中，导致图片中地面的颜色是黑色的，实际上每次都应该更新，因为这个光线（也就是primary ray）没有打到三角形（也就是平面）的话，应该是有颜色的，如果不更新uv，就无法正常计算颜色了" }, { "title": "GAMES101-Lecture 12 Geometry 3", "url": "/posts/GAMES101-Lecture-12-Geometry-3/", "categories": "Computer Graphics, GAMES101", "tags": "图形学, 学习笔记", "date": "2023-07-04 06:20:00 +0000", "snippet": "SurfacesSubdivision,simplification,regularization 此处承接上一节课 Mesh subdivision Mesh simplification Mesh regularizationSubdivisionLoop Subdivision（因为发明这个算法的人叫loop，而不是循环的意思） 三角形数量增多 调整三角...", "content": "SurfacesSubdivision,simplification,regularization 此处承接上一节课 Mesh subdivision Mesh simplification Mesh regularizationSubdivisionLoop Subdivision（因为发明这个算法的人叫loop，而不是循环的意思） 三角形数量增多 调整三角形顶点的位置，先区分新老顶点，然后使用不同的规则进行改变 对于新点，公式如下，以白色点为例子，根据贡献加权 对于老点，也是以下下面的图中的白色点为例子，算n(是一个点的度数即连接了几条边)和u，对于老点，不仅要考虑周围点的贡献还要考虑自身的贡献 Catmull-Clark Subdivision 奇异点：度数不等于4的顶点 在Catmull-Clark细分一次后，所有的非四边形面都会变成一个奇异点，且不再有非四边形面 再多次细分后，也不会有新的奇异点了，因为一次细分后就不再有非四边形面了 点的更新方式分三种，新的面上的点，新的边上的点，老的点 loop细分只能分三角形面，但Catmull-Clark细分可以细分四边形Mesh SimplificationEdge collapsing 边坍缩 相当去删掉一条边变成一个点，那么问题就是删掉什么边 此时引入一个概念就是二次误差度量Error Metrics：新生成的点到与之关联的所有面的距离平方和的最小值，与之关联就是原来那条边的两点关联的所有面，下图中所有面都是相关联的 所以边坍缩就是去计算每条边的二次误差度量，排序，然后按顺序坍缩 但是会出现很多问题，首先是一条边坍缩后，相关联的很多边都会变化，所以需要一种数据结构，既能找到最小值又能动态修改每条边的二次误差度量值，也就是优先队列或者说是堆 Shadow Mapping 在做阴影计算的时候是不需要知道场景的几何信息的 会产生走样现象 关键：非阴影点必须能够被光源（点光源）和摄像机看到 这种阴影也叫硬阴影 第一，储存光源能看到的点的深度值(其实这就生成了shadow map) 第二，从摄像机看到点，把该点投影到光源光栅化的那个平面的位置，去检测该位置储存的深度值（上一条储存的深度值）和该点本身的深度值（即该点到光源的距离）是否一致，如果一致，说明这个点，光源能看到，摄像机也能看到；如果不一致，说明，摄像机能看到，而光源看不到，那么这个点就是阴影点 但存在很多问题，第一，深度值是个浮点数，而浮点数的相等是很难的，所以就会出现下面这张图的问题（其中绿色是非阴影点，黑色和灰色是阴影点，颜色应该是光源视角平面上存的深度值），所以会设置一个很小的数值（scale、bias、tolerance），但是只能治标不治本 还有问题就是分辨率的问题，shadow map的分辨率和最后渲染的分辨率的问题就会产生走样（低分辨率、不同分辨率都会走样） 但是依旧是应用广泛的一种方法 软阴影就是因为有本影、半影的存在才会存在，如果有软阴影，那么说明光源有大小 " }, { "title": "GAMES101-Lecture 11 Geometry 2(Curves and Surface) & 作业4", "url": "/posts/GAMES101-Lecture-11-Geometry-2-&-%E4%BD%9C%E4%B8%9A4/", "categories": "Computer Graphics, GAMES101", "tags": "图形学, 学习笔记", "date": "2023-06-30 09:00:00 +0000", "snippet": "Explicit Representations Point Cloud点云 好表达 大数据集很有用 经常用于转换成多边形mesh 难以在采样不足的区域进行绘制 Polygon Mesh ...", "content": "Explicit Representations Point Cloud点云 好表达 大数据集很有用 经常用于转换成多边形mesh 难以在采样不足的区域进行绘制 Polygon Mesh 储存顶点和多边形 方便处理、模拟、适合采样 数据结构更复杂 几乎最常见的显式表示 wavefront object v是顶点坐标 vt是纹理坐标 vn是法线 f是点的连接关系 CurvesBezier curves 定义 起始点在p0，终点在p1 且起始点处的切线方向为p0p1，终点处的切线方向为p2p3 De Casteljau’s algorithm 这个算法需要至少三个控制点 需要不断的取t[0,1]来采样，连接成一条曲线 比如t = 1/3时，取b01点使得b0b01占b0b1的1/3，取b11点使得b1b11占b1b2的1/3，然后在b01b11取点b02使得b01b02占b01b11的1/3 那么在t = 1/3时，曲线过点b02 以此类推 三次贝塞尔曲线，需要四个点，操作跟上面的类似 公式就是不断地插值，递归 n是曲线的degree，如果有3个控制点，那n就是2，B是伯恩斯坦多项式 在三维空间中依然适用 贝塞尔曲线的性质： 起始点和终点确定 起始点和终点切线方向确定 仿射变换的结果一样（对控制点先变换再画线和先画线再对线上的控制点变换），但对投影不一样 凸包性质：曲线一定在控制点形成的凸包内 Piecewise Bezier Curves 多段贝塞尔 最常用的是三次贝塞尔曲线（4个控制点） 当一个终点控制点（连接两条曲线）相邻两个控制点在一条直线上且距离该终点距离相同，那么这两条曲线实现了平滑的连接 如果在一条直线上但距离该终点距离不相同，那么不算平滑连接。比如一个蚂蚁爬到终点时会突然加速 C0连续：第一段的终点和第二段的终点重合 C1连续：第一段的终点和第二段的终点重合，且第一段的an-1点和第二段的b1点在一条直线上，且距离重合点距离相等（相当于第一段的终点和第二段的终点的一阶导数相等） C2连续：C1的基础上，二阶导数再相等 B-splines（basis splines） B样条不需要分段就具有局部操控性（动一个点不会整条曲线都改变） 极其复杂 非均匀有理B样条（NURBS）更复杂 SurfacesBezier surfaces 首先，现在有16个点，每行4个，先根据每行的4个点画出四条曲线，然后根据t，在四条线上一共会找到四个点，再根据这四个点来绘制列的曲线 uv上的任何一个点都可以映射到曲面上，uv可以理解成t1和t2 所以贝塞尔曲线是显式表示，因为它可以被映射而来 Subdivision,simplification,regularization作业4 作业描述： Bézier 曲线是一种用于计算机图形学的参数曲线。在本次作业中，你需要实 现 de Casteljau 算法来绘制由 4 个控制点表示的 Bézier 曲线 (当你正确实现该 算法时，你可以支持绘制由更多点来控制的 Bézier 曲线)。 你需要修改的函数在提供的 main.cpp 文件中。 bezier：该函数实现绘制 Bézier 曲线的功能。它使用一个控制点序列和一个OpenCV：：Mat 对象作为输入，没有返回值。它会使 t 在 0 到 1 的范围内进行迭代，并在每次迭代中使 t 增加一个微小值。对于每个需要计算的 t，将调用另一个函数 recursive_bezier，然后该函数将返回在 Bézier 曲线上 t处的点。最后，将返回的点绘制在 OpenCV ：：Mat 对象上。 recursive_bezier：该函数使用一个控制点序列和一个浮点数 t 作为输入，实现 de Casteljau 算法来返回 Bézier 曲线上对应点的坐标。 这次的作业非常简单，就是平滑得写一小会儿 递归就是按ppt的思路递归，没啥好说的 cv::Point2f recursive_bezier(const std::vector&lt;cv::Point2f&gt; &amp;control_points, float t) { // TODO: Implement de Casteljau's algorithm if (control_points.size() == 1) { return control_points[0]; } std::vector&lt;cv::Point2f&gt; new_points; for (int i = 0; i &lt; control_points.size()-1; i++) { float x = t * control_points[i].x + (1 - t) * control_points[i + 1].x; float y = t * control_points[i].y + (1 - t) * control_points[i + 1].y; new_points.emplace_back(x,y); } return recursive_bezier(new_points, t);} 然后仿照naive_bezier函数画点即可 void bezier(const std::vector&lt;cv::Point2f&gt; &amp;control_points, cv::Mat &amp;window) { // TODO: Iterate through all t = 0 to t = 1 with small steps, and call de Casteljau's // recursive Bezier algorithm. for (float t = 0.0; t &lt;= 1.0; t += 0.001) { auto point = recursive_bezier(control_points, t); window.at&lt;cv::Vec3b&gt;(point.y, point.x)[1] = 255; } }} 平滑的话，就是先跟上次作业中的双线性插值一样，判断要平滑的是哪四块像素，然后计算点到四个像素中心的距离d1、d2、d3、d4，根据比例来赋颜色值 void bezier(const std::vector&lt;cv::Point2f&gt; &amp;control_points, cv::Mat &amp;window) { // TODO: Iterate through all t = 0 to t = 1 with small steps, and call de Casteljau's // recursive Bezier algorithm. for (float t = 0.0; t &lt;= 1.0; t += 0.001) { auto point = recursive_bezier(control_points, t); window.at&lt;cv::Vec3b&gt;(point.y, point.x)[1] = 255; bool smooth = false; if (smooth) { float d1, d2, d3, d4; int x = point.x; int y = point.y; d1 = dis(point.x, point.y, (float)x + 0.5f, (float)y + 0.5f); int xx, yy; if (point.x - (float)x - 0.5f &gt; 0.f) { xx = x + 1; } else { xx = x - 1; } d2 = dis(point.x, point.y, (float)xx + 0.5f, (float)y + 0.5f); setColor(xx, y, 255.f * d1 / d2, window); if (point.y - (float)y - 0.5f &gt; 0.f) { yy = y + 1; } else yy = y - 1; d3 = dis(point.x, point.y, (float)x + 0.5f, (float)yy + 0.5f); setColor(x, yy, 255.f * d1 / d3, window); d4 = dis(point.x, point.y, (float)xx + 0.5f, (float)yy + 0.5f); setColor(x, yy, 255.f * d1 / d4, window); } }} 其中，为了方便创建了两个函数 float dis(float x1, float y1, float x2, float y2){ return sqrt( pow(x2 - x1, 2) + pow(y2 - y1, 2));}void setColor(int x, int y, float c, cv::Mat&amp; window){ if (x &lt; 0) x = 0; if (x &gt; window.cols) x = window.cols - 1; if (y &lt; 0) y = 0; if (y &gt; window.rows) y = window.rows - 1; window.at&lt;cv::Vec3b&gt;(y, x)[1] = std::max(c, (float)window.at&lt;cv::Vec3b&gt;(y, x)[1]);} " }, { "title": "GAMES101-Lecture 10 Geometry 1 & 作业3", "url": "/posts/GAMES101-Lecture-10-Geometry-1-&-%E4%BD%9C%E4%B8%9A3/", "categories": "Computer Graphics, GAMES101", "tags": "图形学, 学习笔记", "date": "2023-06-27 09:00:00 +0000", "snippet": "Applications of Textures In modern GPUs, texture = memory + range query (filtering) Environment Map环境贴图 Spherical Map、Cube Map Bump Mapping 定义的是纹理上任意一个点，高度的相对移动 通过凹凸贴图（也可以说是高度...", "content": "Applications of Textures In modern GPUs, texture = memory + range query (filtering) Environment Map环境贴图 Spherical Map、Cube Map Bump Mapping 定义的是纹理上任意一个点，高度的相对移动 通过凹凸贴图（也可以说是高度贴图），改变了原来的点的高度（实际没改，只是用来算法线），从而改变了法线的方向，制造了凹凸的效果 对平面来说：该点的切线方向是(1,dp)，dp就是凹凸贴图存的值，那么该点的法线方向就是转90°，也就是(-dp,1) 在三维空间中，假设一个法向量(0,0,1)，根据凹凸图某一点uv的梯度值来计算出扰乱后的切线，最后旋转就成了扰乱后的法线也就是(-dp/du,-dp/dv,1)，因为假设的法向量(0,0,1)在local坐标系（局部坐标系stn），所以之后还需要转换Displacement mapping 3d生成噪声作为贴图 环境光遮罩贴图 体渲染Geometryimplicit隐式几何 点满足一些特殊的关系，比如一个球的方程，并不给实际的点 难点在于哪些点符合这个关系，很难从式子看出来是什么模型。但是，给定一个点，判断这个点在不在这个面上，很容易。直接把点代入式子，如果是0在面上，大于0在外，小于0在内explicit显式几何 要么直接给出，要么通过参数映射的方式给出 把所有uv找一遍就知道在三维空间中长什么样，所以采样更简单；但是判断某个点是否在平面的里外，很难 CSG(constructive solid geometry)(implicit) 通过基本的几何的组合来构造几何Distance Functions(implicit) 距离函数是指空间中任意一个点到一个模型的最短距离，如果这个点在模型的面外就是正的，如果在面内，就是负的 A是一个物体挡住窗口1/3时候的一张图，B是该物体挡住窗口的2/3时候的一张图，现在的目标是求出这两个状态中间状态的样子 如果拿两张图做一个线性blend(相加除以二)，那么左边黑，中间灰，右边白 但是我们希望的结果是运动的中间态也就是左边一半是黑的，右边一半是白的 SDF是signed distance function。对A和B计算距离函数也就是变换成SDF(A)和SDF(B)，再通过距离函数来blend，这样的话结果中间就会是0，最后再恢复 Level Set Methods水平集方法（类似距离函数） Fractals分形(自相似)(递归)作业3 作业描述：     在这次编程任务中，我们会进一步模拟现代图形技术。我们在代码中添加了 Object Loader(用于加载三维模型), Vertex Shader 与 Fragment Shader，并且支持 了纹理映射。     而在本次实验中，你需要完成的任务是: 修改函数 rasterize_triangle(const Triangle&amp; t) in rasterizer.cpp: 在此 处实现与作业 2 类似的插值算法，实现法向量、颜色、纹理颜色的插值。 修改函数 get_projection_matrix() in main.cpp: 将你自己在之前的实验中 实现的投影矩阵填到此处，此时你可以运行 ./Rasterizer output.png normal 来观察法向量实现结果。 修改函数 phong_fragment_shader() in main.cpp: 实现 Blinn-Phong 模型计 算 Fragment Color. 修改函数 texture_fragment_shader() in main.cpp: 在实现 Blinn-Phong 的基础上，将纹理颜色视为公式中的 kd，实现 Texture Shading Fragment Shader. 修改函数 bump_fragment_shader() in main.cpp: 在实现 Blinn-Phong 的 基础上，仔细阅读该函数中的注释，实现 Bump mapping. 修改函数 displacement_fragment_shader() in main.cpp: 在实现 Bump mapping 的基础上，实现 displacement mapping 上来报错namespace “std” has no member “optional”，这是因为optional是C++17新特性，我的vs默认是C++14，在项目属性-&gt;常规中修改标准版本为C++17即可 源代码部分： 第一，实现插值，首先是跟作业二很相似的框架，先判断bonding box，然后遍历里面的像素，需要注意的是insideTriangle函数已经写好了，直接传三角形的顶点数组就行了，不需要再算出来三角形的边了，我刚开始传进去的是三角形的三条边，但这样是不对的，源码写的很迷，我看不明白，gpt的意思是cross坐了相减的功能，我觉得蛮离谱的，反正要是我写，肯定不这么写，读起来有歧义 还有就是，c++有实现插值函数，不用自己写循环，麻了 void rst::rasterizer::rasterize_triangle(const Triangle&amp; t, const std::array&lt;Eigen::Vector3f, 3&gt;&amp; view_pos) { auto v = t.toVector4(); //先找到三角形的边界box，即找到左下角和右上角，以此为区间遍历 int left = std::min(std::min(v[0][0], v[1][0]), v[2][0]); int bottom = std::min(std::min(v[0][1], v[1][1]), v[2][1]); int right = std::max(std::max(v[0][0], v[1][0]), v[2][0]); int top = std::max(std::max(v[0][1], v[1][1]), v[2][1]); for (float x = left; x &lt;= right; x++) { for (float y = bottom; y &lt;= top; y++) { //这里是直接传t.v if (insideTriangle(x+0.5,y+0.5,t.v)) { //插值 float alpha, beta, gamma; //插值算深度（虽然我不太清楚为啥这么算） std::tie(alpha, beta, gamma) = computeBarycentric2D(x + 0.5, y + 0.5, t.v); float Z = 1.0 / (alpha / t.v[0].w() + beta / t.v[1].w() + gamma / t.v[2].w()); float zp = alpha * t.v[0].z() / t.v[0].w() + beta * t.v[1].z() / t.v[1].w() + gamma * t.v[2].z() / t.v[2].w(); zp *= Z; if (zp &lt; depth_buf[get_index(x, y)]) { depth_buf[get_index(x, y)] = zp; //插值算颜色、法向量、纹理坐标和着色坐标（其实是视空间坐标） //我本来以为一直报错是因为我的变量不是const类型，看来是我之前的判断错误了 Vector3f interpolated_color; for (int i = 0; i &lt; 3; i++) { interpolated_color[i] = alpha * t.color[0][i] + beta * t.color[1][i] + gamma * t.color[2][i]; } Vector3f interpolated_normal; for (int i = 0; i &lt; 3; i++) { interpolated_normal[i] = alpha * t.normal[0][i] + beta * t.normal[1][i] + gamma * t.normal[2][i]; } interpolated_normal = interpolated_normal.normalized();//法向量归一化 auto interpolated_texcoords = interpolate(alpha, beta, gamma, t.tex_coords[0], t.tex_coords[1], t.tex_coords[2], 1.0); //计算视空间插值view_pos的插值 Vector3f interpolated_shadingcoords; for (int i = 0; i &lt; 3; i++) { interpolated_shadingcoords[i] = alpha * view_pos[0][i] + beta * view_pos[1][i] + gamma * view_pos[2][i]; }//着色坐标（其实应该是视空间坐标） fragment_shader_payload payload(interpolated_color, interpolated_normal,interpolated_texcoords, texture ? &amp;*texture : nullptr); payload.view_pos = interpolated_shadingcoords; Vector2i point(x, y); Vector3f pixel_color = fragment_shader(payload); //原来问题出在这个set_pixel上，传入的参数与形参类型不一样 set_pixel(point, pixel_color); } } } }} 第二，投影矩阵，这个矩阵不能像上一次直接取负号了，会把模型显示反过来所以要小改一下，我的建议是直接用现成的，别想着怎么回事了，每个厂商的坐标系啊什么的都不一样，反正清楚流程就行了，不用在这种厂商问题纠结Eigen::Matrix4f get_projection_matrix(float eye_fov, float aspect_ratio, float zNear, float zFar){ // TODO: Use the same projection matrix from the previous assignments //aspect_ratio = r / t; //tan(eye_fov)/2 = t/|n|; /*zNear = -zNear; zFar = -zFar;*/ Eigen::Matrix4f projection = Eigen::Matrix4f::Identity(); float t = tan(eye_fov / 2 / 180.f * MY_PI) * (-zNear); float b = -t; float r = aspect_ratio * t; float l = -r; Eigen::Matrix4f m1 = Eigen::Matrix4f::Identity();//缩放矩阵 Eigen::Matrix4f m2 = Eigen::Matrix4f::Identity();//平移矩阵 m1(0, 0) = 2.f / (r - l); m1(1, 1) = 2.f / (t - b); m1(2, 2) = 2.f / (zNear - zFar); m2(0, 3) = -(r + l) / 2.f; m2(1, 3) = -(t + b) / 2.f; m2(2, 3) = -(zNear + zFar) / 2.f; Eigen::Matrix4f Mortho = m1 * m2;//正交矩阵 //平截头体压缩至长方体矩阵 Eigen::Matrix4f Mpersp2ortho; Mpersp2ortho &lt;&lt; zNear, 0.f, 0.f, 0.f, 0.f, zNear, 0.f, 0.f, 0.f, 0.f, zNear + zFar, -zNear * zFar, 0.f, 0.f, 1.f, 0.f; projection = Mortho * Mpersp2ortho; return projection;} 第三，此时使用normal_fragment_shader可以看看效果，但需要注意的是，运行时可能会报错，也就是在执行getColor函数的时候，运行到 auto color = image_data.at&lt;cv::Vec3b&gt;(v_img, u_img);这行代码，会报数组越界的错，所以要修改下这个函数，岂可休！浪费我好多时间，改成：（参考GAMES101-作业1、作业2、作业3的解题和框架分析 - 知乎 (zhihu.com)的作业3讲解，有说这个问题） Eigen::Vector3f getColor(float u, float v) { int u_img = static_cast&lt;int&gt;(u * width); int v_img = static_cast&lt;int&gt;((1 - v) * height); if (u_img &lt; 0) u_img = 0; if (u_img &gt;= width) u_img = width - 1; if (v_img &lt; 0) v_img = 0; if (v_img &gt;= height) u_img = height - 1; auto color = image_data.at&lt;cv::Vec3b&gt;(v_img, u_img); return Eigen::Vector3f(color[0], color[1], color[2]); } 实现phong_fragment_shader()。这里需要注意的有一点，就是环境光的光强要用amb_light_intensity，如果用light.intensity就会全白Eigen::Vector3f phong_fragment_shader(const fragment_shader_payload&amp; payload){ Eigen::Vector3f ka = Eigen::Vector3f(0.005, 0.005, 0.005); Eigen::Vector3f kd = payload.color; Eigen::Vector3f ks = Eigen::Vector3f(0.7937, 0.7937, 0.7937); auto l1 = light{ {20, 20, 20} , {500, 500, 500} } ; auto l2 = light{ {-20, 20, 0} , {500, 500, 500} } ; std::vector&lt;light&gt; lights = {l1, l2}; Eigen::Vector3f amb_light_intensity{10, 10, 10}; Eigen::Vector3f eye_pos{0, 0, 10}; float p = 150; Eigen::Vector3f color = payload.color; Eigen::Vector3f point = payload.view_pos;//片元在view空间下的坐标 Eigen::Vector3f normal = payload.normal;// 表面法线 Eigen::Vector3f result_color = {0, 0, 0}; for (auto&amp; light : lights) { Eigen::Vector3f l = light.position - point;//光照方向同时也是光源到着色点的偏移向量 Eigen::Vector3f v = eye_pos - point;//注视方向 float r = l.squaredNorm();//计算光源到着色点的距离 l = l.normalized(); v = v.normalized(); Eigen::Vector3f h = v + l; h = h.normalized(); // TODO: For each light source in the code, calculate what the *ambient*, *diffuse*, and *specular* // components are. Then, accumulate that result on the *result_color* object. Eigen::Vector3f ambient; Eigen::Vector3f diffuse; Eigen::Vector3f specular; for (int i = 0; i &lt; 3; i++) { ambient[i] = ka[i] * amb_light_intensity[i]; diffuse[i] = kd[i] * (light.intensity[i] / r) * std::max(0.f, normal.dot(l)) ; specular[i] = ks[i] * (light.intensity[i] / r) * pow(std::max(0.f, normal.dot(h)),p);//先不做p的次方 result_color[i] += (ambient[i] + diffuse[i] + specular[i]); } } return result_color * 255.f;} 第四，实现texture_fragment_shader()。只需要让颜色值是return_color就行了，别的跟phong都一样 Eigen::Vector3f return_color = {0, 0, 0}; if (payload.texture) { // TODO: Get the texture value at the texture coordinates of the current fragment return_color = payload.texture-&gt;getColor(payload.tex_coords.x(), payload.tex_coords.y()); } 第五，实现bump_fragment_shader()。在gpt的帮助下，弄懂了bump mapping，目标就是修改法向量，根据凹凸贴图来计算在(u,v)位置下的梯度，公式在框架中给出了，其中h函数的意思就是求height，那么height是怎么来的呢。首先，凹凸贴图其实存的是三通道rgb值，只需要求出这个三维向量的绝对值也就是长度，那么就是高度。其中tbn矩阵是一个局部坐标系（其实这么说也不太准确），通过这个矩阵可以将计算出来的在局部坐标系下的法线转换成世界坐标系下。还有一点是，颜色直接取凹凸图就好Eigen::Vector3f bump_fragment_shader(const fragment_shader_payload&amp; payload){ Eigen::Vector3f ka = Eigen::Vector3f(0.005, 0.005, 0.005); Eigen::Vector3f kd = payload.color; Eigen::Vector3f ks = Eigen::Vector3f(0.7937, 0.7937, 0.7937); auto l1 = light{ {20, 20, 20} , {500, 500, 500} } ; auto l2 = light{ {-20, 20, 0} , {500, 500, 500} } ; std::vector&lt;light&gt; lights = {l1, l2}; Eigen::Vector3f amb_light_intensity{10, 10, 10}; Eigen::Vector3f eye_pos{0, 0, 10}; float p = 150; Eigen::Vector3f color = payload.color; Eigen::Vector3f point = payload.view_pos; Eigen::Vector3f normal = payload.normal; float kh = 0.2, kn = 0.1; float u = payload.tex_coords[0], v = payload.tex_coords[1]; float width,height; if (payload.texture) { width = payload.texture-&gt;width; height = payload.texture-&gt;height; } auto n = normal; Vector3f t(n.x() * n.y() / sqrt(n.x() * n.x() + n.z() * n.z()), sqrt(n.x() * n.x() + n.z() * n.z()), n.z() * n.y() / sqrt(n.x() * n.x() + n.z() * n.z())); auto b = n.cross(t); Eigen::Matrix3f TBN; TBN.col(0) = t; TBN.col(1) = b; TBN.col(2) = n; auto dU = kh * kn * (payload.texture-&gt;getColor(u + 1.f / width, v).norm() - payload.texture-&gt;getColor(u, v).norm()); auto dV = kh * kn * (payload.texture-&gt;getColor(u , v + 1.f/height).norm() - payload.texture-&gt;getColor(u, v).norm()); Eigen::Vector3f ln(-dU, -dV, 1.f); n = (TBN * ln).normalized(); Eigen::Vector3f result_color = { 0, 0, 0 }; result_color = n; return result_color * 255.f;} 第六，实现displacement_fragment_shader()。实现了凹凸映射，那位移映射也就简单了，直接把点修改下就好，最后再加个phong着色就行Eigen::Vector3f displacement_fragment_shader(const fragment_shader_payload&amp; payload){ Eigen::Vector3f ka = Eigen::Vector3f(0.005, 0.005, 0.005); Eigen::Vector3f kd = payload.color; Eigen::Vector3f ks = Eigen::Vector3f(0.7937, 0.7937, 0.7937); auto l1 = light{ {20, 20, 20} , {500, 500, 500} } ; auto l2 = light{ {-20, 20, 0} , {500, 500, 500} } ; std::vector&lt;light&gt; lights = {l1, l2}; Eigen::Vector3f amb_light_intensity{10, 10, 10}; Eigen::Vector3f eye_pos{0, 0, 10}; float p = 150; Eigen::Vector3f color = payload.color; Eigen::Vector3f point = payload.view_pos; Eigen::Vector3f normal = payload.normal; float kh = 0.2, kn = 0.1; //储存该片元在纹理上的uv坐标 float u = payload.tex_coords[0], v = payload.tex_coords[1], w = payload.texture-&gt;width, h = payload.texture-&gt;height; float x = normal.x(), y = normal.y(), z = normal.z(); //计算t向量tangent Vector3f t(x * y / sqrt(x * x + z * z), sqrt(x * x + z * z), z * y / sqrt(x * x + z * z)); auto b = normal.cross(t);//b向量binormal Eigen::Matrix3f TBN; TBN.col(0) = t; TBN.col(1) = b; TBN.col(2) = normal; //计算在凹凸贴图上uv的梯度 auto dU = kh * kn * (payload.texture-&gt;getColor(u + 1 / w, v).norm() - payload.texture-&gt;getColor(u, v).norm()); auto dV = kh * kn * (payload.texture-&gt;getColor(u, v + 1 / h).norm() - payload.texture-&gt;getColor(u, v).norm()); //根据梯度计算出的在tbn坐标系下的法线方向 Eigen::Vector3f ln(-dU, -dV, 1.f); point += (kn * normal * payload.texture-&gt;getColor(u, v).norm()); normal = (TBN * ln).normalized(); Eigen::Vector3f result_color = {0, 0, 0}; for (auto&amp; light : lights) { // TODO: For each light source in the code, calculate what the *ambient*, *diffuse*, and *specular* // components are. Then, accumulate that result on the *result_color* object. Eigen::Vector3f l = light.position - point;//光照方向同时也是光源到着色点的偏移向量 Eigen::Vector3f v = eye_pos - point;//注视方向 float r = l.squaredNorm();//计算光源到着色点的距离 l = l.normalized(); v = v.normalized(); Eigen::Vector3f h = v + l; h = h.normalized(); Eigen::Vector3f ambient = ka.cwiseProduct(amb_light_intensity); Eigen::Vector3f diffuse = kd.cwiseProduct(light.intensity /r)* std::max(0.f, normal.dot(l)); Eigen::Vector3f specular = ks.cwiseProduct(light.intensity/r) * pow(std::max(0.f, normal.dot(h)), 100); result_color += (ambient + diffuse + specular); } return result_color * 255.f;} 第七，双线性插值。为了实现我的思路，我还重载了getColor()函数。先说双线性插值，我是根据那个点所在的位置来取离它最近的三个点，也就是说这个原本的点可能在四个点的左下角、右下角、左上角、右上角。因为我需要算出是哪四个像素，也就是拿到了四个像素的下标，但是原来的getColor()函数是传入浮点型并且小于1的uv，所以我就重载了形参为int的getColor()函数 Eigen::Vector3f getColorBilinear(float u, float v) { int u_img = static_cast&lt;int&gt;(u * width); int v_img = static_cast&lt;int&gt;((1 - v) * height); //去找周围的点坐标 int x, y; Eigen::Vector3f color[4]; color[0] = getColor(u_img, v_img); float s = (u * (float)width - ((float)u_img + 0.5)); if (s &gt; 0) { //x = u + 1.f / width &gt;= 1.f ? 1.f : u + 1.f / width; x = u_img + 1 &gt;= width ? width - 1 : u_img + 1; } else { x = u_img - 1 &lt; 0 ? 0 : u_img - 1; //x = u - 1.f / width &lt; 0.f ? 0.f : u - 1.f / width; } color[1] = getColor(x, v_img); auto c1 = lerp(s, color[0], color[1]);//水平方向相邻两个颜色的插值结果 float t = (1 - v) * (float)height - ((float)v_img + 0.5); if (t &gt; 0) { y = v_img + 1 &gt;= height ? height - 1 : v_img + 1; //y = v + 1.f / height &gt;= 1.0f ? 1.0f : v + 1.f / height; } else { y = v_img - 1 &lt; 0 ? 0 : v_img - 1; //y = v - 1.f / height &lt; 0.f ? 0.f : v - 1.f / height; } color[2]= getColor(u_img, y); color[3] = getColor(x, y); auto c2 = lerp(t, color[2], color[3]);//水平方向相邻两个颜色的插值结果(原像素下面一行或者上面一行的结果) return lerp(t, c1, c2); }}; 重载的getColor()函数： Eigen::Vector3f getColor(int u, int v) { if (u &lt; 0) u = 0; if (u &gt;= width) u = width - 1; if (v &lt; 0) v = 0; if (v &gt;= height) u = height - 1; auto color = image_data.at&lt;cv::Vec3b&gt;(v, u); return Eigen::Vector3f(color[0], color[1], color[2]); } lerp()函数。为什么取绝对值，这事因为，我把t的绝对值当成四个当中一个像素对最终颜色的贡献大小，如果t是0.2，说明真实的坐标，距离原本的那个像素c1（不考虑双线性插值的像素）更近所以贡献更大所以是0.8c1，距离相邻的那个像素c2是0.8，距离更远，所以贡献更小，所以是0.2c2 Eigen::Vector3f lerp(float t, Eigen::Vector3f c1, Eigen::Vector3f c2) { return (c1 + (c2 - c1) * abs(t)); }" }, { "title": "力扣-剑指offer错题集", "url": "/posts/%E5%8A%9B%E6%89%A3-%E5%89%91%E6%8C%87offer%E9%94%99%E9%A2%98%E9%9B%86/", "categories": "算法刷题, 力扣", "tags": "剑指offer", "date": "2023-06-24 03:46:00 +0000", "snippet": "数学类型剑指 Offer 44. 数字序列中某一位的数字class Solution {public: int findNthDigit(int n) { if(n==0)return 0; long long count = 9, start = 1; int digit = 1; while(n&gt;count) ...", "content": "数学类型剑指 Offer 44. 数字序列中某一位的数字class Solution {public: int findNthDigit(int n) { if(n==0)return 0; long long count = 9, start = 1; int digit = 1; while(n&gt;count) { n-=count; digit++; start *= 10; count = 9 * start * digit; } long long num = start + (n-1)/digit; int pos = (n-1)%digit; string s = to_string(num); return s[pos]-'0'; }};    这道题目算是数学中的找规律，比较难搞的是边界问题，还有就是变量类型需要时long。其中count指的是第几位，start是每一个数量级开始的数字，digit是在该数量级数字的位数剑指 Offer 56 - I. 数组中数字出现的次数vector&lt;int&gt; singleNumbers(vector&lt;int&gt;&amp; nums) { int abXOR = 0; for(auto &amp;i : nums) { abXOR ^= i; } int diffOne = 1; while((diffOne &amp; abXOR) == 0) { diffOne&lt;&lt;=1; } int a = 0,b = 0; for(auto &amp;i: nums) { if(diffOne &amp; i) { a ^= i; } else b ^= i; } return vector&lt;int&gt;{a,b}; }    我觉得这算计算机类型了都。其实这道题适合看题解，不过提一嘴异或，就是如果所有的数字异或一遍，哪些一样的数字就会消失，最终的结果就是那两个不一样的数的异或，其实很好证明，异或满足交换律。那么剩下的难点就是如何把ab分到两组而且还能脱颖而出了    还有一点需要注意的是一个数左移是diffOne = diffOne&lt;&lt;1,我一开始只是左移了，忘记写等号了，就产生了超时，那么为什么会产生超时呢，我不说，让未来复习的我想一下排序类型剑指 Offer 45. 把数组排成最小的数class Solution { static bool compare(int a, int b){ string sa = to_string(a); string sb = to_string(b); return sa + sb &lt; sb+sa;}public: string minNumber(vector&lt;int&gt;&amp; nums) { sort(nums.begin(),nums.end(),compare); string ret; for(auto num:nums) { ret += to_string(num); } return ret; }};    这道题就是个排序，就比两个数作为字符串相加，看谁在前边小，谁就排在前面去，sort()真好用动态规划类型剑指 Offer 46. 把数字翻译成字符串class Solution {public: int translateNum(int num) { string s = to_string(num); int p = 0, q = 1, r = 1;//r是当前下标的翻译种类数量 for(int i = 1; i &lt; s.size(); i++) { p = q; q = r; r = 0; if(s.substr(i-1,2)&gt;= \"10\" &amp;&amp; s.substr(i-1,2)&lt;=\"25\") { r = p + q; }else r = q; } return r; }};    简单的dp，真没啥说的，看题目就明白了，但当时就是没想到这个法子剑指 Offer 49. 丑数class Solution {public: int nthUglyNumber(int n) { int dp[1691]; int p2 = 1, p3 = 1, p5 = 1; dp[1] = 1; for(int i = 2; i &lt;= n; i ++) { dp[i] =min(min(dp[p2]*2,dp[p3]*3),dp[p5]*5); if(dp[i] == dp[p2]*2)p2++; if(dp[i] == dp[p3]*3)p3++; if(dp[i] == dp[p5]*5)p5++; } return dp[n]; }};    第一次做的时候想到了丑数是由2、3、5相互组合相乘得到的，但是没往dp上想，甚至用了素数表，但超时了。使用三个指针+dp就行了，后面的丑数都是由前面的丑数乘以2、3、5得到的，还有需要注意的一点是去重，代码很清楚，不多说数据结构剑指 Offer 59 - II. 队列的最大值class MaxQueue {public: deque&lt;int&gt; d; queue&lt;int&gt; q; MaxQueue() { } int max_value() { if(d.empty()) return -1; return d.front(); } void push_back(int value) { q.push(value); while(!d.empty() &amp;&amp; d.back() &lt; value) { d.pop_back(); } d.push_back(value); } int pop_front() { if(q.empty()) return -1; int ret = q.front(); q.pop(); if(ret == d.front()) { d.pop_front(); } return ret; }};/** * Your MaxQueue object will be instantiated and called as such: * MaxQueue* obj = new MaxQueue(); * int param_1 = obj-&gt;max_value(); * obj-&gt;push_back(value); * int param_3 = obj-&gt;pop_front(); */    这道题难点在于双端队列取最大值，就是再push的时候判断，因为push时，当前值位于队列的最后一个，那么如果队列前面的值比当前值小，就说明在pop到当前值之前，调用max得到的结果都不会是前面那些比当前值小的数，所以呢，在双端队列里遇到比当前值小的删除就行。这么下来，双端队列的第一位永远也是最大的一位。剑指 Offer 60. n个骰子的点数class Solution {public: vector&lt;double&gt; dicesProbability(int n) { vector&lt;double&gt; dp(6,1.0/6.0); for(int i = 2; i &lt;= n; i ++) { vector&lt;double&gt; tmp(5 * i + 1, 0.0); for(int m = 0; m &lt; dp.size(); m++) { for(int k = 0; k &lt; 6; k++) { tmp[m + k] += dp[m] / 6.0; } } dp = tmp; } return dp; }};    这道题给我cpu干懵了，首先我把它当成找规律做，浪费了大票的时间。其次，得知它需要用dp做后，又开始搞二维数组，因为下标关系紊乱，又浪费了大票时间，所以看答案，使用滚动数组最简单方便了，麻了，关键的是要找对状态转移方程" }, { "title": "游戏设计模式笔记", "url": "/posts/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/", "categories": "设计模式", "tags": "学习笔记, 游戏设计模式", "date": "2023-05-11 19:16:00 +0000", "snippet": "书籍链接：游戏编程模式 (tkchu.me)重访设计模式 命令模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开 例子：按键输入、撤销重做 享元模式：运用共享技术来有效地支持大量细粒度对象的复用 这个模式通过将对象的数据分为两种来解决这个问题。 第一种数据没有特定指明是哪个对象的实例，因此...", "content": "书籍链接：游戏编程模式 (tkchu.me)重访设计模式 命令模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开 例子：按键输入、撤销重做 享元模式：运用共享技术来有效地支持大量细粒度对象的复用 这个模式通过将对象的数据分为两种来解决这个问题。 第一种数据没有特定指明是哪个对象的实例，因此可以在它们间分享。 Gof称之为固有状态，也有人视为“上下文无关”部分。数据的剩余部分是变化状态，那些每个实例独一无二的东西。这种模式通过在每个对象出现时共享一份固有状态来节约内存 例子：使用同一个模型进行实例渲染 观察者模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为 现代的解决办法是让“观察者”只是对方法或者函数的引用。 在函数作为第一公民的语言中，特别是那些有闭包的， 这种实现观察者的方式更为普遍 明日观察者：数据绑定 例子：成就系统 原型模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。 给我的感觉是简化类的继承，直接把一个对象（或者说类）作为原型，而不是专门写一个抽象类来作为基本类，然后再继承一大堆出去，这样相当于省了两波，一波是省了重复属性或者方法的代码（可以直接委托到原型那里），第二波是省了创建基类和派生类的代码（用js语言比较好理解） 例子：javascript的原型 单例模式：保证一个类只有一个实例，并且提供了访问该实例的全局访问点，其拓展是有限多例模式。 给我的理解就是，单例模式其实就是一个全局的静态类对象，优点就是保证只有一个存在（并且在初次请求时创建并初始化），而且方便访问，问题也是由于方便访问，在不想访问的地方有可能出现问题 例子：文件操作系统封装类（不能同时写和删除） 状态模式：允许一个对象在其内部状态发生改变时改变其行为的能力 使用状态模式来使容易混淆的繁琐的ifelse代码整理得更清晰，更好改动 例子：有限状态机、并发状态机、分层状态机、下推状态机，animation blueprint 序列模式 双缓冲模式：当信息从缓冲区中读取，它总是读取当前的缓冲区。 当信息需要写到缓存，它总是在下一缓冲区上操作。 给我的理解就是，因为读取的信息是宏观上的一种最终状态（如渲染完成的画面或者处理完相互作用的实体们），所以如果在渲染到一半或者相互作用到一半就读取就会出现可见的错误（画面撕裂）或者行为不正确，因此需要先在一个缓冲区中将这个状态结果算好，再通过交换的形式来一次性显示 例子：图形学中的双缓冲 游戏循环：一个游戏循环在游玩中不断运行。 每一次循环，它无阻塞地处理玩家输入，更新游戏状态，渲染游戏。 它追踪时间的消耗并控制游戏的速度。 有很多种方式的游戏循环，有固定时间步长的，有动态时间步长的，二者各有优劣，但我感觉目前游戏引擎中（如unity和ue）使用动态时间步长的游戏循环居多。 例子：游戏引擎中的游戏循环 更新方法：通过每次处理一帧的行为模拟一系列独立对象。 给我的理解就是每一帧要update每个实体的行为，至于是如何实现这个功能，在哪个类实现，有多种选择，实体类、组件类或者委托类 例子：Unity引擎中的MonoBehaviour 行为模式 字节码：将行为编码为虚拟机器上的指令，赋予其数据的灵活性。 为了防止硬编码带来的长时间编译，将一些修改与调整以字节码的方式来进行。简单来说就是做一套工具（沙箱），来对游戏内容进行修改而不需要经过漫长的重新编译。比如使用栈式虚拟机，将字节码指令通过栈来存储调用 例子：定义基于文本的语言、图形化创作工具 子类沙箱：用一系列由基类提供的操作定义子类中的行为。 我的理解就是为了避免子类的耦合，把多种子类可能使用的功能写在基类的protect里面供子类调用，把耦合给基类负责。甚至如果沙箱方法太多，可以将多个方法集成到另外一个类中，这样只需要创建一个另外类的成员变量。为了优化还可以写一个静态的初始化函数来给成员赋值 例子：超能力系统类 " }, { "title": "C++ Primer Plus-第14章 C++中的代码重用", "url": "/posts/C++-Primer-Plus-%E7%AC%AC14%E7%AB%A0-C++%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8/", "categories": "C++, C++ Primer Plus", "tags": "学习笔记", "date": "2022-11-22 07:32:00 +0000", "snippet": "    最近有点偷懒了，而且发现了一个挺严重的问题，就是之前看过的内容有点不记得了，所以单单是啃书，效果不是特别好，还是得结合实际的项目来，所以之后的笔记可能不会记得太详细了，以后的书籍阅读可能也就是以读和查阅为主，也许不会再系统详细的记录长篇大论了… 代码重用方法： 公有继承 本身是另一个类的对象的类成员：称...", "content": "    最近有点偷懒了，而且发现了一个挺严重的问题，就是之前看过的内容有点不记得了，所以单单是啃书，效果不是特别好，还是得结合实际的项目来，所以之后的笔记可能不会记得太详细了，以后的书籍阅读可能也就是以读和查阅为主，也许不会再系统详细的记录长篇大论了… 代码重用方法： 公有继承 本身是另一个类的对象的类成员：称为包含(containment)、组合(composition)、层次化(layering) 私有或保护继承 14.1 包含对象成员的类 公有继承，类可以继承接口，可能还有实现，获得接口是is-a关系的组成部分 使用组合（其他类对象作为本类成员），类可以获得实现，但不能获得接口，不继承接口是has-a关系的组成部分 复习：使用explicit关键字可以关闭隐式转换 //防止//student s;//s = 5;引发的隐式转换explicit Student(int n):name{\"Nully\"}, scross(n){} C++和约束：C++包含让程序员能够限制程序结构的特性——使用explicit防止单参数构造函数的隐式转换，使用const限制方法修改数据，这样做的根本原因：在编译阶段出现错误优于在运行阶段出现错误 初始化顺序：当初始化列表包含多个项目时，项目的初始化顺序为它们被声明的顺序，而不是在初始化列表中的顺序 如果代码使用一个成员的值作为另一个成员的初始化表达式的一部分时，初始化顺序就非常重要 14.2 私有继承 使用私有继承，基类的公有成员和保护成员都将称为派生类的私有成员——这意味着基类方法将不会称为派生对象公有接口的一部分，但可以在派生类的成员函数中使用它们 包含将对象作为一个命名的成员对象添加到类中，而私有继承将对象作为一个未被命名的继承对象添加到类中。我们用术语子对象(subobject)来表示通过继承或包含添加的对象 使用多个基类的继承被称为多重继承(multiple inheritance, MI) 对于继承类，初始化将使用类名而不是成员名来标识构造函数（ArrayDb是std::valarray&lt;double&gt;的别名 Student(const char * str, const double * pd, int n):std::string(str), ArrayDb(pd, n){} 使用包含时将使用对象名来调用方法，而使用私有继承时将使用类名和作用域解析运算符来调用方法 double Student::Average() const{ if(ArrayDb::size() &gt; 0) return ArrayDb::sum()/ArrayDb::size(); else return 0;} 访问私有继承基类的对象：使用强制类型转换，由于Student是从string继承来的，那么强制转换为string结果就是继承而来的string对象，接着使用this指针即可 const string &amp; Student::Name() const{ return (const string &amp;) *this;} 访问基类的友元函数：同样是使用强制类型转换，使用派生类友元来访问基类友元 ostream &amp; operator&lt;&lt;(ostream &amp; os, const Student &amp; stu){ os&lt;&lt;(const String &amp;)stu;} 那么使用包含还是私有继承呢？大部分选择包含 包含易于理解 继承更抽象，容易出现问题，比如包含同名方法的独立的基类或共享祖先的独立基类 包含能包括多个同类子对象，继承只能有一个 使用私有继承的场景： 私有继承可以访问基类的保护成员，但包含就不行 需要重新定义虚函数时 保护继承：基类的公有成员和保护乘员都将称为派生类的保护成员 和私有继承的区别在于第三代派生类，私有继承第三代派生类不能使用基类的接口，因为二代全给私有了，但保护继承的第三代类依然可以使用基类的公有、保护接口，因为第二代只是变保护 使用保护和私有派生时，重新定义访问权限可以使得基类方法可以在派生类外使用 在派生类建一个公有方法直接调基类的方法（保护、公有的） 使用公有部分的using声明指出派生类可以使用特定的基类成员 class Student : private std::valarray&lt;double&gt;{ public: using std::valarray&lt;double&gt;::min;} 14.3 多重继承 私有MI（多重继承）和保护MI可以表示has-a关系 MI带来的两个重要的问题： 从两个不同的基类继承同名方法 从两个或多个相关基类那里继承同一个类的多个实例 从两个或多个相关基类那里继承同一个类的多个实例：使得基类指针指向派生类对象中基类对象地址时出现二义性 使用虚基类(virtual base class)来解决上面这个问题 虚基类使得从多个类（它们的基类相同）派生出的对象只继承一个基类对象 在继承时使用关键字virtual class Singer:virtual public Worker{}class Waiter:public virtual Worker{} 如此一来，继承于singer和waiter的新派生类就只包含worker对象的一个副本了 为什么用“虚” 虚函数和虚基类无明显关系，只是反对引入新关键字，所以这有点像关键字重载 为什么不抛弃将基类声明为虚的方式，而使虚行为称为MI的准则呢 在一些情况下，需要基类的多个拷贝 虚基类要求完成额外的计算 虚基类操作麻烦 使用虚基类时，需要对类构造函数采用新方法，为了避免在构造函数的参数列表自动传递信息（即调用基类构造函数）时，通过多条途径传递的冲突 如果不希望默认构造函数（当有多条路径时会选择默认）来构造虚基类对象，需要显式地调用所需基类构造函数： SingerWaiter(const Worker &amp; wk, int p = 0, int v = Singer::other): Worker(wk),waiter(wk,p),singer(wk,v){} 调用哪个方法 在多继承中，如果每个直接祖先都有一个同名函数，如show()，就会出现二义性 可以使用作用域解析运算符 更好的方法是在派生类中重新定义函数，指出要使用哪个版本的函数 void singingWaiter::show(){ singer::show();} 在多次这样调用会出现问题，要么模块化（拆的细一点），要么设置为protected，详情见p559 当虚基类和非虚基类混合使用 该类将包含一个表示所有虚途径的基类子对象和分别表示各条非虚途径的多个基类子对象 如果某个名称优先于(dominates)其他所有名称，则使用它时，即便不适用限定符也不会导致二义性 派生类中的名称优先于直接或间接祖先类中的相同名称 14.4 类模板 定义类模板：使用模板定义替换类（如Stack）声明，使用模板函数替换类的成员函数 模板类使用template &lt;class Type&gt;或template &lt;typename Type&gt;开头 以相同的方法让模板成员函数替换原有类方法 template &lt;class Type&gt;class stack{ public: stack(); bool isempty();};template &lt;class Type&gt;stack&lt;type&gt;::stack(){ ...}template &lt;class Type&gt;bool stack&lt;Type&gt;::isempty(){ ...} 模板的具体实现被称为实例化(instantiation)或具体化(specialization) 不能将模板成员函数放在独立的实现文件中 泛型标识符——例如Type——称为类型参数，它们类似于变量，只能是类型赋给它们 可以讲内置类型或类对象用作模板的类型，指针也可以 一种允许指定数组大小的简单数组模板 tmplate&lt;class T, int n&gt;class arrayTp{private: T ar[n];public: explicit arratTp(const T &amp; v);};template&lt;class T, int n&gt;arrayTp&lt;T,n&gt;::arayTp(const T &amp; v){ ...} 可以递归使用模板：arrayTp&lt;arrayTp&lt;int, 5&gt;, 10&gt; twodee 可以使用多个类型参数：template &lt;class T1, class T2&gt; 模板具体化：有隐式实例显式实例化和显式具体化，统称为具体化(specialization)，详情见p582 成员模板：模板可用作结构、类或模板类的成员 模板类的友元，详情见p588 非模板友元 约束（bound）模板友元，即友元的类型取决于类被实例化时的类型 非约束（unbound）模板友元，即友元的所有具体化都是类的每一个具体化友元 模板别名（C++11） typedef std::array&lt;double, 12&gt; arrd;arrd gallons; C++11允许使用模板提供一系列别名 template&lt;typename T&gt; using arrtype = std::array&lt;T, 12&gt;; C++允许讲语法using＝用于非模板，此时与typedef等价 typedef const char * pc1;using pc2 = const char *; " }, { "title": "C++ Primer Plus-第13章 类继承", "url": "/posts/C++-Primer-Plus-%E7%AC%AC13%E7%AB%A0-%E7%B1%BB%E7%BB%A7%E6%89%BF/", "categories": "C++, C++ Primer Plus", "tags": "学习笔记", "date": "2022-11-14 09:52:00 +0000", "snippet": "    这章陆续看了三天，总算是对类继承有个差不多的概念了，之前一直稀里糊涂的QAQ13.1 一个简单的基类 通过继承可以完成的工作： 可以在已有类的基础上添加新的功能 可以给类添加数据 可以修改类方法的行为 派生类对象包含基类对象 ...", "content": "    这章陆续看了三天，总算是对类继承有个差不多的概念了，之前一直稀里糊涂的QAQ13.1 一个简单的基类 通过继承可以完成的工作： 可以在已有类的基础上添加新的功能 可以给类添加数据 可以修改类方法的行为 派生类对象包含基类对象 使用公有派生： 基类的公有成员将成为派生类的公有成员 基类的私有部分也将成为派生类的一部分，但只能通过公有和保护方法访问 派生类对象具有以下特征： 派生类对象存储了基类的数据成员（派生类继承了基类的实现） 派生类对象可以使用基类的方法（派生类继承了基类的接口） 需要在继承特性中添加： 派生类需要自己的构造函数 构造函数必须给新成员（如果有）和继承的成员提供数据（如果基类构造函数需要参数，那么派生类的形参就要提供（除非要使用默认构造函数就不提供）） 派生类可以根据需要添加额外的数据成员和成员函数 派生类不能直接访问基类的私有成员，必须通过基类的公有方法进行访问 有关派生类构造函数的要点： 首先创建基类对象（即先调用基类构造函数再调用派生类构造函数） 派生类构造函数应通过成员初始化列表将基类信息传递给基类构造函数 派生类构造函数应初始化派生类新增的数据成员 基类指针可以在不进行显式类型转换的情况下指向派生类对象；基类引用可以在不进行显式类型转换的情况下引用派生类对象 然而基类指针和引用只能调用基类方法，不能调用派生类方法 不可以将基类对象的地址赋给派生类引用和指针 13.2 继承：is-a关系 公有继承建立了一种is-a关系，即派生类对象也是一个基类对象，可以对基类对象执行的任何操作，也可以对派生类对象执行 公有继承不建立has-a关系，例如午餐可能包括水果，但通常午餐不是水果，所以最容易的建模方式是将fruit对象作为lunch类的数据成员 公有继承不建立is-like-a关系，即不采用明喻，律师像鲨鱼，但不是鲨鱼，不能在水下生活 公有继承不建立is-implemented-as-a（作为……来实现），例如，可以使用数组实现栈名单从array类派生出stack类是不合适的 公有继承不建立uses-a关系，例如，计算机可以使用激光打印机，但从computer类派生出printer类（或者反过来）是没有意义的 13.3 多态公有继承 方法的行为取决于调用该方法的对象，这种复杂的行为称为多态——具有多种形态 有两种重要机制可用于实现多态公有继承： 在派生类中重新定义基类方法 使用虚方法 使用virtual虚方法（如virtual void viewacct() const;）：如果方法是通过引用或指针而不是对象调用的，它将确定使用哪一种方法。如果没有使用关键字virtual，程序将根据引用类型或指针类型选择方法；如果使用了virtual，程序将根据引用或指针指向的对象的类型来选择方法 方法在基类中被声明为虚的后，它在派生类中将自动成为虚方法。然而，在派生类中使用关键字virtual来指出哪些函数是虚函数也不失为一个好办法 如果在派生类中重新定义基类的方法，通常应将基类方法声明为虚的。这样，程序将根据对象类型而不是引用或指针的类型来选择方法版本。为基类声明一个虚析构函数也是一种惯例 注意：关键字virtual只用于类声明的方法原型中 在派生类方法中，标准技术是使用作用域解析运算符来调用基类方法，如果没有使用作用域解析运算符，那么将会递归下去…… void BrassPlus::ViewAcct() const{ Brass::ViewAcct(); ...} 虚析构函数作用： 当有new的对象时，需要delete，此时就需要虚析构函数了 如果虚构函数不是虚的，那么就将调用对应于指针类型的析构函数（比如基类指针指向了一个派生类对象），这样就delete错了；如果时虚函数，那么将调用对应对象的析构函数 因此，使用虚析构函数可以确保正确的析构函数被调用 13.4 静态联编和动态联编 程序调用函数时，将使用哪个可执行代码呢？（因为有函数重载的情况）编译器将代码中的函数调用解释为执行特定的函数代码块被称为函数名联编(binding)，C/C++编译器可以在编译过程完成这种联编 在编译过程中进行联编被称为静态联编 (static binding)，又称为早期联编(early binding) 像虚函数这样不能再编译时确定，因为编译器不知道用户将选择哪种类型的对象，所以编译器必须生成能够在程序运行时选择正确的虚方法的代码，这被称为动态联编(dynamic binding)，又称为晚期联编(late binding) 将派生类引用或指针转换为基类引用或指针被称为向上强制转换(upcasting)，这使得公有继承不需要进行显式类型转换，并且向上强制转换是可传递的 相反的过程，将基类指针或引用转换为派生类的，称为向下强制转换(downcasting)，必须使用显式类型转换 动态联编实例：对象类型为BrassPlus，但只有在运行时程序才能确定对象的类型，所以编译器生成的代码将在程序执行时，根据对象类型将ViewAcct()关联到Brass::ViewAcct()或BrassPlus::ViewAcct() 为什么有两种联编以及为什么默认为静态联编： 效率原因，程序要在运行阶段采取决策就需要采取方法跟踪基类指针或引用指向的对象类型，增加了开销，因此静态联编效率更高 C++的指导原则之一是不要为不使用的特性付出代价（内存或时间） 概念模型原因，设计类时，派生类不变的不设置虚函数，既提高了效率也指出不要重新定义该函数 虚函数工作原理： 给每个对象添加一个隐藏成员 隐藏成员中保存了一个指向虚函数地址数组的指针，数组称为虚函数表(virtual function table, vtbl) 在使用虚函数时，在内存和执行速度方面有一定的成本： 每个对象都将增大，增大量为存储地址的空间 对于每个类，编译器都创建一个虚函数地址表 对于每个函数调用，都需要执行一项额外的操作，即到表中查找地址 虽然非虚函数效率更高，但不具备动态联编功能 虚构函数应当是虚函数，除非类不用做基类 通常应该给基类提供一个虚析构函数，即使它并不需要析构函数 友元不能是虚函数，因为友元不是类成员 如果派生类没有重新定义函数，将使用该函数的基类版本；如果派生类位于派生链中，则将使用最新的虚函数版本 重新定义产生问题：比如基类的虚函数与派生类的同名函数参数不同，虚函数的重新定义不会生成函数的两个重载版本，而是隐藏了基类版本；因此，如果重新定义继承的方法，应确保与原来的原型完全相同，但如果返回类型是基类引用或指针，则可以修改为指向派生类的引用或指针（这种例外是新出现的），这种特性被称为返回类型协变(covariance of return type) 如果基类被重载了，则应该在派生类中重新定义所有的基类版本；如果只定义一个版本，那么另外的版本会被隐藏，派生类对象将无法使用它们；当然，如果不修改，可以直接调用基类版本：void Hovel::show() const{Dewelling::show();} class Dwelling{ public: virtual void show(int a) const; virtual void show() const;};```cppclass Hovel : public Dwelling{ public: virtual void show(int a) const; virtual void show() const;} 13.5 访问控制：protected 关键字protected和private相似，在类外只能用公有类成员（比如公有成员函数）来访问protected的类成员 派生类的成员可以直接访问基类的保护成员，但不能直接访问私有成员 最好对数据成员采用私有访问控制，不要使用保护访问控制；同时通过基类方法使派生类能够访问基类数据 对于成员函数来说，保护访问控制很有用，它让派生类能够访问公众不能使用的内部函数 13.6 抽象基类 当类声明中包含纯虚函数时，则不能创建该类的对象（理念：包含纯虚函数的类之用作基类）; 纯虚函数(pure virtual fuction)提供未实现的函数，纯虚函数声明的结尾处为0，在原型中使用=0指出类是一个抽象基类，在类中可以不定义该函数 virtual double Area() const = 0; 总之，ABC(抽象基类)描述的是至少使用一个纯虚函数的接口，从ABC派生出的类将根据派生类的具体特征，使用常规虚函数来实现这种接口 可以将ABC看作是一种必须实施的接口，ABC要求具体派生类覆盖其纯虚函数——迫使派生类遵循ABC设置的接口规则 13.7 继承和动态内存分配 如果基类使用了new而派生类没有使用new 那么派生类没必要定义新的显式构造函数、复制构造函数、析构函数，统统默认就行，因为默认就都用基类的了 如果基类使用了new而派生类也使用new 必须为派生类定义显式析构函数、复制构造函数和赋值运算符 使用强制类型转换在派生类的函数中使用基类的友元函数 std::ostream:: operator&lt;&lt;(std::ostream os, const hasDMA &amp; hs){ os&lt;&lt;(const baseDMA) hs; os&lt;&lt;\"hasDMA\";} 13.8 类设计回顾 复习下特殊成员函数——默认构造函数、复制构造函数、赋值运算符 复习下其他类方法——构造函数、析构函数、转换、按值传递对象和传递引用、返回对象和返回引用、使用const 公有继承的相关考虑因素 is-a关系 为什么不能继承（比如构造函数，因为要必须执行派生类构造函数（执行过程自动先执行基类构造（无论是显式调用还是隐式调用默认的））） 赋值运算符 私有成员、保护成员 虚方法 析构函数 友元函数 有关基类方法的说明总结： 派生类对象自动使用继承而来的方法，如果派生类没有重新定义该方法 派生类的构造函数自动调用基类的构造函数 派生类的构造函数自动调用基类的默认构造函数，如果没有在成员初始化列表中指定其他构造函数 派生类的构造函数显式地调用成员初始化列表中指定的基类构造函数 派生类方法可以使用作用域解析运算符来调用共有的和受保护的基类方法 派生类的友元函数可以通过强制类型转换，将派生类引用或指针转换为基类引用或指针，然后用该引用或指针来调用基类的友元函数 成员函数属性： " }, { "title": "C++ Primer Plus-第12章 动态内存和类", "url": "/posts/C++-Primer-Plus-%E7%AC%AC12%E7%AB%A0-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%92%8C%E7%B1%BB/", "categories": "C++, C++ Primer Plus", "tags": "学习笔记", "date": "2022-11-10 14:27:00 +0000", "snippet": "12.1 动态内存和类 不能在类声明中初始化静态成员变量，这是因为声明描述了如何分配内存，但并不分配内存； 初始化在方法文件中，而不是在类声明文件中进行，因为类声明文件位于头文件中，程序可能将头文件包括在其他几个文件中，如果 在头文件初始化，将出现多个初始化副本，引发错误； 当然，也有例外：静态成员为整型或枚举型const 特殊...", "content": "12.1 动态内存和类 不能在类声明中初始化静态成员变量，这是因为声明描述了如何分配内存，但并不分配内存； 初始化在方法文件中，而不是在类声明文件中进行，因为类声明文件位于头文件中，程序可能将头文件包括在其他几个文件中，如果 在头文件初始化，将出现多个初始化副本，引发错误； 当然，也有例外：静态成员为整型或枚举型const 特殊成员函数：如果没有定义，C++自动提供了下面这些成员函数 默认构造函数 默认析构函数 复制构造函数 赋值运算符 地址运算符 C++11还提供了另外两个特殊成员函数：移动构造函数和移动赋值运算符 默认构造函数： 带参数的构造函数也可以是默认构造函数，只要所有的参数都有默认值，但只能有一个默认参数，不然会产生二义性 复制构造函数：将一个对象复制到新创建的对象中 用于初始化过程中（包括按值传递参数），而不是常规的赋值 类的复制构造函数原型：Class_name(const Class_name &amp;); 假设motto是一个StringBad对象，下面4种情况都调用复制构造函数： //calls StringBad(const StringBad &amp;);StringBad ditto(motto);StringBad metoo = motto;StringBad also = StringBad(motto);//使用motto初始化了一个匿名对象，并将新对象的地址赋给pstring指针StringBad * pStringBad = new StringBad(motto); 默认的复制构造函数逐个复制非静态成员（成员复制也称为浅复制），如果成员本身就是类对象，则将使用这个类的复制构造函数来复制成员对象 字符出现乱码：隐式复制构造函数是按值复制的，复制字符串（char*）复制的是指针，也就是说两个对象指向同一个字符串，一旦其中一个销毁了，另一个就用不了这个字符串了，所以在显式复制构造函数种需要新建一个字符串 必须定义复制构造函数（深度复制）的原因在于，一些类成员是使用new初始化的、指向数据的指针，而不是数据本身 赋值运算符： 运算符原型：Class_name &amp; Class_name::oprator=(const StringBad &amp;); 将已有的对象赋给另一个对象时，将使用重载运算符： StringBad headline1(\"ABC\");StringBad knot;knot = headline1; 初始化对象使用=，不一定会使用赋值运算符（比如还使用了复制构造函数），那么为什么说不一定呢，这是因为实现时也有可能分两步来完成，先使用复制构造函数生成一个临时对象，在把临时对象赋值给那个要初始化的对象。也就是说，初始化总会调用复制构造函数，而使用=运算符时也可能调用赋值运算符 函数应当避免将对象赋给自身，否则给对象重新赋值前，释放内存操作可能删除对象的内容（所以要先检查自我复制if(this == &amp;st) return *this;） 由于目标对象可能引用了以前分配的数据，所以函数应使用delete[]来释放这些数据 函数返回一个指向调用对象的引用 我认为一定要返回一个类的引用，是因为会有连等的情况比如A = B = C;这样的的话，B = C，然后返回一个类的引用也就是B，接着就会执行A = B; 12.2 改造后的新String类 在C++98中，字面值0有两个含义：可以表示数字值0，也可以表示空指针，有些程序员使用(void *) 0来表示空指针或者NULL；C++11引入新关键字nullptr，表示空指针 静态成员函数：函数声明必须包含static，但如果函数定义是独立的，则其中不能包含static 不能通过对象调用静态成员函数，静态成员函数甚至不能使用this指针 只能使用静态数据成员 可以使用静态成员函数设置类级（classwide）标记，以空值某些类接口的行为 如果是在公有部分声明的，则可以使用类名和作用域解析运算符调用： static int HowMany() {return num_strings;}int count = String::HowMany(); 12.3 在构造函数中使用new时应注意的 在构造函数中使用new来初始化指针成员，则应在析构函数中使用delete new和delete必须相互兼容；new对应delete，new[]对应delete[] 如果有多个构造函数，必须以相同的方式使用new，要么都到中括号要么都不带，因为只有一个析构函数 应定义一个复制构造函数，通过深度复制将一个对象初始化为另一个对象 具体来说，复制构造函数应分配足够的空间来存储复制的数据，并复制数据，而不仅仅是数据的地址，另外，还应该更新所有受影响的静态类成员 应当定义一个赋值运算符，通过深度复制将一个对象复制给另一个对象 具体来说，该方法应完成这些操作：检查自我赋值的情况，释放成员指针以前指向的内存，复制数据而不仅仅是数据的地址，返回一个指向调用调用对象的引用我 12.4 有关返回对象的说明 当成员函数或独立的函数返回对象时，可以返回指向对象的引用、指向对象的const引用或const对象 返回指向const对象的引用，旨在提高效率 返回对象将调用复制构造函数，而返回引用不会 引用指向的对象在调用函数执行时存在（也就是说不能是字面值，字面值的话就说明这对象之前没创建，开始调函数了，给了个字面值） 参数被声明为const引用，那么返回类型必须为const，这样才匹配 const Vector &amp; Max(const Vector &amp;v1, const Vector &amp;v2){ if(v1.magval() &gt; v2.magval()) return v1; else return v2;} 返回指向非const对象的引用 两种常见情形：重载赋值运算符以及重载与cout一起使用的&lt;&lt;运算符。前者这样做旨在提高效率（因为传非引用的对象也行，就是慢点），后者必须这样做，因为要用于串接输出cout&lt;&lt;a&lt;&lt;b&lt;&lt;c;，如果不返回引用而返回ostream，将要求调用复制构造函数，但ostream类没有公有的复制构造函数 返回对象 如果被返回的对象是被调用函数的局部变量，则不应该按引用方式返回它，因为执行完了函数会销毁的 返回const对象 其实就是增强代码鲁棒性，防止一些情况发生，比如a+b=c，如果没有const修饰，那么这句话是对的，只是产生了一个临时对象，然后销毁，但加上const，这句话就是不对的了 12.5 使用指向对象的指针 使用new初始化对象：Class_name * pclass = new Class_name(value); 如果不存在二义性，则将发生由原型匹配导致的转换 在下述情况下析构函数被调用 对象是动态变量，则当执行完定义该对象的程序块时，将调用该对象的析构函数 如果对象是静态变量，则在程序结束时调用 如果是new创建的，则仅当您显式使用delete删除对象时调用 定位new运算符：能够在分配内存时能够指定内存位置 比如： const int BUF = 512;char * buffer = new char[BUF];JustTesting *pc1, *pc2;pc1 = new(buffer)JustTesting;pc2 = new(buffer + sizeof(JustTesting))JustTesting; delete可以跟常规new配合使用，但不能和定位new搭配使用，比如指针pc2没有收到new返回的地址，因此delete会导致运行阶段错误；pc1指向的buffer是new[]初始化的，就算delete也要加[] 12.6 复习各种技术 重载&lt;&lt;运算符 转换函数 构造函数使用new的类 这些前面都有，包括第11章，直接翻前面就行了 12.7 队列模拟 栈是后进先出LIFO(last-in, first-out) 队列是先进先出FIFO 就是模拟了下ATM，写了个queue类和customer类，详情p460 " }, { "title": "C++ Primer Plus-第11章 使用类", "url": "/posts/C++-Primer-Plus-%E7%AC%AC11%E7%AB%A0-%E4%BD%BF%E7%94%A8%E7%B1%BB/", "categories": "C++, C++ Primer Plus", "tags": "学习笔记", "date": "2022-11-09 14:27:00 +0000", "snippet": "11.1 运算符重载 C++允许将运算符重载扩展到用户定义的类型 要重载运算符，需要使用被称为运算符函数的特殊函数形式：operatorop(argument-list)如operator+()重载＋运算符 op必须是有效的C++运算符，不能虚构一个新的符号，比如不能是＠11.2 计算时间：一个运算符重载示例 详情见p381，下面记一些重点 函数原型：Time ...", "content": "11.1 运算符重载 C++允许将运算符重载扩展到用户定义的类型 要重载运算符，需要使用被称为运算符函数的特殊函数形式：operatorop(argument-list)如operator+()重载＋运算符 op必须是有效的C++运算符，不能虚构一个新的符号，比如不能是＠11.2 计算时间：一个运算符重载示例 详情见p381，下面记一些重点 函数原型：Time operator+(const Time &amp; t) const 调用时，有两种方式：total = coding.operator+(fixing);和total = coding + fixing; 编译器将根据操作数的类型来确定如何做 t4 = t1 + t2 + t3;t4 = t1.operator+(t2 + t3);t4 = t1.operator+(t2.operator+(t3)); 运算符重载的限制： 重载后的运算符必须至少有一个操作数是用户定义的类型，防止用户为标准类型重载运算符 使用运算符时不能违反运算符原来的句法规则，比如不能将求模运算符（％）重载成使用一个操作数 不能创建新运算符 不能重载下面的运算符： 下面的运算符只能通过成员函数重载： =：赋值运算符 ()：函数调用运算符 []：下标运算符 -&gt;：通过指针访问类成员的运算符 可重载的运算符： 11.3 友元 C++提供了另外一种形式的访问权限：友元： 友元函数 友元类 友元成员函数 通过让函数成为类的友元，可以赋予该函数与类的成员函数相同的访问权限，本节仅介绍友元函数 在为类重载二元运算符时（带两个参数的运算符）常常需要友元，比如两个类型不同的参数：A = B*2.75和A = 2.75*B。按理来说应该一样，但第一个参数应该是类对象，所以第二个就会出问题 第一种方式是告知每个人按第一种方式编写，另一种解决方式——非成员函数 大多数运算符都可以通过成员或非成员函数来重载 非成员函数不是由对象调用的，它使用的所有值（包括对象）都是显示参数比如： A = 2.75 * B;A = operator*(2.75, B);//函数原型：Time operator*(double m , const Time &amp; t); 问题就是非成员函数不能访问对象的私有数据，故出现了友元函数 创建友元函数两部曲： 将原型放在类声明中，并加上关键字friend：friend Time operator*(double m , const Time &amp; t); 虽然operator*()函数是在类声明中声明的，但它不是成员函数，所以不能使用成员运算符来调用； 虽然operator*()函数不是成员函数，但它与成员函数的访问权限相同 编写函数定义（因为不是成员函数，所以不要使用Time::限定符），在函数定义时，就不需要写friend关键字了 如果要为类重载运算符，并将非类的项作为其第一个操作数，则可以用友元函数来反转操作数的顺序 通过友元函数重载&lt;&lt;: ostream &amp; operator&lt;&lt;(ostream &amp; os, const Time &amp; t){ os&lt;&lt;t.hours&lt;&lt;\" hours, \"&lt;&lt;t.minutes&lt;&lt;\" minutes\";} 11.4 重载运算符：作为成员函数还是非成员函数 一般来说，非成员函数应该是友元函数 在定义运算符时，必须选择一种格式（当两个参数都是同样的时候），因为两种格式都与同一个表达式匹配，同时定义这两种格式将被视为二义性错误11.5 再谈重载：一个矢量类 这小节是个例子，使用了上面的知识点和以前的一些知识点，比如枚举量啊之类的，详情见p39811.6 类的自动转换和强制类型转换 C++语言不会自动转换不兼容的类型，比如将数字赋给指针变量 当无法自动类型转换时，可以使用强制类型转换，如： int *p = (int *) 10; 可以将类定义成与基本类型或另一个类相关，使得从一种类型转换为另一种类型是有意义的 在C++中，接受一个参数（如果有两个参数，第二个参数提供了默认值的话也行）的构造函数为将类型与该参数相同的值转换成类提供了蓝图： Stone(double lbs);//构造函数 Stone cat;cat = 19.6;//double转换为Stone类型 C++新增了关键字explicit来关闭隐式自动转换这种自动特性，但仍然允许显式强制类型转换： explicit Stone(double lbs) 还有二步转换：比如int先转double再转成Stone；当且仅当不存在二义性时才可以二步转换 转换函数：将类对象转换成数字 operator typename();转换为typename类型，比如operator double(); 转换函数必须是类方法 转换函数不能指定返回类型 转换函数不能有参数 同样不能使用二义性转换 Stone::operator double() const{ return pounds;//成员变量} 转换函数和友元函数配合，可以实现数字=类+数字和数字=数字+类 " }, { "title": "C++ Primer Plus-第10章 对象和类", "url": "/posts/C++-Primer-Plus-%E7%AC%AC10%E7%AB%A0-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/", "categories": "C++, C++ Primer Plus", "tags": "学习笔记", "date": "2022-11-04 10:43:00 +0000", "snippet": "10.1 过程性编程和面向对象编程 最重要的OOP特性： 抽象 封装和数据隐藏 多态 继承 代码的可重用性 10.2 抽象和类 将问题的本质特征抽象出来，并根据特征来描述解决方案 指定基本类型完成了三项工作： 决定数据对象需要的内存数量 决定如何解释内存中的位 决定可使用数据对象执...", "content": "10.1 过程性编程和面向对象编程 最重要的OOP特性： 抽象 封装和数据隐藏 多态 继承 代码的可重用性 10.2 抽象和类 将问题的本质特征抽象出来，并根据特征来描述解决方案 指定基本类型完成了三项工作： 决定数据对象需要的内存数量 决定如何解释内存中的位 决定可使用数据对象执行的操作或方法 数据隐藏不仅可以防止直接访问数据，还让开发者无需了解数据是如何被表示的 不必在类声明中使用关键字private，因为这是类对象的默认访问控制 结构的默认访问类型是public 类成员函数两个特殊特征： 定义成员函数时，使用作用域解析运算符(::)来指出函数所属的类，比如void stock::update(double price); 类方法可以访问类的private组件 所创建的每个新对象都有自己的存储空间，用于存储其内部变量和类成员；但同一个类的所有对象共享一组类方法10.3 类的构造函数和析构函数 为避免成员名和参数名混淆，一种常见的做法是在数据成员名中使用m_前缀或者使用后缀_ 当且仅当没有定义任何构造函数时，编译器才会提供默认构造函数；为类定义了构造函数后，程序员必须为它提供默认构造函数 定义默认构造函数的方式有两种： 给已有构造函数的所有参数提供默认值 通过函数重载来定义另一个构造函数—一个没有参数的构造函数 隐式地调用默认构造函数时，不要使用圆括号 与构造函数不同的是，析构函数没有参数，因此Stock析构函数的原型必须是这样的：~Stock(); 在C++11中，可以将列表初始化语法用于类 保证函数不会修改调用对象的语法：将const关键字放在括号后面，比如void show() const;和void Stock::show() const 警告：接受一个参数的构造函数允许使用赋值语法将对象初始化为一个值：Classname object = value; 10.4 this指针 this指针指向用来调用成员函数的对象 每个成员函数都有一个this指针，this指针指向调用对象 10.5 对象数组 可以用构造函数来初始化数组元素，在这种情况下，必须为每个元素调用构造函数，可以对不同的元素使用不同的构造函数，如果只初始化了部分元素，那么剩下的就使用默认构造函数10.6 类作用域 在类中定义的名称（如类数据成员和类成员函数名）的作用域都为整个类，要调用公有成员函数，必须通过对象 声明类只是描述了对象的形式，并没有创建对象，因此，在创建对象前，将没有用于存储值的空间，即不能声明一个常量，但有两种解决方案： 在类中声明一个枚举： class Bakery{private: enum {Months = 12}; double consts[Months];} 这里使用枚举只是为了创建符号常量，并不打算创建枚举类型的变量，因此不需要提供枚举名，比如ios_base类在其公有部分完成了类似的工作，比如ios_base::fixed等标识符，fixed就是类的枚举量 使用关键字static class Bakery{private: static const int Months = 12; double consts[Months];} 在这里，该常量与其他静态变量存储在一起，而不是存储在对象中，被所有的Bakery对象共享 C++11作用域内枚举，为避免两个枚举的枚举量发生冲突，所以C++11提供了一种新枚举，作用域为类：enum class egg{small medium}; 10.7 抽象数据类型 abstract data type, ADT 比如栈就是一种抽象数据类型" }, { "title": "C++ Primer Plus-第9章 内存模型和名称空间", "url": "/posts/C++-Primer-Plus-%E7%AC%AC9%E7%AB%A0-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4/", "categories": "C++, C++ Primer Plus", "tags": "学习笔记", "date": "2022-10-28 11:29:00 +0000", "snippet": "9.1 单独编译 头文件常包含的内容： 函数原型 使用#define或const定义的符号常量 结构声明 类声明 模板声明 内联函数 ...", "content": "9.1 单独编译 头文件常包含的内容： 函数原型 使用#define或const定义的符号常量 结构声明 类声明 模板声明 内联函数 如果文件名包含在尖括号中，则C++编译器将在存储标准头文件的主机系统的文件系统中查找； 如果文件名包含在双引号中，则编译器将首先查找当前的当前的工作目录或源代码目录（或其他目录，这取决于编译器） 在UNIX系统中编译由多个文件组成的C++程序： 头文件管理： 在同一个文件中只能将同一个头文件包含一次 可以使用基于预处理编译指令#ifndef来避免多次包含同一个头文件 #ifndef COORDIN_H_#define COORDIN_H_/////......#endif 编译器首次遇到该文件时，名称COORDIN_H_没有定义（根据include文件名来选择名称，并加上下划线，为了创建一个在其他地方不太可能被定义的名称），此时编译器查看#ifndef和#endif之间的内容；如果COORDIN_H_已经被定义了，从而跳到#endif后面的一行 9.2 存储持续性、作用域和链接性 存储持续性： 自动存储持续性：在函数定义中声明的变量（包括函数参数）的存储持续性为自动的。它们在程序开始执行其所属的函数或代码块时被创建，在执行完函数或代码块时，它们使用的内存被释放。C++有两种存储持续性为自动的变量 静态存储持续性：在函数定义外定义的变量和使用关键字static定义的变量的存储持续性都为静态。它们在程序整个运行过程中都存在。C++有3种存储持续性为静态的变量 线程存储持续性(C++11):当前，多核处理器很常见，一这些CPU可同时处理多个执行任务。这让程序能够将计算放在可并行处理的不同线程中。如果变量是使用关键字thread_local声明的，则其生命周期与所属的线程一样长。本书不探讨并行编程 动态存储持续性：用new运算符分配的内存将一直存在，直到使用delete运算符将其释放或程序结束为止。这种内存的存储持续性为动态，.有时被称为自由存储(freestore)或堆(heap) 作用域（scope）描述了名称在文件（翻译单元）的多大范围内可见 链接性（linkage）描述了名称如何在不同的单元间共享：链接性为外部的名称可以在文件间共享，链接性在内部的名称只能由一个文件中的函数共享。自动变量的名称没有链接性，因为它们不能共享 当代码块内外有同名变量时，程序执行代码块内部语句时，解释为局部代码块变量，新的定义暂时隐藏了以前的定义 自动变量和栈： 程序再运行时对自动变量进行管理，留出一段内存，视其为栈，管理变量的增减 之所以叫栈，是因为新数据象征性地被放在原有数据的上面 栈默认长度取决于实现，一般可以选择改变 程序用两个指针跟踪栈，栈底和栈顶 函数调用时，自动变量入栈，函数结束时，栈顶指针重置 寄存器变量：关键字register建议编译器使用CPU寄存器存储自动变量，旨在提高访问变量的速度，使用原因：指出程序员想使用的一个自动变量。然而保留这个关键字的重要原因时避免使用过该关键字的代码非法 静态持续变量： 外部链接性（可在其他文件中访问）：必须在代码块外面声明 内部链接性（仅当前文件访问）：必须在代码块外面声明并使用static限定符 无链接性（仅当前函数或代码块使用）：必须在代码块内部声明，并使用static限定符 三种链接性都在整个程序执行期间存在 编译器分配固定的内存块存储所有静态变量 如果没有显式初始化，那么默认设置为0 5种变量存储方式： 零初始化和常量表达式初始化被统称为静态初始化，这意味着在编译器处理文件（翻译单元）时初始化变量。动态初始化意味着变量将在编译后初始化 外部变量：是在函数外部定义的，也称全局变量 单定义规则：变量只能有一次定义 定义声明(defining declaration)，简称定义，它给变量分配存储空间 引用声明(referencing declaration)，简称声明：不给变量分配存储空间，因为它引用已有的变量 引用声明使用关键字extern，且不进行初始化，否则声明为定义，导致分配存储空间 extern int blem;//声明extern char gr = 'z';//定义 想要使用其他文件定义的外部变量，那么就要在本文件中使用extern声明 定义与全局变量同名的的局部变量后，局部变量将隐藏全局变量 C++提供了作用域解析运算符（::），放在变量名前面时，该运算符表示使用变量的全局版本 静态外部变量（也就是使用static修饰的外部变量），如果与另一个文件中声明的常规外部变量相同，则在该文件中，静态变量将隐藏常规外部变量 无链接性的局部静态变量： 在代码块中使用static，将导致局部变量的存储持续性变为静态的 变量在该代码块不处于活动状态时仍然存在 两次函数调用之间，静态局部变量的值保持不变 如果初始化了静态局部变量，则程序只在启动时进行一次初始化 说明符： auto（C++11不再是说明符） register static extern thread_local（C++11新增）：thread_local变量之于线程，犹如常规静态变量之于整个程序 mutable：即使结构或类变量为const，其某个成员也可以被修改，比如声明了一个const结构对象，按理来说其成员不可被修改，但倘若其成员被mutable修饰，那么还是可以被修改的 cv-限定符： const volatile：即使程序代码没有对内存单元进行修改，其值也可能发生变化（比如硬件修改数据，如果不加这个限定符，编译器可能会执行优化导致一个变量存到寄存器（默认变量不会变化）而不能被硬件或其他情况修改，详情见书p317） const限定符修饰的全局变量将会从外部链接性转变为内部链接性，也就是说，在C++看来，全局const定义就像使用了static说明符一样 函数和链接性： 所有函数的存储持续性都自动为静态的 在默认情况下，函数的链接性为外部的，即可以在文件间共享，当然，想在其他文件中使用，需要提前使用extern来声明函数（不用再次定义否则报错噢） 和变量类似，函数也可以使用extern和static 语言链接性（详情见p319，感觉这个点没啥用）： 在C++中，同一个名称可能对应多个函数，必须将这些函数生成不同的符号名称，例如soiff(int)转换为_spoff_i，这种方法被称为C++语言链接 存储方案和动态分配： 通常，编译器使用三块独立的内存：一块用于静态变量（可能再细分），一块用于自动变量，一块用于动态存储 new失败时，在最初的10年C++会让new返回空指针，但现在将引发异常std::bad_alloc 定位new运算符（感觉不太常用，详情见p321） 通常new负责在堆中找内存块，而new存在变体，定位new运算符可以让程序员指定需要使用的位置9.3 名称空间 传统C++名称空间： 声明区域(declaration region)：可以在其中进行声明的区域 潜在作用域(potential scope)：从声明点开始，到声明区域结尾，因此比声明区域小 新的名称空间特性： 通过定义一种新的声明区域来创建命名的名称空间，目的之一是提供一个声明名称的区域 一个名称空间中的名称不会与另一个名称空间的相同名称发生冲突 名称空间可以是全局的，也可以位于另一个名称空间中，但不能位于代码块中，所以在默认情况下，在名称空间中声明的名称的链接性为外部的（除非引用了常量） 全局名称空间（global namespace）：它对应于文件级声明区域 访问：使用域解析运算符::如Jack::pail = 12.34; 未被装饰的名称如pail称为未限定的名称(unqualified name)；包含名称空间的名称如Jack::pail称为限定的名称(qualified name) C++提供了两种机制即using声明和using编译指令来简化堆名称空间中名称的使用 using声明使特定的标识符可用，using编译指令使整个名称空间可用 using声明：using Jack::fetch;，之后便可以用fetch来代替Jack::fetch using编译指令：using namespace Jack; 它们增加了名称冲突的可能性 还有一些比较复杂的情况，比如局部名称隐藏名称空间名等等，感觉并不会很常用，详情见p328 名称空间其他特性： 可以嵌套 未命名的名称空间（怪，这真的会用到么）：这提供了链接性为内部的静态变量的替代品（好像还真有点用，比如少写一些static） 名称空间及其前途： 使用在已命名的名称空间中声明的变量，而不是使用外部的全局变量 使用在已命名的名称空间中声明的变量，而不是使用静态全局变量 如果开发了一个函数库或类库，将其放在一个名称空间中 仅将编译指令作为一种将旧代码转换为使用名称空间的权宜之计 不要在头文件中使用using编译指令，如果非用，应放在预处理编译指令#include之后 导入名称时，首选使用作用域解析运算符或using声明的方法 对于using声明，首选将其作用域设置为局部而不是全局 " }, { "title": "C++ Primer Plus-第8章 函数探幽", "url": "/posts/C++-Primer-Plus-%E7%AC%AC8%E7%AB%A0-%E5%87%BD%E6%95%B0%E6%8E%A2%E5%B9%BD/", "categories": "C++, C++ Primer Plus", "tags": "学习笔记", "date": "2022-10-16 12:07:00 +0000", "snippet": "    没想到这一章竟然持续了将近10天！虽然差不多是看了三天，因为前面一周感冒纯开摆，顺便还去长广溪呆了两天YWY8.1 C++内联函数 内联函数是C++为提高程序运行速度所做的一项改进。常规函数和内联函数之间的主要区别不在手编写方式，而在于C++编译器如何将它们组合到程序中 编译过程的最终产品是可执行程序——由一组机器语言指令组成，运行程序时，操作系统将这些指令载...", "content": "    没想到这一章竟然持续了将近10天！虽然差不多是看了三天，因为前面一周感冒纯开摆，顺便还去长广溪呆了两天YWY8.1 C++内联函数 内联函数是C++为提高程序运行速度所做的一项改进。常规函数和内联函数之间的主要区别不在手编写方式，而在于C++编译器如何将它们组合到程序中 编译过程的最终产品是可执行程序——由一组机器语言指令组成，运行程序时，操作系统将这些指令载入到计算机内存中，因此每条指令都有特定的内存地址 常规函数调用使程跳到另一个地址（函数的地址），并在函数结束时返回 执行到函数调用指令时，程序将在函数调用后立即存储该指令的内存地址 并将函数参数复制到堆栈 跳到标记函数起点的内存单元，执行函数代码（也许还需要将返回值放入寄存器中） 跳回到地址被保存的指令处 来回跳跃需要一定的开销 内联函数的编译代码与其他程序代码“内联”起来了，也就是说编译器将使用相应的函数代码替换函数调用，不需要跳跃，因此更快，但代价是占用更多内存 如果执行函数代码的时间比处理函数调用机制的时间长，则节省的时间将只占整个过程的很小一部分。如果代码执行时间很短，则内联调用就可节省非内联调用使用的大部分时间 使用内联函数： 在函数声明前加上关键字inline 在函数定义前加上关键字inline 通常做法是省略原型，将整个定义放在本应提供原型的地方 内联函数不能递归 inline是C++新增的特性，C语言使用#define来提供宏（但宏不能按值传递） 8.2 引用变量 引用是已定义的变量的别名 通过将引用变量用作参数，函数将使用原始数据 int &amp;指向int变量的引用 必须在声明引用时将其初始化 int &amp; rodents = rats;其实是int * const pr = &amp;rats;的伪装表示 引用常被用作函数参数，这种传递参数的方法称为按引用传递 如果编写使用基本数值类型的函数，应采用按值传递的方式，当数据比较大时，引用参数将很有用 如果函数形参是引用，那么实参应该是变量，因为比如不能将值赋给表达式和字面常量 如果实参和引用参数不匹配，C++将生成临时变量，而且仅当参数为const引用时才允许这样做: 实参类型正确，并且是非左值(字面常量（除了字符串，因为是指针）、表达式) 实参的类型不正确，但可以转换为正确的类型 原因其实也很简单，如果不加const意味着想要使用引用修改实参，但C++生成了临时变量，所以是没法修改的。加了const就是不想修改实参，那么生成临时变量去算也没关系，这样的话，该函数只需要在必要的时候生成临时变量，其他情况不生成，又能节约时间还能增加函数使用空间。临时变量只在函数调用期间存在。 注意：如果函数调用的参数不是左值或与相应的cost引用参数的类型不匹配，则C++将创建类型正确的匿名变量，将函数调用的参数的值传递给该匿名变量，并让参数来引用该变量。 应尽可能使用const 可以避免无意中修改数据的编程错误 使函数能够处理const和非const实参，否则将只能接受非const数据 使用const引用使函数能够正确生成并使用临时变量 引用非常适合用于结构和类 函数头的返回类型如果不是引用，那么将返回一个拷贝；如果返回类型为引用，意味着返回对象本身 为何要返回引用？返回引用与传统返回机制的不同： 传统返回机制与按值传递函数参数类似：计算关键字return后面的表达式，并将结果返回给调用函数，从概念上来讲，这个值被复制到一个临时位置，而调用程序将使用这个值 返回引用直接把结果返回，不会复制到临时位置 注意：应避免返回 函数终止时不再存在的 内存单元引用（比如函数中新建了个对象，返回了这个对象，但该对象在函数结束后自动就销毁了） 解决办法就是： 返回一个作为参数传递给函数的引用 用new来分配新的存储空间 const node &amp; clone(node &amp; n){ node * p; *p = n;//此时复制了n，此处隐藏了new，实际上使用了new return *p;} 这样使得后面很容易忘记使用delete释放内存 将const用于引用返回类型 一方面不能成为左值 另一方面不能成为函数非const形参的实参 将C-分割字符串用作string对象引用参数 string类定义了一种char*到string的转换功能，这使得可以使用C-风格字符串(如\"abcd\")来初始化string对象 使用const引用形参，如果类型不匹配但能转换为引用类型，那么就会创建正确的临时变量，如果不加const只加引用，那么会报错 基类引用可以指向派生类对象，例如参数类型为ostream &amp;的函数可以接受ostream对象或ofstream对象  setf()可以设置各种格式化状态（ostream类中的方法） setf(ios_base::fixed)定点表示法 setf(ios_base::showpoint)显示小数点模式 width()（ostream类中的方法）设置下一次操作使用的字段宽度，这种设置只在下一个值时有效，然后恢复默认 何时使用引用参数： 能够修改函数中的数据对象 提高运行速度 使用引用、指针、按值传递的指导原则 对于使用传递的值而不做修改的函数 如果数据对象很小，比如内置数据类型或小结构，则按值传递 如果数据对象是数组，则使用指针，并将指针声明为指向const的指针 如果数据对象是较大的结构，则使用const指针或const引用以提高程序效率 如果数据对象是类对象，则使用const引用。传递类对象参数的标准方式是按引用传递 对于修改调用函数中数据的函数 如果数据对象是内置数据类型，则使用指针 如果数据对象是数组，则只能使用指针 如果数据对象是结构，则使用引用或指针 如果对象是类对象则使用引用 当然，以上都是指导原则，有可能做出其他选择。比如cin对于基本类型使用引用，因此可以使用cin&gt;&gt;n而不是cin&gt;&gt;&amp;n 8.3 默认参数 默认参数指的是当函数调用中省略了实参时自动使用的一个值 通过函数原型来设置默认值，将值赋给原型中的参数，例如char * left(const char * str, int n = 1); 对于带参数列表的函数（即有多个参数），必须从右向左添加默认值 实参按从左到右的顺序依次被赋给相应的形参，而不能跳过任何参数，因此下面的调用是不允许的beeps=harpo(3, ,8); 8.4 函数重载 函数重载的关键是函数的参数列表——也称为函数特征标(function signature)，如果两个函数的参数数目和类型相同，同时参数的排列顺序也想通，则它们的特征标相同，而变量名是无关紧要的 C＋＋允许定义名称相同的函数，条件是它们的特征标不同 使用被重载的函数时，需要在函数调用中使用正确的参数类型（也就是说不会自动转换类型） 为避免混乱，类型引用和类型本身视为同一特征标 匹配函数时，并不区分const和非const，这是因为非const可以赋给const；如果重载了一个const形参的函数和一个非const形参的函数，那么就会匹配正确类型，如果只写了const的函数，那么非const实参也可以赋给const形参；如果只写了非const形参函数，那么const实参无法赋值 特征标相同且返回类型不同的不能重载 void stove(double &amp;&amp; r3);这个可以与右值参数匹配，如两个double的和，如果没有定义这个函数，那么就会调用stove(const double &amp;) 名称修饰(name decoration)或名称矫正(name mangling)：它根据函数原型中指定的形参类型对每个函数名进行加密；编译器会将奖惩转换为不太好看的内部表示来描述接口，比如long f(int , float);转换为?f@@YAXH。添加的符号随函数特征标而异，而修饰时使用的约定随编译器而异 8.5 函数模板 函数模板是通用的函数描述，也就是说，它们使用泛型来定义函数 建立一个交换模板： template &lt;typename AnyType&gt;void Swap(AnyType &amp;a, AnyType &amp;b){ AnyType tmp; tmp = a; a = b; b = tmp;}template &lt;class AnyType&gt;void Swap(AnyType &amp;a, AnyType &amp;b){ AnyType tmp; tmp = a; a = b; b = tmp;} 第一行指出要建立一个模板，并将类型命名为AnyType；关键字tmplate和typeename是必需的，除非使用关键字class代替typename 注意，函数模板不能缩短可执行程序 并非所有的模板参数都必须是模板参数类型，可以是具体类型 第三代具体化： 对于给定的函数名，可以有非模板函数、模板函数和显式具体化模板函数以及它们的重载版本 显式具体化的原型和定义应以template&lt;&gt;打头，并通过名称来指出类型 具体化优先于常规模板，而非模板函数优先于具体化和常规模板 void swap(job &amp;, job &amp;);//非模板template &lt;typename T&gt;void swap(T &amp;, T &amp;);//模板template &lt;&gt; void swap&lt;job&gt;(job &amp;, job &amp;);//显式具体化模板template &lt;&gt; void swap(job &amp;, job &amp;);//&lt;job&gt;可省略 实例化和具体化： 函数模板本身并不会生成函数定义，它只是一个用于生成函数定义的方案 实例化： 编写模板后，调用模板函数如swap(i,j)，那么会导致编译器生成swap()的一个实例，即生成了一个函数定义，这种实例化方式称为隐式实例化(implicit instantiation) 显式实例化(explicit instantiation)：命令创建特定的实例template void swap&lt;int&gt;(int, int);；也可以使用函数来创建显式实例化，比如swap&lt;int&gt;()，即使用swap()模板来生成int类型的函数定义，那么如果参数的类型不同，就可以通过类型转换而尝试运行，当然也有可能出其他的错误，但是，隐式实例化遇到两个不同类型的参数会直接报错（swap模板的两个形参类型一样） 显式具体化(explicit specialization)：template &lt;&gt; void swap&lt;int&gt;(int &amp;, int &amp;) ;//(其中&lt;int&gt;可省略)这个声明的意思是不要使用swap模板来生成int的函数定义，而是应该使用专门为int类型显式地定义的函数定义 隐式实例化、显式实例化、显式具体化统称为具体化 重载解析(overloading resolution)：对于函数重载、函数模板和函数模板重载，C++需要一个策略——决定为函数调用使用哪一个函数定义，尤其是有多个参数时 创建候选函数列表，其中包含与被调用函数名称相同的函数和模板函数 使用候选函数列表创建可行函数列表(类型隐式转换的也加入可行列表) 确定是否有最佳可行函数 最佳到最差顺序： 完全匹配，但常规函数优于模板 提升转换（如char自动转为int，float自动转double） 标准转换（如int转char，long转double） 用户自定义的转换 如果有多个匹配的原型，没有最佳的可行函数（如果存在更具体的，那么也算是有最佳的可行函数），则编译器会生成一条错误信息。比如ambiguous(二义性) 自己选择 lesser&lt;&gt;(m,n);此时是示意编译器选择模板函数而不使用非模板函数 lesser&lt;int&gt;(m,n);此时是示意编译器选择模板函数并将实参强制转换为int 模板函数拓展 为解决类型问题，发明了关键字decltype: template&lt;typename t1, typename t2&gt;void f(t1 x, t2 y){ decltype(x)z;//设置z的类型和x一样 decltype(x + y) xpy;//设置xpy的类型与x+y一样 xpy = x + y;} 语法：decltype(expression) var; 如果expression是一个没有用括号括起来的标识符，那么var的类型与该标识符类型相同 如果expression是一个函数调用，则var类型与函数的返回类型相同 如果expression是一个左值，那么var为指向其类型的引用 同样，因为无法预先知道x和y的类型，可以将返回类型设置为decltype(x + y)，但此时未声明x和y，不在作用域（编译器看不到），为此C++11使用auto与后置返回类型(trailing return type)来操作： template&lt;class t1, class t2&gt;auto gt(t1 x, t2 y) -&gt; decltype(x + y){ return x + y; } " }, { "title": "C++ Primer Plus-第7章 函数——C++的编程模块", "url": "/posts/C++-Primer-Plus-%E7%AC%AC7%E7%AB%A0-%E5%87%BD%E6%95%B0-C++%E7%9A%84%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9D%97/", "categories": "C++, C++ Primer Plus", "tags": "学习笔记", "date": "2022-10-14 12:25:00 +0000", "snippet": "    这章16号才看完，因为15号去辅导学弟了（虽然辅导了个空气），15号三国杀杀到半夜，人都给杀麻了……7.1 复习函数的基本知识 要使用C++函数，必须完成如下工作： 提供函数定义 提供函数原型（在使用前声明函数名） 调用函数 函数是...", "content": "    这章16号才看完，因为15号去辅导学弟了（虽然辅导了个空气），15号三国杀杀到半夜，人都给杀麻了……7.1 复习函数的基本知识 要使用C++函数，必须完成如下工作： 提供函数定义 提供函数原型（在使用前声明函数名） 调用函数 函数是如何返回值的：通常，函数通过将返回值复制到指定的CPU寄存器或内存单元中来将其返回。随后，调用程序将查看该内存单元。返回函数和调用函数必须就该内存单元中存储的数据的类型达成一致。函数原型将返回值类型告知调用程序，而函数定义命令被调用函数应返回什么类型的数据 函数原型通常隐藏在include文件中 需要原型的原因： 在文件中查找效率低 不一定在文件中，可能无权访问函数代码 唯一避免使用函数原型的方法是在使用函数之前定义 原型的功能： 编译器正确处理函数返回值 编译器检查使用的参数数目是否正确 编译器检查使用的参数类型是否正确。如果不正确，则转换为正确的类型（如果可能的话） 仅当有意义时，原型化才会导致类型转换。例如，原型不会将整数转换为结构和指针。 在编译阶段进行的原型化被称为静态类型检查。可以看出，静态类型检查可以捕获许多在运行阶段非常难以捕获的错误 7.2 函数参数和按值传递 用于接受传递值得变量称为形参(parameter)，传递给函数的值称为实参(argument) 一般情况下（即不加引用），函数将创建一个新的变量作为形参，相当于副本 7.3 函数和数组 int sum_arr(int arr[], int n);方括号指出arr是一个数组，任意长度皆可；但实际上arr是一个指针！不过在编写函数其余部分时，可以将arr看成数组 int sum_arr(int* arr, int n);在C++中，当且仅当用于函数头或函数原型中，int* arr和int arr[]的含义才是相同的。它们都意味着arr是一个int指针，都指向数组的第一个元素 传递常规变量时，函数将使用该变量的拷贝；但传递数组时，函数将使用原来的数组（因为传的是地址） 注意，地址值和数组的长度随系统而异，另外，有些C++实现以十进制而不是十六进制格式显示地址，有些编译器以十六进制显示地址时，会加上前缀0x； 编写特定的函数来处理特定的数据操作是有好处的（程序的可靠性更高，修改和调试更为方便） 构思程序时，将存储属性与操作结合起来，便是朝OOP思想迈进了重要的一步 void show(const double arr[], int n);常量指针，该指针不能修改指向的数据，保护原数组 常量指针： int age = 13; const int* pt = &amp;age; 实际上pt并不一定意味着它指向的值实际上就是一个常量，而只是意味着对pt而言，这个值是常量。 注意：不能将const变量的地址赋给常规指针，如果非要这么做，需要使用强制类型转换，详情见第15章；如果数据本身不是指针，则可以将const数据或非const数据的地址赋给指向const的指针，但只能将非const数据的地址赋给非const指针 尽可能使用const：将指针参数声明为指向常量数据的理由 避免由于无意间修改数据类型而导致的编程错误 使用const使得函数能够处理const和非const实参，否则将只能接受非const数据。如果条件允许，则应该将指针形参声明为指向const的指针。如下：非const指针可以作为const形参的实参，而且由于加了const，所以函数不能修改数组 #include&lt;iostream&gt;using namespace std;void fun(const int arr[]){ cout &lt;&lt; arr[0];}int main(){ int* arr = new int[10]{1,2};//列表初始化，后面的都初始化为0 fun(arr);} 7.4 函数和二维数组 二维数组没有使用const，因为这种技术只能用于指向基本类型的指针，而ar2是指向指针的指针7.5 函数和C-风格字符串 C-风格字符串与常规char数组之间的一个重要区别是：字符串有内置的结束字符，不以空值字符结尾的char数组只是数组，而不是字符串7.6 函数和结构 当结构比较小时，按值传递结构最合理7.7函数和string对象 string对象与结构更相似 可以将一个对象赋给另一个对象 可以将对象作为完整的实体进行传递 需要多个字符串可以声明一个string数组 7.8 函数与array对象 模板array并非只能存储基本数据类型，还可以存储类对象7.9 递归 每个递归调用都创建自己的一套变量(这就是为啥递归调多了会栈溢出)7.10 函数指针 函数的地址是存储其机器语言代码的内存的开始地址 比如可以编写将另一个函数的地址作为参数的函数，它允许在不同的时间传递不同函数的地址，这意味着可以在不同的时间使用不同的函数 函数指针的基础知识： 获取函数的地址：只要函数名（后面不跟参数即可） 声明函数指针：通常，需要声明特定类型函数的指针，可以先编写这种函数的原型，然后用(*pf)替换函数名，pf就是这类函数的指针 double pam(int);//指针类型声明：double (*pf)(int);pf = pam;void estimate(int lines, double (*pf)(int)); 使用指针来调用函数：(*pf)扮演的角色与函数名相同；但实际上，C++也允许像使用函数名那样使用pf，第一种格式虽然不好看，但它给出了强有力的提示——代码正在使用函数指针 double x = pam(5);double y = (*pt)(5);double z = pt(5); 深入探讨函数指针： 在函数原型中，可以省略标识符。比如const double ar[]可简化为const double [] 使用C++11的自动类型推断功能，代码要简单得多： const double * f1(const double *, int);const double * (*p1)(const double *, int) = f1;auto p2 = f1; 函数指针数组： const double * (*pa[3])(const double *, int)={f1,f2,f3}; []的优先级高于，因此pa[3]表示pa是一个包含3个指针的数组，特征标为：const double*，int，返回类型为const double * auto自动类型判断只能用于单值初始化，不能用于初始化列表 pa指向函数数组第一个元素（函数指针）的指针，pa[0]储存第一个函数指针。使用函数指针数组调用函数： const double * px = pa[0](av,3);const double * py = (*pa[1])(av,3); 除了auto外，C++还提供了其他简化声明的工具，比如关键字typedef能够创建类型别名，比如某个函数指针类型： typedef const double * (*p_fun)(const double *, int);p_fun是一个函数指针的类型名了 " }, { "title": "C++ Primer Plus-第6章 分支语句和逻辑运算符", "url": "/posts/C++-Primer-Plus-%E7%AC%AC6%E7%AB%A0-%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5%E5%92%8C%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6/", "categories": "C++, C++ Primer Plus", "tags": "学习笔记", "date": "2022-10-13 09:25:00 +0000", "snippet": "这章重点是简单文件输入输出，看来后面还会有复杂文件输入输出啊…..6.1 if语句 条件运算符和错误防范：很多程序员将更直观的表达式variable == value反转为value==variable，以此来捕获将相等运算符误写为赋值运算符的错误。 一般来说，编写让编译器能够以发现错误的代码，比找出导致难以理解的错误的原因要容易的多 6.2 逻辑表达式...", "content": "这章重点是简单文件输入输出，看来后面还会有复杂文件输入输出啊…..6.1 if语句 条件运算符和错误防范：很多程序员将更直观的表达式variable == value反转为value==variable，以此来捕获将相等运算符误写为赋值运算符的错误。 一般来说，编写让编译器能够以发现错误的代码，比找出导致难以理解的错误的原因要容易的多 6.2 逻辑表达式 也就是与或非，c++不需要头文件就可以使用标识符来表示： 6.3 字符函数库cctype C++从C语言继承了一个与字符相关的、非常方便的函数软件包，它可以简化诸如确定字符是否为大写字母、数字、标点符号等工作，这些函数的原型是在头文件cctype(老式的风格中为ctype.h)中定义的。 6.4 ?运算符 其实就是三目运算符6.5 switch语句 可以使用枚举量作为标签 然而，如果所有的选项都可以使用整数常量来标识，则可以使用switch语句或ifelse语句。由于switch语句是专门为这种情况设计的，因此，如果选项超过两个，则就代码长度和执行速度而言，switch语句的效率更高。 提示：如果既可以使用if else if语句，也可以使用switch语句，则当选项不少于3个时，应使用switch语句。 6.6 break和continue语句 continue导致该程序跳过循环体的剩余部分，但不会跳过循环的更新表达式，也就是说，在for循环中，continue先跳到更新表达式处，然后跳到测试表达式处6.7 读取数字的循环 输入错误和EOF都会导致cin返回false 读取错误发生的5种情况：以int类型的n输入单词为例 n不变 不匹配的输入将被留在输入队列中 cin对象种的一个错误标记被设置 对cin方法的调用将返回false 接下来的cin拒绝输入，必须使用cin.clear()重置cin后才可以输入，而且会首先接受刚才被留在输入队列种的输入 当程序发生输入错误时，应该采取三个步骤： 重置cin以接受新的输入 删除错误输入 提示用户再输入 int a; while (!(cin &gt;&gt; a)) { cin.clear(); while (cin.get() != '\\n')//或者' ' continue; cout &lt;&lt; \"please enter a number\"; } 6.8 简单文件输入/输出 写入文件： 必须包含头文件fstream，头文件fstream定义了一个用手处理输出的ofstream类 需要声明一个或多个ofstream变量（对象），并以自己喜欢的方式对其进行命名，条件是遵守常用的命名规则 必须指明名称空间std;例如，为使用用元素ofstream,必须使用编译指令using或前缀std 需要将ofstream对象与文件关联起来，为此，方法之一是使用open()方法 使用完文件后，应使用方法close()将其关闭 可结合使用ofstream对象和运算符«来输出各种类型的数据 #include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;string&gt;using namespace std;int main(){ ofstream fout; string s; double d; fout.open(\"a.txt\"); getline(cin, s); cin &gt;&gt; d; fout.precision(2);//设置有效位为2（如果是1，那么就写入1.0） fout.setf(ios_base::showpoint);//强制写入小数点，如果不加这一行1就是写入1了 fout &lt;&lt; s &lt;&lt; endl &lt;&lt; d; fout.close();} 程序运行前，如果文件不存在，那么open就会新建一个文件；如果存在，那么清空该文件，重新写入 读取文件： 必须包含头文件fstream，头文件定义了一个用于处理输入的ifstream类 需要声明一个或多个ifstream变量（对象），并以自己喜欢的方式对其进行命名，条件是遵守常用的命名规则 必须指明名称空间std;例如，为使用用元素ifstream,必须使用编译指令using或前缀std 需要将ofstream对象与文件关联起来，为此，方法之一是使用open()方法 使用完文件后，应使用方法close()将其关闭 可结合使用ifstream对象和运算符»来读取各种类型的数据 可以使用ifstream对象和get()方法来读取一个字符，使用ifstream对象和getline()来读取一行字符 可以结合使用ifstream和eof()、fail()等方法来判断输入是否成功 ifstream对象本身被用作测试条件时，如果最后一个读取操作成功，它将被转换为布尔值truc,否则被转换为fase #include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;string&gt;#include&lt;cstdlib&gt;using namespace std;int main(){ ifstream fin; fin.open(\"a.txt\"); if (!fin.is_open()) { cout &lt;&lt; \"No file\"; exit(EXIT_FAILURE); } int a, cnt = 0; fin &gt;&gt; a; while (fin.good()) { cnt++; cout &lt;&lt; a&lt;&lt;endl; fin &gt;&gt; a; } cout &lt;&lt; cnt &lt;&lt; endl; if (fin.eof()) cout &lt;&lt; \"End of File\\n\"; else if (fin.fail()) cout &lt;&lt; \"data mismatch\\n\"; else cout &lt;&lt; \"unknwon erro\\n\"; fin.close();} 检查文件是否被打开的首先方法是使用方法is_open() 函数exit()(终止程序)原型在头文件cstdlib种定义的，该头文件中还定义了一个用于同操作系统通信的参数值EXIT_FAILURE 注意，文件中，最后一个信息之后最好加个空格或者回车，不然读不进去，比如1 2 3，最后的3是打印不出来的，此时 fin.good()已经返回false了，所以要在3后面加个空格或者回车。但是，如果不用fin.good()，而是直接用fin&gt;&gt;a作为条件，文件最后就不需要额外加东西了： int a, cnt = 0; while (fin&gt;&gt;a) { cnt++; cout &lt;&lt; a&lt;&lt;endl; } " }, { "title": "C++ Primer Plus-第5章 循环和关系表达式", "url": "/posts/C++-Primer-Plus-%E7%AC%AC5%E7%AB%A0-%E5%BE%AA%E7%8E%AF%E5%92%8C%E5%85%B3%E7%B3%BB%E8%A1%A8%E8%BE%BE%E5%BC%8F/", "categories": "C++, C++ Primer Plus", "tags": "学习笔记", "date": "2022-10-12 09:48:00 +0000", "snippet": "    今天是把上一章剩下的一点看完了。这一章内容其实不多，也不难，但晚上要去做摄影作业了，又得拖到明天才能看完了。    感觉EOF这里多看了会，别的问题不大。5.1 for循环 步骤： 1.设置初始值 2.执行测试，看看循环是否应当继续进行 3.执行循环操作 4.更新用于测试的值 C++常用的方式是，在for（和其他控制语句if、while...", "content": "    今天是把上一章剩下的一点看完了。这一章内容其实不多，也不难，但晚上要去做摄影作业了，又得拖到明天才能看完了。    感觉EOF这里多看了会，别的问题不大。5.1 for循环 步骤： 1.设置初始值 2.执行测试，看看循环是否应当继续进行 3.执行循环操作 4.更新用于测试的值 C++常用的方式是，在for（和其他控制语句if、while）和括号之间加上一个空格，而省略函数名和括号之间的空格。这样从视觉上强化了控制语句和函数调用之间的区别 表达式到语句的转换只需要加一个分号，所有表达式都可以成为语句，但不一定有编程意义：rodents + 6; 副作用（side effect）：指的是在计算表达式时对某些东西（如存储在变量中的值）进行了修改 顺序点（sequence point）：是程序执行过程中的一个顺序点 在C++中，语句中的分号就是一个顺序点，意味着程序处理下一条语句之前，赋值运算符、递增运算符和递减运算符执行的所有修改都必须完成。另外，任何完整的表达式末尾都是一个顺序点 完整的表达式：不是另一个更大的表达式的子表达式 C++11文档中不再使用“顺序点”，因为难以用于讨论多线程。所以使用了“顺序” 然而，虽然选择使用前缀格式还是后缀格式对程序的行为没有影响，但执行速度可能有细微的差别。对于内置类型和当代的编译器而言，这看似不是任么问题。然而，C++允许您针对类定义这些运算符，在这种情况下，用户这样定义前缀函数：将值加1，然后返回结果：但后缀版本首先复制一个副本，将其加1，然后将复制的副本返回。因此，对于类而言，一前缀版本的效率比后缀版本高 指针递增和递减遵循指针的算术规则 5.2 while循环 由于for循环和while循环几乎是等效的，因此究竞使用哪一个只是风格上的问题。它们之间存在三个差别： 首先，在for循环中省略了测试条件时，将认为条件为tnue; 其次，在for循环中，可使用初始化语句声明一个局部变量，但在while循环中不能这样做； 最后，如果循环体中包括continue语句，情况将稍有不同，continue语句将在第6章讨论。 通常，程序员使用for循环来为循环计数，因为for循环格式允许将所有相关的信息—初始值、终止值和更新计数器的方法一放在同一个地方。在无法预先知道循环将执行的次数时，程序员常使用while循环 编写延时循环 使用ctime头文件，其中定义了一个符号常量CLOCKS_PER_SEC，每秒钟包含的系统时间单位数（我测试了下我的是1000），因此，将系统时间除以这个值，可以得到秒数（其中可以使用clock()函数返回程序开始执行后所用的系统时间） ctime头文件将clock_t作为clock()返回类型的别名，因为不同系统的clock()函数返回的类型可能不同（比如long或unsigned long）(确实有道理，毕竟时间不会是负数，无符号更合适) 5.3 do while循环 do while属于出口条件循环 一般情况下，入口条件循环好 5.4 基于范围的for循环(C++11) 其实就是for循环使用： for(auto x : array){} 5.5 循环和文本输入 文本输入，需要选取某个特殊字符——哨兵字符(sentinel character)，将其作为停止标记 使用cin.get(char)可以吸收空格，但单cin不行 如果输入来自文件，则可以使用一种更强大的技术——检测文件尾(EOF)，C++输入工具和操作系统协同工作，来检测文件尾并将这种信息告知程序 检测到EOF后，cin将两位(eofbit和failbit)都设置为1。可以通过成员函数eof()来查看eofbit是否被设置；如果检测到EOF,则cin.eof()将返回bool值true，否则返回false。同样，如果eofbit或failbit被设置为1,则fail()成员函数返回true，否则返回false。注意，eof()和fail()方法报告最近读取的结果；也就是说，它们在事后报告，而不是预先报告。因此应将cin.eof()或cin.fail()测试放在读取后，程序清单5.18中的设计体现了这一点。它使用的是fail(),而不是eof(),因为前者可用于更多的实现中。ctrl + z 和Enter可以模拟文件的EOF(不同环境会有所不同，我的windows是可以的) #include&lt;iostream&gt;using namespace std;int main(){ char ch; cin.get(ch); int count = 0; while (cin.fail() == false) { cout &lt;&lt; ch; ++count; cin.get(ch); } cout &lt;&lt; endl &lt;&lt; count;} 方法cin.get(char)的返回值是一个cin对象。然而，istream类提供了一个可以将istream对象（如cin)转换为bool值的函数：当cin出现在需要bool值的地方（如在while循环的测试条件中）时，该转换函数将被调用。另外，如果最后一次读取成功了，则转换得到的bool值为true:否则为false。这意味着可以将上述while测试改写为这样：while(cin)。这比!cin.fail()或!cin.eof()更通用，因为它可以检测到其他失败原因，如磁盘故障。 #include&lt;iostream&gt;using namespace std;int main(){ char ch; int count = 0; while (cin.get(ch)) { cout &lt;&lt; ch; ++count; } cout &lt;&lt; endl &lt;&lt; count;} 可以使用int ch,并用cin.get()代替cin.get(char),用cout.put()代替cout,用EOF测试代替cin.fail()测试： #include&lt;iostream&gt;using namespace std;int main(){ int ch; int count = 0; ch = cin.get(); while (ch != EOF) { cout.put(ch);//cout.put(char(ch)) 对一些实现需要强制类型转换 ++count; ch = cin.get(); } cout &lt;&lt; endl &lt;&lt; count;} 使用cin.get(ch)更符合对象方式5.6 嵌套循环和二维数组 在输出中使用制表符比使用空格可使数据排列更有规则。（跟本节内容好像没啥关系，不过这节确实没啥内容）" }, { "title": "C++ Primer Plus-第4章 复合类型", "url": "/posts/C++-Primer-Plus-%E7%AC%AC4%E7%AB%A0-%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B/", "categories": "C++, C++ Primer Plus", "tags": "学习笔记", "date": "2022-10-09 09:25:00 +0000", "snippet": "    今天看了看复合类型，并不难，我发现每天看完C++都比前一天晚一会，今天快五点半才看完，昨天看到5点。而且这几天都没看games101了TWT，昨晚打了一晚上三国杀，但当内奸赢了一把很爽就是了。    第四章比较长，分两天看完吧。    没想到最后是花了三天，10号差几页没看完，11号课比较多，一点没看，拖到了12号……4.1 数组 sizeof运算符返回类型或数据对象的长度...", "content": "    今天看了看复合类型，并不难，我发现每天看完C++都比前一天晚一会，今天快五点半才看完，昨天看到5点。而且这几天都没看games101了TWT，昨晚打了一晚上三国杀，但当内奸赢了一把很爽就是了。    第四章比较长，分两天看完吧。    没想到最后是花了三天，10号差几页没看完，11号课比较多，一点没看，拖到了12号……4.1 数组 sizeof运算符返回类型或数据对象的长度（单位为字节）。用于数组名，得到的是整个数组的字节数，用于数组元素，则是元素的长度 {}初始化 {}初始化列表只能用于数组初始化，不能用于后续赋值 如果使用{}初始化数组的一部分，那么编译器会把其他元素设置为0 c++11使用{}： 可以省略= {}不包含内容，则所有元素设置为0 列表初始化禁止缩窄转换 4.2 字符串 C++两种处理字符串方式：C风格字符串、string类库 C风格字符串： 存储在char数组中 以空字符结尾，\\0，ASCII码为0 可以用字符串常量来初始化char数组，比如\"abc\"，\\0会自动加到结尾，如果还有空余位置，会自动设置为\\0 有时候，字符串很长，无法放到一行中。C++允许拼接字符串字面值，即将两个用引号括起的字符串合并为一个。事实上，任何两个由空白（空格、制表符和换行符）分隔的字符串常量都将自动拼接成一个。 面向行的输入： getline()，通过回车键输入的换行符来确定输入结尾 cin.getline(name,20)数组名，要读取的字符数（最多读取的数目，数组其余位置添加空字符） get()，与getline相似，唯一的不同是不再读取并丢弃换行符，而是留在输入队列中，所以需要额外使用一次get()来吸收换行符 cin.get(name,20) 可以连续get或getline（因为函数会返回一个cin对象） cin.get(name,20).get();//有点酷，因为外行可能看不懂哈哈 get的优点： get使输入更精准，使用get可以知道停止读取的原因是由于读取了整行还是已经填满，只需要查看下一个输入字符是否为换行符。但getline因为会自动吸收换行符，所以无论如何，下一个输入字符都不会是换行符 空行问题，cin读取字符串后，会把回车键生成的换行符留在输入队列，导致后面的getline或者get会认为是一个空行，所以会把空字符串赋给数组 4.3 string类简介 使用string类时，某些操作比数组简单： 不能将一个数组赋给另一个数组，但可以将一个string对象赋给另一个string对象 简化字符串合并，使用+ getline的不同用法： cin.getline(charr,10)函数时istream类的一个类方法（cin是istream的一个对象） getline(cin,str)，string的用法，说明函数不是类方法 其他形式字符串字面值：wchar_t、char16_t、char32_t，C++分别使用前缀L、u、U来表示 wchar_t title[] = L\"abc def\"; C+11还支持Unicode字符编码方案UTF-8。:在这种方案中，根据编码的数字值，字符可能存储为1~4个八位组。C++使用前缀u8来表示这种类型的字符串字面值。 C++11新增的另一种类型是原始(raw)字符串。在原始字符串中，字符表示的就是自己。 cout&lt;&lt;R\"(Jim\"King\" Tutt uses \"\\n\" instead of endl.)\" 输入原始字符串时，按回车键不仅会移到下一行，还将在原始字符串中添加回车字符。 如果想打印)\"呢？只需要在\"和(之间添加其他字符，当然结尾处也要加，相当于使用新的一个字符串来表示开头和结尾，比如R\"+*(表示开头，)+*\"表示结束 4.4 结构简介 结构是C++OOP堡垒（类）的基石 C++11结构使用{}初始化 等号可选 不包含内容则所有成员设置成0 不允许缩窄 可以使用赋值运算符=将结构赋给另一个同类型的结构 4.5 共用体 共用体(union)是一种数据格式，它能够存储不同的数据类型，但只能同时存储其中的一种类型。也就是说：结构可以同时存储int、long和double，共用体只能存储int、long或double。所以，共用体的长度为其最大成员的长度 用途之一：当数据项使用两种或更多种格式（但不会同时使用）时，可节省空间。 匿名共用体(anonymous union)没有名称，其成员将成为位于相同地址处的变量。显然，每次只有二个成员是当前的成员 共用体通常用于（但并非只能用于）节省内存 4.6 枚举 enum spectrum {red,orange,yellow,green,blue,violet,indigo,ultraviolet}; 让spectrum成为新类型的名称；spectrum被称为枚举(enumeration)，就像struct变量被称为结构一样。 将red、orange、yellow等作为符号常量，它们对应整数值0~7。这些常量叫作枚举量(enumerator).在默认情况下，将整数值赋给枚举量，第一个枚举量的值为0，第二个枚举量的值为1，依次类推。 在不进行强制类型转换的情况下，只能将枚举量赋给枚举的变量，不能直接赋值数字 强制类型转换：band = spectrum(3)，如果数字越界，结果不确定，不会出错，但不能依赖得到的结果 设置枚举量的值： 可以显式地直接赋值：enum bits{one =1,two= 2,four =4,eight =8}; 指定的值必须事整数，也可以只显式地定义其中一些枚举量的值：enum bigstep{first,second =100,third}; 后面没被初始化的枚举量的值将比前面的大1 可以创建多个值相同的枚举量：enum{zero,null= 0,one,numero_uno= 1}; 枚举的取值范围： 上限：找到大于最大值的、最小的2的幂，减1：101的上限就是127（128-1） 下限：同上限：-6的下限-7（-（8-1）） 4.7 指针和自由存储空间 显示地址时，cout使用16进制表示法，因为这是常用于描述内存的表示法，我在我vs试了下，不是十六进制表示法，是十进制，有些系统不会把两个变量存储在相邻的内存单元中，比如我的 面向对象编程与传统的过程性编程的区别在于，OOP强调的是在运行阶段（而不是编译阶段）进行决策 *运算符被称为间接值（indirect value）或解除引用（dereferencing）运算符 在C++中，int*是一种复合类型，是指向int的指针 C++中创建指针时，计算机只会分配用来存储地址的内存，但不会分配用来存储指针所指向的数据的内存，为数据提供空间是一个独立的步骤。下面这个例子是危险的： long* fellow;*fellow = 23333; 指针不是整型，C++不循序将数字值赋给指针，但可以使用强制类型转换，如：int* p = (int*)0xB80000000 int* pn = new it;pn指向了一个数据对象，指的是为数据项分配的内存块而不是OOP中的对象，虽然不如变量好用，但它使程序在管理内存方面有更大的控制权 double* p = new double；*p = 0.1；中，sizeof(p)为指针的大小，为4，sizeof(*p)为double的大小，为8 变量存储在栈，而new从被称为堆或自由存储区的内存区域分配内存（后面第9章会详细介绍） 内存耗尽，new会引发异常 delete指针不会删除指针p本身，而是释放其指向的内存 不要尝试释放已经释放的内存，不能使用delete释放声明变量所获得的内存如：int jugs = 5;int* p=&amp;jugs;不能delete这个p delete是通过new的内存块的地址来删的，不是指针这个变量，多个指针可能指向同一个内存块，也就是说多个指针变量存储的地址相同，所以delete其中任何一个都会删除内存块 对于大型数据，应使用new，这正是new的用武之地！ 动态数组： 在编译时给数组分配内存被称为静态联编（static binding）。但使用new时，如果在运行阶段需要数组，则创建它，不需要就不创建，还可以在程序运行时选择长度，这杯称作静态联编（dynamic binding）。这种数组称为动态数组。 使用new创建动态数组： int* psome = new int[10];delete []psome; new和delete的规则 不要使用delete来释放不是new分配的内存 不要使用delete释放同一个内存块两次 如果使用new[]为数组分配内存，则应使用delete[]来释放 如果使用new为一个实体分配内存，则应使用delete(没有方括号)来释放 对空指针应用delete是安全的。 4.8 指针、数组和指针算术 指针和数组基本等价的原因在于指针算术（pointer arithmetic）和C++内部处理数组的方式。指针变量加1后，增加的量等于它指向的类型的字节数。比如指向double的指针+1后，则数值会+8（如果系统对double使用8个字节存储） 自动存储、静态存储和动态存储 自动存储： 在函数内部定义的常规变量使用自动存储空间被称为自动变量(automatic variable),这意味着它们在所属的函数被调用时自动产生，在该函数结束时消亡。 自动变量通常存储在栈中。这意味着执行代码块时，其中的变量将依次加入到栈中，而在离开代码块时，将按相反的顺序释放这些变量 静态存储： 静态存储是整个程序执行期间都存在的存储方式。使变量成为静态的方式有两种：一种是在函数外面定义它；另一种是在声明变量时使用关键字static：static double a = 0.1; 自动存储和静态存储的关键在于：这些方法严格地限制了变量的寿命。变量可能存在于程序的整个生命周期（静态变量），也可能只是在特定函数被执行时存在（自动变量） 动态存储： new和delete运算符提供了一种比自动变量和静态变量更灵活的方法。它们管理了一个内存池，这在C++中被称为自由存储空间(free store)或堆(heap)。该内存池同用于静态变量和自动变量的内存是分开的。 4.9 类型组合 其实就是说数组、结构、指针可以组合使用4.10 数组的替代品 模板类vector和array是数组的替代品 模板类vector 模板类vector类似于string类，也是一种动态数组。您可以在运行阶段设置vector对象的长度，可在末尾附加新数据，还可在中间插入新数据。基本上，它是使用new创建动态数组的替代品。实际上，vector类确实使用new和delete来管理内存，但这种工作是自动完成的。存放在自由存储区或堆 模板类array(C++11) vector类的功能比数组强大，但付出的代价是效率稍低。如果您需要的是长度固定的数组，使用数组是更佳的选择，但代价是不那么方便和安全。有鉴于此，C+11新增了模板类array,它也位于名称空间std中。与数组一样，array对象的长度也是固定的，也使用栈（静态内存分配），而不是自由存储区，因此其效率与数组相同，但更方便，更安全 array&lt;typename, n_elem&gt; arr;：n_elem不能是变量，C++11中可以对vector和array使用列表初始化，C++98不能对vector使用 array可以将一个array对象赋给另一个array对象，但数组不行，只能逐元素复制 vector和array使用at()可以在运行期间捕获非法索引，程序默认将中断，代价就是运行时间更长 " }, { "title": "C++ Primer Plus-第3章 处理数据", "url": "/posts/C++-Primer-Plus-%E7%AC%AC3%E7%AB%A0-%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE/", "categories": "C++, C++ Primer Plus", "tags": "学习笔记", "date": "2022-10-08 09:05:00 +0000", "snippet": "    这一章内容还蛮多的，虽然就三十页，但看了挺久，介绍了一些C++中基础的变量，算是复习复习，巩固下基础吧。3.1 简单变量 C++命名规则（我之前不清楚的）： 以两个下划线或下划线和大写字母打头的名称被保留给实现使用（编译器及其使用的资源）。 以一个下划线开头的名称被保留给实现，用作全局标识符 ...", "content": "    这一章内容还蛮多的，虽然就三十页，但看了挺久，介绍了一些C++中基础的变量，算是复习复习，巩固下基础吧。3.1 简单变量 C++命名规则（我之前不清楚的）： 以两个下划线或下划线和大写字母打头的名称被保留给实现使用（编译器及其使用的资源）。 以一个下划线开头的名称被保留给实现，用作全局标识符 C++对于名称长度没有限制（ANSI C(C99标准)有限制，只保证前63个字符有意义） C++整型长度： char 8位 short至少16位 int至少与short一样长（IBM PC 16位；Windows 32位） long至少32位，且至少与int一样长 long long 至少64位，且至少与long一样长 字节的含义通常指8位的内存单元，然而C++对字节的定义与此不同。C++字节由至少能够容纳实现的基本字符集的相邻位组成，也就是说可能取值的数目必须大于等于字符数目。ASCII码可以用8位，但Unicode需要16位，还有的甚至32位来表示一个字节。 climits头文件中包含类似#define INT_MAX 32767的语句行(我试了下，打印的是2147483647，不知道为啥)。define和include一样，都是预处理器编译指令。#define编译指令的工作方式与文本编辑器或字处理器中的全局搜索并替换命令相似。修改后的程序将在完成替换后被编译。（其实define是C的，c++用const比较好） C++初始化 int a = 0;int a(0); C++11 可以使用=也可以不用 可以不包含任何东西 有助于更好地防范类型转换错误 int a{1};int a = {1};int a = {};//初始化为0int a{}; 如果知道变量可能表示的整数值大于16位整数的最大可能值，则使用long，即使系统上int为32位，也应该这样做。这样当程序移植到16位系统时，就不会突然无法正常工作。 如果要以16进制或8进制显示值，需要利用cout int a = 42;cout&lt;&lt;dec;//10cout&lt;&lt;a;cout&lt;&lt;hex;//16cout&lt;&lt;a;cout&lt;&lt;cot;//8cout&lt;&lt;a; 常量类型会根据后缀L、LL等或者大小来确定 有趣的是，程序中输入的是M,而不是对应的字符编码77。，另外，程序将打印M,而不是77。通过查看内存可以知道，77是存储在变量ch中的值：这种神奇的力量不是来自char类型，而是来自cin和cout这些工具为您完成了转换E作。输入时，cin将键盘输入的M转换为77：输出时，cout将值77.转换为所显示的字符M:cin和cout的行为都是由变量类型引导的。 C++转义序列编码： char在默认情况下既不是没有符号，也不是有符号。是否有符号由C++实现决定 wchar_t（宽字符类型）可以表示扩展字符集 C++11新增类型：char16_t和char32_t都是无符号的 任何数字值或指针值都可以被隐式转换为bool值。任何非零值被转换为true，零被转换为false 3.2 const 限定符 比define的优点： 能够明确指定类型 可以使用C++的作用域规则将定义限制在特定的函数或文件中 可以将const用于更复杂的类型，如数组和结构 3.3 浮点数 书写浮点数方式： 标准小数点表示法 E表示法：适合非常大的数和非常小的数，数字中不能有空格 2.52e+8 8.33e-4 7E5 浮点类型有效位： float：至少32位，通常32位（这里的位指的是二进制位数，也就是有32个01） double：至少48位，且不少于float，通常64位（这里的位指的是二进制位数，也就是有32个01） long double：至少和double一样多，通常为80、96、128位（这里的位指的是二进制位数，也就是有32个01） 指数范围至少是-37到37 folat至少有6位有效位，double至少15位有效位（这里的有效位指的是10进制的，6位和15位） 浮点常量，默认为double，如果希望存float就加f或F后缀，如果希望存long double，就加l或L后缀 3.4 C++算术运算符 *、/、%优先级高于+、- 以{}方式初始化时，不允许缩窄（narrowing），比如不能把浮点数初始化给整型类型的变量 整型提升：在计算表达式时，C++将bool, char, unsigned char, signed char, short转换为int 当运算涉及两种类型时，较小的类型被转换为较大的类型 强制类型转换不会修改变量本身，而是创建一个新变量 typename(value)//为C++格式，让强制类型转换像是函数调用 static_cast&lt;&gt;可以将值从一种数值类型转换为另一种数值类型，例如：static_cast&lt;long&gt;(thorn)，将thorn转换成long类型 " }, { "title": "C++ Primer Plus-第2章 开始学习C++", "url": "/posts/C++-Primer-Plus-%E7%AC%AC2%E7%AB%A0-%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0C++/", "categories": "C++, C++ Primer Plus", "tags": "学习笔记", "date": "2022-10-07 09:00:00 +0000", "snippet": "    感觉这章没啥要记的，基本都知道……2.1 进入C++ 形参列表：argument list（gamemaker里面函数参数就用的argument来表示）；参数列表：parameter list main函数： 被启动代码调用，启动代码是由编译器添加到程序中的，是程序和操作系统之间的接口 预处理器：处理以#开头的编译指令—...", "content": "    感觉这章没啥要记的，基本都知道……2.1 进入C++ 形参列表：argument list（gamemaker里面函数参数就用的argument来表示）；参数列表：parameter list main函数： 被启动代码调用，启动代码是由编译器添加到程序中的，是程序和操作系统之间的接口 预处理器：处理以#开头的编译指令——在源代码被编译之前按，替换或添加文本 名称空间： 名称空间让厂商能够将其产品封装在一个角坐名称空间的单元中，这样可以使用名称空间的名称来指出想使用哪个厂商的产品，避免不同厂商相同名字函数的混淆。 头文件没有h才能使用名称空间 2.2 C++语句 声明变量2.3 其他C++语句 类是用户定义的一种数据类型2.4 函数 函数原型和函数定义：原型其实就是函数名，定义就是函数体" }, { "title": "C++ Primer Plus-第1章 预备知识", "url": "/posts/C++-Primer-Plus-%E7%AC%AC1%E7%AB%A0-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/", "categories": "C++, C++ Primer Plus", "tags": "学习笔记", "date": "2022-10-07 05:30:00 +0000", "snippet": "    距离上次记录博客竟然已经过去了整整20天，其实前面有在复习专业课啦，最终还是如愿通过了浙软的面试，拿到offer了，保完属于是狠狠地开摆了，玩了一整个国庆，该收收心继续学了，10月剩下二十多天了，计划看看这本书，大概率看不完，希望能看个2/3吧，这个月的其他时间把GAMES101看完，打算从头看，笔记整理整理。    由于课程基本转线下了，大概率也没办法出去实习了，就老老实实在学校看...", "content": "    距离上次记录博客竟然已经过去了整整20天，其实前面有在复习专业课啦，最终还是如愿通过了浙软的面试，拿到offer了，保完属于是狠狠地开摆了，玩了一整个国庆，该收收心继续学了，10月剩下二十多天了，计划看看这本书，大概率看不完，希望能看个2/3吧，这个月的其他时间把GAMES101看完，打算从头看，笔记整理整理。    由于课程基本转线下了，大概率也没办法出去实习了，就老老实实在学校看书吧TWT1.1 C++简介 融合三种编程方式： C过程性语言 面向对象语言 C++模板支持的泛型编程 1.2 C++简史 低级语言直接操作硬件，高级语言致力于解决问题，而不针对特定的硬件 一般来说，计算机语言要处理两个概念：数据和算法 C语言： 融合低级语言的效率以及硬件访问能力和高级语言的通用性、可移植性 强调算法 结构化编程：for、while、if else 原则：自顶向下 OOP面向对象 强调数据 将数据和方法合并为类；创建可重用代码；信息隐藏；多态 原则：自下向上（其实也有自上而下） 泛型编程 创建独立于类型的代码 1.3 可移植性和标准 可移植性两个障碍：硬件、语言的差异 国际标准：ISO/IEC 1.4 程序创建的技巧 编写源代码 编译源代码为目标代码 目标代码与其他代码链接起来 得到可执行代码 " }, { "title": "PAT-The Missing Number & Chain the Ropes & Eulerian Path & ZigZagging on a Tree", "url": "/posts/PAT-The-Missing-Number-&-Chain-the-Ropes-&-Eulerian-Path-&-ZigZagging-on-a-Tree/", "categories": "算法刷题, PAT", "tags": "双指针, 哈夫曼树, 欧拉图, 二叉树的遍历, 树的构造", "date": "2022-09-17 07:30:00 +0000", "snippet": "    今天又做了一套模拟题，前三道题花了不到50分钟，但第三道题只拿了19/25分，没继续想，继续往下做了，花了二十多分钟就把最后一题写完了，1h10min的分数为94，接着回过头去想第3题，又写了20min通过了。    本日战绩：1h30min 100分。    后天就要考试了，明天就不刷题了，就复习复习做过的题目吧。A1144 The Missing Number#include&l...", "content": "    今天又做了一套模拟题，前三道题花了不到50分钟，但第三道题只拿了19/25分，没继续想，继续往下做了，花了二十多分钟就把最后一题写完了，1h10min的分数为94，接着回过头去想第3题，又写了20min通过了。    本日战绩：1h30min 100分。    后天就要考试了，明天就不刷题了，就复习复习做过的题目吧。A1144 The Missing Number#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;using namespace std;int n, tmp;vector&lt;int&gt; l;int main(){\tcin &gt;&gt; n;\tfor (int i = 0; i &lt; n; i++)\t{\t\tscanf(\"%d\", &amp;tmp);\t\tif (tmp &gt; 0) l.emplace_back(tmp);\t}\tsort(l.begin(), l.end());\tif (l.size() == 0) cout &lt;&lt; 1;\telse if (l[0] &gt; 1) cout &lt;&lt; 1;\telse\t{\t\tbool flag = true;\t\tfor (int i = 0; i &lt; l.size() - 1; i++)\t\t{\t\t\tif (l[i + 1] &gt; l[i] + 1)\t\t\t{\t\t\t\tcout &lt;&lt; l[i] + 1;\t\t\t\tflag = false;\t\t\t\tbreak;\t\t\t}\t\t}\t\tif (flag) cout &lt;&lt; l.back() + 1;\t}}    算双指针吗？有点像又不太像，需要注意一种情况就是，整个序列是连续的，那么缺少的最小值就是最后一个值+1。A1125 Chain the Ropes#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;int n;double tmp;priority_queue&lt;double, vector&lt;double&gt;, greater&lt;double&gt;&gt; q;int main(){\tcin &gt;&gt; n;\tfor (int i = 0; i &lt; n; i++)\t{\t\tcin &gt;&gt; tmp;\t\tq.push(tmp);\t}\twhile (q.size() &gt; 1)\t{\t\tdouble t1 = q.top();\t\tq.pop();\t\tdouble t2 = q.top();\t\tq.pop();\t\tq.push((t1 + t2) / 2);\t}\tint l = (int)q.top();\tcout &lt;&lt; l;}    简单的哈夫曼树题，就是带权路径最小的树，直接用小顶堆即可。A1126 Eulerian Path#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;const int maxn = 501;int n, m, u, v, degree[maxn], oddcnt, notconnect, connectcnt;bool isVis[maxn];vector&lt;vector&lt;int&gt;&gt; neighbor(maxn);void dfs(int s){\tif (s &gt; n) return;\tisVis[s] = true;\tconnectcnt++;\tfor (int n : neighbor[s])\t{\t\tif (!isVis[n])\t\t{\t\t\tdfs(n);\t\t}\t}}int main(){\tcin &gt;&gt; n &gt;&gt; m;\tfor (int i = 0; i &lt; m; i++)\t{\t\tcin &gt;&gt; u &gt;&gt; v;\t\tdegree[u]++;\t\tdegree[v]++;\t\tneighbor[u].emplace_back(v);\t\tneighbor[v].emplace_back(u);\t}\tfor (int i = 1; i &lt;= n; i++)\t{\t\tif (i != 1) cout &lt;&lt; ' ';\t\tcout &lt;&lt; degree[i];\t\tif (degree[i] % 2 == 1) oddcnt++;\t}\tdfs(1);\tif(connectcnt != n) notconnect = 1;\tcout &lt;&lt; endl;\tif (notconnect == 0)\t{\t\tif (oddcnt == 0) cout &lt;&lt; \"Eulerian\";\t\telse if (oddcnt == 2) cout &lt;&lt; \"Semi-Eulerian\";\t\telse cout &lt;&lt; \"Non-Eulerian\";\t}\telse cout &lt;&lt; \"Non-Eulerian\";}    判断欧拉环路和欧拉路，正好了解下欧拉图的判别：连通图中， 所有节点的度为偶数，那么就有欧拉环路 有且仅有两个节点的度为奇数，那么就有欧拉路     这道题一开始没拿满，是因为没有判别是否为连通图，dfs一遍就能知道了，后面还有一个点过不去，就是因为，当只有一个节点的时候，我给的结果不是欧拉图，但答案是欧拉环路，蚌。A1127 ZigZagging on a Tree#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;const int maxn = 31;struct node{\tint v, l;\tnode* left, * right;\tnode(int _v) : v(_v), left(nullptr), right(nullptr) {}};int in[maxn], post[maxn], n;vector&lt;vector&lt;int&gt;&gt; levelOrder(maxn);node* build(int inL, int inR, int postL, int postR){\tif (inL &gt; inR) return nullptr;\tnode* n = new node(post[postR]);\tint index;\tfor (int i = inL; i &lt;= inR; i++)\t{\t\tif (in[i] == post[postR])\t\t{\t\t\tindex = i;\t\t\tbreak;\t\t}\t}\tn-&gt;left = build(inL, index - 1, postL, postL + index - 1 - inL);\tn-&gt;right = build(index + 1, inR, postR - inR + index, postR - 1);\treturn n;}void travelsal(node* root, int level){\tif (root == nullptr) return;\troot-&gt;l = level;\ttravelsal(root-&gt;left, level + 1);\ttravelsal(root-&gt;right, level + 1);}int main(){\tcin &gt;&gt; n;\tfor (int i = 0; i &lt; n; i++) cin &gt;&gt; in[i];\tfor (int i = 0; i &lt; n; i++) cin &gt;&gt; post[i];\tnode* root = build(0, n - 1, 0, n - 1);\ttravelsal(root, 1);\tqueue&lt;node*&gt; q;\tq.push(root);\twhile (!q.empty())\t{\t\tnode* n = q.front();\t\tq.pop();\t\tlevelOrder[n-&gt;l].emplace_back(n-&gt;v);\t\tif (n-&gt;left)q.push(n-&gt;left);\t\tif (n-&gt;right)q.push(n-&gt;right);\t}\tvector&lt;int&gt; ans;\tfor (int i = 1; i &lt;= 30 ; i++)\t{\t\tif (levelOrder[i].size() == 0) break;\t\tif (i % 2 == 1)\t\t{\t\t\tfor (int j = levelOrder[i].size() - 1; j &gt;= 0; j--)\t\t\t{\t\t\t\tans.emplace_back(levelOrder[i][j]);\t\t\t}\t\t}\t\telse\t\t{\t\t\tfor (int j = 0; j &lt; levelOrder[i].size(); j++)\t\t\t{\t\t\t\tans.emplace_back(levelOrder[i][j]);\t\t\t}\t\t}\t}\tfor (int i = 0; i &lt; ans.size(); i++)\t{\t\tif (i != 0) cout &lt;&lt; ' ';\t\tcout &lt;&lt; ans[i];\t}}    就是一简单的建树、遍历，虽然它说不简单，但实际上就多一步存储节点罢了，仍然很简单，昨天那道树的构造确实不简单，昨天那个写了一个小时，今天这个就20分钟。" }, { "title": "PAT-Friend Numbers & Damn Single & Hamiltonian Cycle & Pre- and Post-order Traversals", "url": "/posts/PAT-Friend-Numbers-&-Damn-Single-&-Hamiltonian-Cycle-&-Pre-and-Post-order-Traversals/", "categories": "算法刷题, PAT", "tags": "模拟, 哈希表, 哈密顿图, 二叉树的遍历, 树的构造", "date": "2022-09-16 08:07:00 +0000", "snippet": "    昨天发现浙软通知19号下午1点半到3点半机试，还是用OMS考，剩下三天，每天这个点刷一套题吧。    今天1点半准时开始，前三道题50分钟就写完了，心想还挺简单，做最后一题就不这么想了，最后一题开始写了1小时10分钟，对了26分，差4分，后来又改了8分钟，拿满了，也就是说，今日战绩：2h18min 100分。A1120 Friend Numbers#include&lt;iostre...", "content": "    昨天发现浙软通知19号下午1点半到3点半机试，还是用OMS考，剩下三天，每天这个点刷一套题吧。    今天1点半准时开始，前三道题50分钟就写完了，心想还挺简单，做最后一题就不这么想了，最后一题开始写了1小时10分钟，对了26分，差4分，后来又改了8分钟，拿满了，也就是说，今日战绩：2h18min 100分。A1120 Friend Numbers#include&lt;iostream&gt;using namespace std;int id[40], n, cnt;int main(){ cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) { int num, sum = 0; cin &gt;&gt; num; while (num != 0) { sum += (num % 10); num /= 10; } id[sum]++; } for (int i : id) { if (i != 0) cnt++; } cout &lt;&lt; cnt &lt;&lt; endl; bool flag = false; for (int i = 0; i &lt; 40; i++) { if (id[i] &gt; 0) { if (flag) { cout &lt;&lt; ' '; } cout &lt;&lt; i; flag = true; } }}    简单的模拟。A1121 Damn Single#include&lt;iostream&gt;#include&lt;unordered_map&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;set&gt;using namespace std;const int maxn = 100000;int come[maxn], n, m, p, q;unordered_map&lt;int, int&gt; cp;set&lt;int&gt; single;vector&lt;int&gt; allPeople;int main(){ cin &gt;&gt; n; while (n--) { cin &gt;&gt; p &gt;&gt; q; cp[p] = q; cp[q] = p; } cin &gt;&gt; m; while (m--) { cin &gt;&gt; p; allPeople.emplace_back(p); come[p] = 1; } for (int i = 0; i &lt; allPeople.size(); i++) { if (!cp.count(allPeople[i]) || come[cp[allPeople[i]]] == 0) { single.insert(allPeople[i]); } } printf(\"%d\\n\", single.size()); for (auto i = single.begin(); i != single.end(); i++) { if (i != single.begin()) printf(\" \"); printf(\"%05d\", *i); }}    哈希表，其实想考排序，但我直接用set了，规避掉了排序。注意要打印五位id，不然有一个测试点过不去（竟然就只有一个）。A1122 Hamiltonian Cycle#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;unordered_map&gt;using namespace std;const int maxn = 201;int N, m, k, n, edge[maxn][maxn], u, v, i;int main(){ cin &gt;&gt; N &gt;&gt; m; while (m--) { cin &gt;&gt; u &gt;&gt; v; edge[u][v] = edge[v][u] = 1; } cin &gt;&gt; k; while (k--) { cin &gt;&gt; n; if (n != (N + 1)) { cout &lt;&lt; \"NO\" &lt;&lt; endl; string s; getline(cin, s); continue; } vector&lt;int&gt; vertex(n); unordered_map&lt;int, int&gt; map; for ( i = 0; i &lt; n; i++) { cin &gt;&gt; vertex[i]; map[vertex[i]]++; } if (vertex.front() != vertex.back() || map.size() &lt; N) { cout &lt;&lt; \"NO\" &lt;&lt; endl; continue; } for ( i = 0; i &lt; n - 1; i++) { if (edge[vertex[i]][vertex[i + 1]] == 0) break; } if (i == n - 1) cout &lt;&lt; \"YES\" &lt;&lt; endl; else cout &lt;&lt; \"NO\" &lt;&lt; endl; }}    判断是否为哈密顿图，哈密顿图是每个节点都经过一次最后返回原点的圈。又犯了老毛病，开始判断节点不是N+1后直接continue了，这样是不对的，后面节点的信息没有读取，会影响下一条路的判断。所以要用getline给吸收掉。A1119 Pre- and Post-order Traversals#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int n, pre[30], post[30];vector&lt;int&gt; in;struct node{ int v; node* left = nullptr, * right = nullptr; node(int _v) : v(_v) {}};bool flag = true;node* build(int preL, int preR, int postL, int postR){ if (preL &gt; preR) return nullptr; node* n = new node(pre[preL]); if (preL == preR) return n; if (pre[preL + 1] == post[postR - 1]) { flag = false; n-&gt;left = build(preL + 1, preR, postL, postR - 1); return n; } int postLR, preRL = -1; for (int i = postL; i &lt;= postR ; i++) { if (pre[preL + 1] == post[i]) { postLR = i; break; } } for (int i = preL; i &lt;= preR; i++) { if (pre[i] == post[postR - 1]) { preRL = i; break; } } n-&gt;left = build(preL + 1, preRL - 1, postL, postLR); n-&gt;right = build(preRL, preR, postLR + 1, postR - 1); return n;}void inorder(node* root){ if (root == nullptr) return; inorder(root-&gt;left); in.emplace_back(root-&gt;v); inorder(root-&gt;right);}int main(){ cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; pre[i]; } for (int i = 0; i &lt; n; i++) { cin &gt;&gt; post[i]; } node* root; root = build(0, n - 1, 0, n - 1); if (flag) cout &lt;&lt; \"Yes\" &lt;&lt; endl; else cout &lt;&lt; \"No\" &lt;&lt; endl; inorder(root); for (int i = 0; i &lt; in.size(); i++) { if (i != 0) cout &lt;&lt; ' '; cout &lt;&lt; in[i]; } cout &lt;&lt; endl;}    这道题挺复杂，给前序和后序，要建一棵树，但这棵树有可能不是唯一的，什么时候不唯一呢，就是当要建当前节点的左右子树时，发现前序数组的pre[preL + 1]等于后序数组的post[postR - 1]时，此时，既可以建造根节点值为pre[preL + 1]的pre[preL]的左子树或者建造右子树（这里有点绕），我统一建成了左子树。    一开始没拿满分是因为我以为只有像样例2那样，最后剩两个节点了，才会出现不唯一的情况。PAT数据确实挺照顾人的，就一个测试点不是剩两个节点。" }, { "title": "晴问-合并果子 & 最小前缀编码长度", "url": "/posts/%E6%99%B4%E9%97%AE-%E5%90%88%E5%B9%B6%E6%9E%9C%E5%AD%90-&-%E6%9C%80%E5%B0%8F%E5%89%8D%E7%BC%80%E7%BC%96%E7%A0%81%E9%95%BF%E5%BA%A6/", "categories": "算法刷题", "tags": "哈夫曼树", "date": "2022-09-10 04:22:00 +0000", "snippet": "    昨天上午有课，失策了，今天把哈夫曼树看了，没想到算法笔记里的哈夫曼树只是一笔带过了，并不难，今天就到此为止了哈哈，回去背专业课了，明天看看字符串hash和kmp算法（kmp算法之前在力扣刷过，相当于复习了）合并果子#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;queue&gt;using namespace std...", "content": "    昨天上午有课，失策了，今天把哈夫曼树看了，没想到算法笔记里的哈夫曼树只是一笔带过了，并不难，今天就到此为止了哈哈，回去背专业课了，明天看看字符串hash和kmp算法（kmp算法之前在力扣刷过，相当于复习了）合并果子#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;queue&gt;using namespace std;priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;//小顶堆int n, ans, tmp;int main(){\tcin &gt;&gt; n;\twhile (n--)\t{\t\tcin &gt;&gt; tmp;\t\tq.push(tmp);\t}\twhile (q.size() &gt; 1)\t{\t\tint x = q.top();\t\tq.pop();\t\tint y = q.top();\t\tq.pop();\t\tq.push(x + y);\t\tans += x + y;\t}\tcout &lt;&lt; ans;}    哈夫曼树思想的一种实际问题求解，其实没有用到构建树，有点像贪心。使用了小顶堆，非常不错。所谓哈夫曼树就是一棵，n个节点，都为叶子节点，带权路径最短的树。最小前缀编码长度#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;queue&gt;using namespace std;priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;//小顶堆int n, ans, tmp, v[26];int main(){\tstring s;\tcin &gt;&gt; s;\tfor (char c : s)\t{\t\tv[c - 'A']++;\t}\tfor (int i : v)\t{\t\tif (i &gt; 0) q.push(i);\t}\twhile (q.size() &gt; 1)\t{\t\tint x = q.top();\t\tq.pop();\t\tint y = q.top();\t\tq.pop();\t\tq.push(x + y);\t\tans += x + y;\t}\tcout &lt;&lt; ans;}    这道题依旧没有建哈夫曼树，直接用的小顶堆，直接把字母出现次数当作权值即可。" }, { "title": "PAT-Travelling Salesman Problem & Counting Nodes in a Binary Search Tree", "url": "/posts/PAT-Travelling-Salesman-Problem-&-Counting-Nodes-in-a-Binary-Search-Tree/", "categories": "算法刷题, PAT", "tags": "图, 哈希表, BST", "date": "2022-09-08 04:30:00 +0000", "snippet": "    承接昨天的题，做完这两道也就花了一个多小时，最后还剩1小时1分钟，而且四道题都ac了，这套题还是很简单的，明天把哈夫曼树看看，做几道哈夫曼树的题目吧。    得益于昨天背了背c++的基础知识点，全局变量、数组是在编译阶段申请在全局/静态存储区的，如果不初始化的话，会默认赋值成0，数组的全部元素也是0，bool的话是false。    得益于前两看了看柳神的代码，于是我也开始精简代码行...", "content": "    承接昨天的题，做完这两道也就花了一个多小时，最后还剩1小时1分钟，而且四道题都ac了，这套题还是很简单的，明天把哈夫曼树看看，做几道哈夫曼树的题目吧。    得益于昨天背了背c++的基础知识点，全局变量、数组是在编译阶段申请在全局/静态存储区的，如果不初始化的话，会默认赋值成0，数组的全部元素也是0，bool的话是false。    得益于前两看了看柳神的代码，于是我也开始精简代码行数，发现确实能节省不少时间。A1150 Travelling Salesman Problem#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;unordered_map&gt;#include&lt;cstdio&gt;using namespace std;const int maxn = 210, inf = 0x3fffffff;int N, M, k, n, neibghbor[maxn][maxn], u, v, w, mindis = inf, minpath;int main(){ cin &gt;&gt; N &gt;&gt; M; fill(neibghbor[0], neibghbor[0] + maxn * maxn, inf); for (int i = 0; i &lt; M; i++) { cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; neibghbor[u][v] = w; neibghbor[v][u] = w; } cin &gt;&gt; k; for (int i = 1; i &lt;= k; i++) { cin &gt;&gt; n; vector&lt;int&gt; path(n); unordered_map&lt;int, int&gt; map; int tmpdis = 0; bool flag = false; for (int j = 0; j &lt; n; j++) { cin &gt;&gt; path[j]; map[path[j]]++; if (j &gt; 0) { if (neibghbor[path[j]][path[j - 1]] == inf) { flag = true; } else tmpdis += neibghbor[path[j]][path[j - 1]]; } } if (flag) printf(\"Path %d: NA (Not a TS cycle)\\n\", i); else { if (path.front() == path.back() &amp;&amp; map.size() == N) { if(path.size() == N + 1) printf(\"Path %d: %d (TS simple cycle)\\n\", i, tmpdis); else printf(\"Path %d: %d (TS cycle)\\n\", i, tmpdis); if (tmpdis &lt; mindis) { mindis = tmpdis; minpath = i; } } else printf(\"Path %d: %d (Not a TS cycle)\\n\", i, tmpdis); } } printf(\"Shortest Dist(%d) = %d\\n\", minpath, mindis);}    这道题目很简单，但是第一次提交只对了8分，前两个测试点没过，查了下，发现了老错误，我再判断中间有路不连通的时候，直接就break了，但后面很有可能还有节点没有读取，那么就会导致出错，要么就不break，只是改下flag，要么就用getline把剩下的全吸收了。A1115 Counting Nodes in a Binary Search Tree#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;using namespace std;struct node{ int v; node* left = nullptr, * right = nullptr; node(int _v) : v(_v) {}}*Root = nullptr;const int maxn = 10010;int n, lowestl = 0, nodesN[maxn], tmp;void Insert(node*&amp; root, int val){ if (root == nullptr) root = new node(val); else if (val &lt;= root-&gt;v) Insert(root-&gt;right, val); else Insert(root-&gt;left, val);}void travelsal(node* root, int level){ if (root == nullptr) return; nodesN[level]++; if (level &gt; lowestl) lowestl = level; travelsal(root-&gt;left, level + 1); travelsal(root-&gt;right, level + 1);}int main(){ cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; tmp; Insert(Root, tmp); } travelsal(Root, 0); printf(\"%d + %d = %d\", nodesN[lowestl], nodesN[lowestl - 1], nodesN[lowestl] + nodesN[lowestl - 1]);}    亏这道题还30分呢，这么简单，就一建树和遍历，但就这我还debug了会，有两点： 我的insert函数，在当值小于当前节点值时，应当插入左子树，我给写成right了，怪不得一开始是1+1=2的结果 注意insert的形参root，要加引用，不然不会真的把值加在树上的 " }, { "title": "PAT-Werewolf - Simple Version & Dangerous Goods Packaging", "url": "/posts/PAT-Werewolf-Simple-Version-&-Dangerous-Goods-Packaging/", "categories": "算法刷题, PAT", "tags": "模拟, 哈希表", "date": "2022-09-07 04:13:00 +0000", "snippet": "    毕竟刚拿了99，有点小膨胀了，昨天两天都没刷题，在背专业课了，不过手不能生啊，每天做个一两道。    47分钟做完了前两题，第一题做的稍微有点久，花了35分钟才ac。A1148 Werewolf - Simple Version#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;const int max...", "content": "    毕竟刚拿了99，有点小膨胀了，昨天两天都没刷题，在背专业课了，不过手不能生啊，每天做个一两道。    47分钟做完了前两题，第一题做的稍微有点久，花了35分钟才ac。A1148 Werewolf - Simple Version#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;const int maxn = 101;int n, werewolf[maxn],wolfliar, humanliar;int main(){\tcin &gt;&gt; n;\tfor (int i = 1; i &lt;= n; i++)\t{\t\tcin &gt;&gt; werewolf[i];\t}\tfor (int i = 1; i &lt; n; i++)\t{\t\tfor (int j = i + 1; j &lt;= n; j++)\t\t{\t\t\twolfliar = 0, humanliar = 0;\t\t\tfor (int k = 1; k &lt;= n; k++)\t\t\t{\t\t\t\tif (k == i || k == j)//当狼\t\t\t\t{\t\t\t\t\t//说别人是狼\t\t\t\t\tif (werewolf[k] &lt; 0 &amp;&amp; werewolf[k] != -i &amp;&amp; werewolf[k] != -j) wolfliar++;\t\t\t\t\tif(werewolf[k] &gt; 0 &amp;&amp;( werewolf[k] == i || werewolf[k] == -j)) wolfliar++;\t\t\t\t}\t\t\t\telse\t\t\t\t{\t\t\t\t\t//说别人是狼\t\t\t\t\tif (werewolf[k] &lt; 0 &amp;&amp; werewolf[k] != -i &amp;&amp; werewolf[k] != -j) humanliar++;\t\t\t\t\t//说狼是人\t\t\t\t\tif (werewolf[k] &gt; 0 &amp;&amp; (werewolf[k] == i || werewolf[k] == j)) humanliar++;\t\t\t\t}\t\t\t}\t\t\tif ((wolfliar + humanliar == 2) &amp;&amp; wolfliar &gt; 0)\t\t\t{\t\t\t\tcout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; j;\t\t\t\treturn 0;\t\t\t}\t\t}\t}\tcout &lt;&lt; \"No Solution\";}    这个题一开始我理解错了，我开始以为样例1第二行的那个-2意思是2号玩家指控1号玩家为狼，但实际上是1号玩家指控2号玩家为狼，就这搞反了，一开始还拿了8分……A1149 Dangerous Goods Packaging#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;unordered_map&gt;using namespace std;unordered_map&lt;int, vector&lt;int&gt;&gt; neighbor;int n, m, k, g1, g2, g3;int main(){\tcin &gt;&gt; n &gt;&gt; m;\tfor (int i = 0; i &lt; n; i++)\t{\t\tcin &gt;&gt; g1 &gt;&gt; g2;\t\tneighbor[g1].emplace_back(g2);\t\tneighbor[g2].emplace_back(g1);\t}\tfor (int i = 0; i &lt; m; i++)\t{\t\tcin &gt;&gt; k;\t\tunordered_map&lt;int, int&gt; map;\t\tfor (int j = 0; j &lt; k; j++)\t\t{\t\t\tcin &gt;&gt; g3;\t\t\tmap[g3]++;\t\t}\t\tbool flag = false;\t\tfor (auto it = map.begin(); it != map.end(); it++)\t\t{\t\t\tfor (int g : neighbor[it-&gt;first])\t\t\t{\t\t\t\tif (map.count(g))\t\t\t\t{\t\t\t\t\tflag = true;\t\t\t\t\tbreak;\t\t\t\t}\t\t\t}\t\t\tif (flag)\t\t\t{\t\t\t\tcout &lt;&lt; \"No\" &lt;&lt; endl;\t\t\t\tbreak;\t\t\t}\t\t}\t\tif (!flag)cout &lt;&lt; \"Yes\" &lt;&lt; endl;\t}}    就典型的哈希表映射，13min速通。" }, { "title": "PAT-2022年秋季考试-Balloon Popping & The Second Run of Quicksort & Leader of the Opinion Leaders & Pseudo-completeness", "url": "/posts/PAT-2022%E5%B9%B4%E7%A7%8B%E5%AD%A3%E8%80%83%E8%AF%95-Balloon-Popping-&-The-Second-Run-of-Quicksort-&-Leader-of-the-Opinion-Leaders-&-Pseudo-completeness/", "categories": "算法刷题, PAT", "tags": "双指针, 排序, 模拟, 二叉树的遍历, 完全二叉树", "date": "2022-09-04 14:42:00 +0000", "snippet": "    这次考试过程就像过山车，看到题目就有点没底，从59分一点一点蚕食，最终拿到了99分，比以往的模拟考的都要好，属于是超常发挥了哈哈。虽然没能拿满分有点小遗憾（现在我也知道是哪没过了），但99分也蛮不错了，心中有点小窃喜。Balloon Popping#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;con...", "content": "    这次考试过程就像过山车，看到题目就有点没底，从59分一点一点蚕食，最终拿到了99分，比以往的模拟考的都要好，属于是超常发挥了哈哈。虽然没能拿满分有点小遗憾（现在我也知道是哪没过了），但99分也蛮不错了，心中有点小窃喜。Balloon Popping#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;const int maxl = 2000001;const int maxn = 100001;int n, h, co[maxn],predix[maxn],maxb = 1, minpos;int l, r;int main(){ cin &gt;&gt; n &gt;&gt; h; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; co[i]; } if (n == 1) { cout &lt;&lt; co[0] - h &lt;&lt; ' ' &lt;&lt; 1; return 0; } l = 0, r = 1; while (r &lt; n &amp;&amp; l &lt; r) { while (r &lt; n &amp;&amp; co[r] - co[l] &lt;= h ) { r++; } if (co[r] - co[l] &gt; h) { if (r - l &gt; maxb) { maxb = r - l; minpos = co[r-1] - h; } } else if (r == n &amp;&amp; co[r] - co[l] &lt;= h) { if (r - l + 1&gt; maxb) { maxb = r - l + 1; minpos = co[r - 1] - h; } } l++; } cout &lt;&lt; minpos &lt;&lt; ' ' &lt;&lt; maxb;}    这道题一开始我用的暴力算法，直接挨个查，只过了第一个点，12分，剩下的不是答案错误就是超时，后来我在想可以倒过来再查一遍，果然，又拿了1分。最后写完后三道题后，又回来想办法，最后剩十几分钟的时候，想到了双指针法，赶紧实现，最后拿了19/20分，差一个测试点没过，我晚上洗澡的时候突然就想到了，是只有一个气球的情况没考虑，因为我的r是从1开始算的，虽然我的最大气球数量默认是1，但距离就得是第一个坐标减去身高了。The Second Run of Quicksort#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;using namespace std;const int maxn = 100010;vector&lt;int&gt; sequence;int maxL, minR, cnt, k, n, tmp;bool bigger[maxn];bool pivot[maxn];int main(){ cin &gt;&gt; k; while (k--) { scanf(\"%d\", &amp;n); //cin &gt;&gt; n; sequence.clear(); for (int i = 0; i &lt; n; i++) { scanf(\"%d\", &amp;tmp); //cin &gt;&gt; tmp; sequence.emplace_back(tmp); } fill(bigger, bigger + n, false); fill(pivot, pivot + n, false); maxL = -1, minR = 0x3fffffff; cnt = 0; for (int i = 0; i &lt; n; i++) { if (sequence[i] &gt; maxL) { bigger[i] = true; maxL = sequence[i]; } } for (int i = n - 1; i &gt;= 0; i--) { if (bigger[i] &amp;&amp; sequence[i] &lt; minR) { cnt++; pivot[i] = true; if (cnt == 3) break; } if (sequence[i] &lt; minR)minR = sequence[i]; } if (cnt &gt;= 3) cout &lt;&lt; \"Yes\" &lt;&lt; endl; else if (cnt == 2 &amp;&amp; (pivot[0] || pivot[n - 1]))cout &lt;&lt; \"Yes\" &lt;&lt; endl; else cout &lt;&lt; \"No\" &lt;&lt; endl; }}    这道题我一看是快排，立马放弃，因为我完全忘记快排咋排了，考前我还给室友说我快排没看来着，真是不会啥考啥，本来我都做好只考七十多分的准备了。做完最后一题后就又回来看，往下一拉，发现下面有提示，就是对四个样例的说明，好家伙，直接被我找到规律了，就去查序列中满足大于左边所有数，小于右边所有数的数就行了，中间debug了一会，可算是找到规律了。如果一个序列有三个这样的数就可以是快排，如果有两个，其中一个在0号位或者末尾的话也行。Leader of the Opinion Leaders#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;const int maxn = 10010;struct node{ int ol = -1, follows = 0;};vector&lt;node&gt; user(maxn);vector&lt;vector&lt;int&gt;&gt; fan(maxn);vector&lt;int&gt; ans;int n, t, follow, f, maxc = 0;int main(){ cin &gt;&gt; n &gt;&gt; t; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; follow; user[i].follows = follow; for (int j = 0; j &lt; follow; j++) { cin &gt;&gt; f; fan[f].emplace_back(i); } } for (int i = 1; i &lt;= n; i++) { if (fan[i].size() / user[i].follows &gt;= t) { user[i].ol = 1; } } for (int i = 1; i &lt;= n; i++) { if (user[i].ol == 1) { int cnt = 0; for (int fa : fan[i]) { if (user[fa].ol == 1) cnt++; } if (cnt &gt; maxc) { maxc = cnt; ans.clear(); ans.emplace_back(i); } else if (cnt == maxc) { ans.emplace_back(i); } } } for (int i = 0; i &lt; ans.size(); i++) { if (i != 0) cout &lt;&lt; ' '; cout &lt;&lt; ans[i]; }}    这道题是最简单的一道，虽然做的时候挺着第一道做了一半、第二题没想法的压力写得不够好，但依旧是直接ac了。题库里有类似的题目嘻嘻。Pseudo-completeness#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;queue&gt;using namespace std;const int maxn = 2010;struct node{ int v, level; node* left = nullptr, * right = nullptr; node(int _v, int _l) : v(_v), level(_l) {}};vector&lt;int&gt; in, pre, post;int maxl = 0;node* build(int inL, int inR, int preL, int preR, int level){ if (inL &gt; inR) return nullptr; node* n = new node(pre[preL], level); if (level &gt; maxl) maxl = level; int index; for (int i = inL; i &lt;= inR; i++) { if (in[i] == pre[preL]) index = i; } n-&gt;left = build(inL, index - 1, preL + 1, preL + index - inL, level + 1); n-&gt;right = build(index + 1, inR, preL + index - inL + 1, preR, level + 1); return n;}bool f1 = true, f2 = true, f3 = true;void levelTravelsal(node* root){ queue&lt;node*&gt; q; q.push(root); bool iscom = false; int leaflevel = -1; while (!q.empty()) { node* top = q.front(); q.pop(); if (!top-&gt;left &amp;&amp; !top-&gt;right) { if (leaflevel == -1)leaflevel = top-&gt;level; else if (leaflevel != top-&gt;level) { f1 = false; } if (maxl - 1 &gt; top-&gt;level) f3 = false; } if ((top-&gt;left &amp;&amp; !top-&gt;right) || (!top-&gt;left &amp;&amp; top-&gt;right)) { f1 = false; if (top-&gt;level &lt; maxl - 1) f3 = false; } if (top-&gt;left &amp;&amp; iscom) f2 = false; if (top-&gt;left)q.push(top-&gt;left); else iscom = true; if (top-&gt;right &amp;&amp; iscom) f2 = false; if (top-&gt;right) q.push(top-&gt;right); else iscom = true; }}void postTravelsal(node* root){ if (root == nullptr) return; postTravelsal(root-&gt;left); postTravelsal(root-&gt;right); post.emplace_back(root-&gt;v);}int main(){ int n, tmp; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; tmp; in.emplace_back(tmp); } for (int i = 0; i &lt; n; i++) { cin &gt;&gt; tmp; pre.emplace_back(tmp); } node* root; root = build(0, n - 1, 0, n - 1, 0); levelTravelsal(root); if (f1) cout &lt;&lt; 1 &lt;&lt; endl; else if (f2) cout &lt;&lt; 2 &lt;&lt; endl; else if (f3)cout &lt;&lt; 3 &lt;&lt; endl; else cout &lt;&lt; 0 &lt;&lt; endl; postTravelsal(root); for (int i = 0; i &lt; n; i++) { if (i != 0) cout &lt;&lt; ' '; cout &lt;&lt; post[i]; }}    虽然这道题代码量不小，但这道题并不难，因为里面涉及的知识点在暑假都遇到过，首先是建树，太典了，然后就是完美二叉树的判断、完全二叉树的判断（这个我还专门复习过两遍），就是这个新加的某某树的判断没见过，不过也不难，就在遍历的时候判断就行了，需要注意的是，是完美二叉树的条件有两个，一个就是非叶子节点必有两个孩子，还有一个就是叶子节点在同一层，所以在判断第三种树的时候，这两种条件也要想到，我就是一开始没想到这两种情况，就拿了21分，后来想起来了，就拿满了。" }, { "title": "PAT-Google Recruitment & Decode Registration Card of PAT & Vertex Coloring & Is It A Red-Black Tree", "url": "/posts/PAT-Google-Recruitment-&-Decode-Registration-Card-of-PAT-&-Vertex-Coloring-&-Is-It-A-Red-Black-Tree/", "categories": "算法刷题, PAT", "tags": "素数, 模拟, 排序, 哈希表, 红黑树, 二叉树的遍历", "date": "2022-09-03 09:31:00 +0000", "snippet": "    返校耽搁了两天，昨天在高铁上做了前两道题，又困又累的，状态很差，第一题就拿了15分，第二题没写完，受不了了，就没接着写了。    因为已经没有连着的4道题了，就选了连着的3道和一道别处的30分的题    今天在学校把没写完的第二题写完了，后面俩题也写完了，最后剩下五分钟时间，最后一题找不出问题了（实在不太懂红黑树），就去查第一题了，改到了19分，最后总分90分，剩下10分再给时间也找...", "content": "    返校耽搁了两天，昨天在高铁上做了前两道题，又困又累的，状态很差，第一题就拿了15分，第二题没写完，受不了了，就没接着写了。    因为已经没有连着的4道题了，就选了连着的3道和一道别处的30分的题    今天在学校把没写完的第二题写完了，后面俩题也写完了，最后剩下五分钟时间，最后一题找不出问题了（实在不太懂红黑树），就去查第一题了，改到了19分，最后总分90分，剩下10分再给时间也找不出来了。A1152 Google Recruitment#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;cmath&gt;using namespace std;typedef long long LL;bool isPrime(LL a){ if (a &lt;= 1) return false; LL sqr = (LL)sqrt(a); for (LL i = 2; i &lt;= sqr; i++) { if (a % i == 0) return false; } return true;}int main(){ int l, k; cin &gt;&gt; l &gt;&gt; k; string s; cin &gt;&gt; s; for (int i = 0; i &lt;= l - k; i++) { string tmp = s.substr(i, k); LL p = stoll(tmp); if (isPrime(p)) { cout &lt;&lt; tmp; return 0; } } cout &lt;&lt; 404;}    这题，一开始我担心超时就用的欧拉筛法，但不能筛太多，太多的话内存不够，所以就拿了15分。最后回来改成普通的查素数方法，竟然有19分，有一个测试点过不去。    好怪啊，我看了下柳神的代码，跟我的几乎一样，唯一不同的就是在遍历的时候我写的i &lt;= s.size() - k，她写的i &lt;= l - k，但按理来说s.size()和l相等啊，奇怪。A1153 Decode Registration Card of PAT#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;unordered_map&gt;#include&lt;algorithm&gt;using namespace std;struct stu{ string stuid; int score; stu(string _id, int _score):stuid(_id), score(_score) {}};struct sitenode{ int num, people; sitenode(int _num, int _people) : num(_num), people(_people) {}};const int maxsite = 1000;const int maxtime = 991300;int siteN[maxsite] = { 0 }, siteScore[maxsite] = { 0 };vector&lt;stu&gt; test[3];//ATBunordered_map&lt;string, unordered_map&lt;int, int&gt; &gt; time2site;unordered_map&lt;int, int&gt; siteShow;int n, m, t;bool comp1(stu s1, stu s2){ if (s1.score != s2.score) return s1.score &gt; s2.score; else return s1.stuid &lt; s2.stuid;}bool comp2(sitenode s1, sitenode s2){ if (s1.people != s2.people) return s1.people &gt; s2.people; else return s1.num &lt; s2.num;}int main(){ cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) { string sid; int ssc; cin &gt;&gt; sid &gt;&gt; ssc; if (sid[0] == 'A') { test[0].emplace_back(stu(sid, ssc)); } else if (sid[0] == 'T') { test[1].emplace_back(stu(sid, ssc)); } else test[2].emplace_back(stu(sid, ssc)); string site = sid.substr(1, 3); int isite = stoi(site); string time = sid.substr(4, 6); int itime = stoi(time); siteN[isite]++; siteScore[isite] += ssc; time2site[time][isite]++; } for (int i = 0; i &lt; 3; i++) { sort(test[i].begin(), test[i].end(), comp1); } for (int i = 1; i &lt;= m; i++) { int type; cin &gt;&gt; type; if (type == 1) { string s; cin &gt;&gt; s; printf(\"Case %d: 1 %s\\n\", i, s.c_str()); int index; if (s == \"A\") index = 0; else if (s == \"T\") index = 1; else index = 2; if (test[index].empty()) { printf(\"NA\\n\"); continue; } for (stu st : test[index]) { printf(\"%s %d\\n\", st.stuid.c_str(), st.score); } } else if (type == 2) { int s; cin &gt;&gt; s; printf(\"Case %d: 2 %d\\n\", i, s); if (siteN[s] == 0) { printf(\"NA\\n\"); continue; } printf(\"%d %d\\n\", siteN[s], siteScore[s]); } else { string s; cin &gt;&gt; s; t = stoi(s); printf(\"Case %d: 3 %s\\n\", i, s.c_str()); if (!time2site.count(s)) { printf(\"NA\\n\"); continue; } vector&lt;sitenode&gt; type3; for (auto it = time2site[s].begin(); it != time2site[s].end(); it++) { type3.emplace_back(sitenode(it-&gt;first, it-&gt;second)); } sort(type3.begin(), type3.end(), comp2); for (int i = 0; i &lt; type3.size(); i++) { printf(\"%d %d\\n\", type3[i].num, type3[i].people); } } }}    这道题真是写了好久，得写了一个多小时，可以说最后一题写的时间都没这个长，也可能跟我在高铁上状态不太好有关系吧。需要注意的点挺多的： type2问的是某个考场的总人数，这个直接在读取的时候记录起来就行了，但是这个记录下来的数据不能用在tyoe3中，因为同一个考场考试时间可能不同，也就是说type3中某个时间的考场人数可能要比上面考场记录的总人数少 想要把考场数据加上时间信息，但不能用数组，因为时间就10^7了，考场再10^3，用数组存的话会内存超限（我试了），所以就用了双层哈希表 哈希表的迭代器iterator可以指向键(first)和值(second) 看了下柳神的代码，代码量只有我的1/3，她是把所有学生数据存起来，根据type，每次都遍历一遍学生，根据学生的情况分别统计需要的数据。我是只读取的时候就几乎完成了统计工作，只需要后序的判断情况和排序，但还是柳神的简单啊，有时候多遍历几次就遍历几次吧，省了写代码的时间 A1154 Vertex Coloring#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;unordered_map&gt;using namespace std;const int maxn = 10010;struct edge{ int v, u; edge(int _u, int _v) : u(_u), v(_v) {}};vector&lt;edge&gt; E;int n, m;int main(){ cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; i++) { int u, v; cin &gt;&gt; u &gt;&gt; v; E.emplace_back(edge(u, v)); } int q; cin &gt;&gt; q; while (q--) { vector&lt;int&gt; vertex(n); unordered_map&lt;int, int&gt; color; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; vertex[i]; color[vertex[i]]++; } bool flag = true; for (edge e : E) { if (vertex[e.u] == vertex[e.v]) { flag = false; break; } } if (flag) cout &lt;&lt; color.size() &lt;&lt; \"-coloring\" &lt;&lt; endl; else cout &lt;&lt; \"No\" &lt;&lt; endl; }}    这道题比上道题的代码量小多了，也不难，遍历就完事了。A1135 Is It A Red-Black Tree#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;struct node{ int v; node* left = nullptr, * right = nullptr; node(int _v) :v(_v) {}};vector&lt;int&gt; pre, in;node* build(int preL, int preR, int inL, int inR){ if (preL &gt; preR) return nullptr; node* n = new node(pre[preL]); int index; for (int i = inL; i &lt;= inR; i++) { if (in[i] == pre[preL]) index = i; } n-&gt;left = build(preL + 1, index - inL + preL, inL, index - 1); n-&gt;right = build(index - inL + preL + 1, preR, index + 1, inR); return n;}bool comp(int a, int b){ return abs(a) &lt; abs(b);}int getBlack(node* n){ if (n == nullptr) return 0; if (n-&gt;v &gt; 0)return 1 + max(getBlack(n-&gt;left), getBlack(n-&gt;right)); else return max(getBlack(n-&gt;left), getBlack(n-&gt;right));}bool checkBlack(node* root){ if (root == nullptr) return true; bool flag = true; if (getBlack(root-&gt;left) != getBlack(root-&gt;right)) flag = false; return flag &amp;&amp; checkBlack(root-&gt;left) &amp;&amp; checkBlack(root-&gt;right);}bool f;void travelsal(node* root){ if (root == nullptr) return; if (root-&gt;v &lt; 0) { if (root-&gt;left &amp;&amp; root-&gt;left-&gt;v &lt; 0) f = false; if (root-&gt;right &amp;&amp; root-&gt;right-&gt;v &lt; 0) f = false; } travelsal(root-&gt;left); travelsal(root-&gt;right);}int main(){ int k, n; cin &gt;&gt; k; while (k--) { cin &gt;&gt; n; pre.clear(); in.clear(); for (int i = 0; i &lt; n; i++) { int v; cin &gt;&gt; v; pre.emplace_back(v); in.emplace_back(v); } sort(in.begin(), in.end(), comp); node* root; root = build(0, n - 1, 0, n - 1); f = true; travelsal(root); if (!checkBlack(root) || root-&gt;v &lt; 0 || !f) { cout &lt;&lt; \"No\" &lt;&lt; endl; continue; } cout &lt;&lt; \"Yes\" &lt;&lt; endl; }}    这道题，一开始自己写的只拿了21分，后面两个测试点没过去。我一开始是这么判断性质5的：每一层必须颜色一样（就像图一那样），但事实上每一层颜色不一定一样，其实就是遍历每个节点，看它到叶子节点的黑色节点个数，而判断方法和获取树高的方法类似，就看左子树和右子树的树高（此时为黑色节点个数）是否相等即可。 注意红黑树不一定是平衡树，其树高可以不平衡" }, { "title": "PAT-N Queens Puzzle & Recommendation System & Infix Expression & Subway Map", "url": "/posts/PAT-N-Queens-Puzzle-&-Recommendation-System-&-Infix-Expression-&-Subway-Map/", "categories": "算法刷题, PAT", "tags": "哈希表, 排序, 二叉树, 中缀表达式, dfs, Dijkstra", "date": "2022-08-31 15:59:00 +0000", "snippet": "    今天的模拟测试并不是很理想，不知道是否跟状态有关。跟昨天一样，超时9min，很奇怪，昨天也差不多超时这么长时间，怎么回事呢？而且不同的是，今天3h9min32s只拿了75分，要是按3h算，最后一题没写完，那就只有59分，还没我上次PAT考的分高，麻了。接下来好好复盘下吧。A1128 N Queens Puzzle#include&lt;iostream&gt;#include&lt;...", "content": "    今天的模拟测试并不是很理想，不知道是否跟状态有关。跟昨天一样，超时9min，很奇怪，昨天也差不多超时这么长时间，怎么回事呢？而且不同的是，今天3h9min32s只拿了75分，要是按3h算，最后一题没写完，那就只有59分，还没我上次PAT考的分高，麻了。接下来好好复盘下吧。A1128 N Queens Puzzle#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;unordered_map&gt;using namespace std;int n;int Hash(int x, int y){ return n * (x - 1) + y;}int main(){ int k; cin &gt;&gt; k; while (k--) { cin &gt;&gt; n; unordered_map&lt;int, int&gt; row; vector&lt;bool&gt; dia((n+1)*(n+1), false); string s; bool flag = true; for (int col = 1; col &lt;= n; col++) { int _row; cin &gt;&gt; _row; if (row.count(_row)) { cout &lt;&lt; \"NO\" &lt;&lt; endl; flag = false; getline(cin, s); break; } else { row[_row]++; } if (dia[Hash(_row, col)]) { cout &lt;&lt; \"NO\" &lt;&lt; endl; flag = false; getline(cin, s); break; } else { int x = _row, y = col; while (x &gt;= 1 &amp;&amp; y &gt;= 1) { dia[Hash(x, y)]=true; x--; y--; } while (x &lt; n &amp;&amp; y &lt; n) { x++; y++; dia[Hash(x, y)] = true; } x = _row, y = col; while (x &gt; 1 &amp;&amp; y &lt; n) { x--; y++; dia[Hash(x, y)] = true; } x = _row, y = col; while (x &lt; n &amp;&amp; y &gt; 1) { x++; y--; dia[Hash(x, y)] = true; } } } if(flag) cout &lt;&lt; \"YES\" &lt;&lt; endl; }}    这是改了之后ac的，一开始做的时候花了40min（debug太久了）只拿了16分，最后一个测试点超时了，本来判断是否在对角线，我也用的哈希表，但会超时，而且用了超级多的内存，改成bool数组后就不超时了，用的内存也很少，看来哈希表还得谨慎使用，有那么几点需要注意： 自己写了个hash函数，把坐标映射成一个数，但我在调函数的时候，参数写反了，就这一个点debug了好久，麻了，一定要细心，注意参数顺序 还有就是，我是一遍读取一遍判断的，如果判断为NO就会提前退出，但！是！提前退出后，后面还有数字没读的，结果就把后面剩余的部分读到下一个棋盘里去了！所以提前退出的话，要把这一行剩下的数据用getline读掉！ 上面两处小错debug了好久，第一题浪费的时间足够把最后一题的第一版写完了！     去看了眼柳神的代码，太强了，判断是否在斜着的，只要判断两个点横坐标相减与纵坐标相减是否相等就行了，如果在一列，那么行差和列差是相等的！想象下，如果两点在一条对角线上，那么两个点分别为一个四边形的左上角和右下角，那么这个四边形就是正方形！A1129 Recommendation System#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cstring&gt;#include&lt;unordered_map&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 50010;int times[maxn];vector&lt;int&gt; rec;unordered_map&lt;int, int&gt; m;bool comp(int r1, int r2){ if (times[r1] != times[r2]) { return times[r1] &gt; times[r2]; } else return r1 &lt; r2;}int main(){ int n, k, r; memset(times, 0, sizeof(times)); cin &gt;&gt; n &gt;&gt; k &gt;&gt; r; rec.emplace_back(r); times[r]++; m[r]++; for (int i = 0; i &lt; n - 1; i++) { cin &gt;&gt; r; cout &lt;&lt; r &lt;&lt; \":\"; for (int j = 0; j &lt; k &amp;&amp; j &lt; rec.size(); j++) { cout &lt;&lt; ' ' &lt;&lt; rec[j]; } cout &lt;&lt; endl; if (i == n - 2)break; if (!m.count(r)) { rec.emplace_back(r); m[r]++; } times[r]++; sort(rec.begin(), rec.end(), comp); }}    这道题我用的暴力排序拿了18分，每次加入到数组中一个数后就排次序，果不其然，超时了，测试点三和四超时了，我改成只有当m中有r时排序，测试点四就能过了，但其他基本都没过。其实也还好了，因为用的方法简单，所以节省了不少时间。#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cstring&gt;#include&lt;unordered_map&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 50010;int times[maxn];vector&lt;int&gt; rec;unordered_map&lt;int, int&gt; m;bool comp(int r1, int r2){ if (times[r1] != times[r2]) { return times[r1] &gt; times[r2]; } else return r1 &lt; r2;}int main(){ int n, k, r; memset(times, 0, sizeof(times)); cin &gt;&gt; n &gt;&gt; k &gt;&gt; r; rec.emplace_back(r); times[r]++; m[r]++; for (int i = 0; i &lt; n - 1; i++) { cin &gt;&gt; r; cout &lt;&lt; r &lt;&lt; \":\"; for (int j = 0; j &lt; k &amp;&amp; j &lt; rec.size(); j++) { cout &lt;&lt; ' ' &lt;&lt; rec[j]; } cout &lt;&lt; endl; if (i == n - 2)break; times[r]++; if (!m.count(r)) { m[r]++; //insert int pos = rec.size() - 1; while (pos &gt;= 0 &amp;&amp; times[rec[pos]] == times[r] &amp;&amp; rec[pos] &gt; r) { pos--; } rec.insert(rec.begin() + pos + 1, r); } else sort(rec.begin(), rec.end(), comp); }}    这是我优化后的，如果是一个新的产品，那么就只是插入数组中，不做排序，如果是老产品，那就排序，这次拿了21分，依旧有一个测试点过不去。#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cstring&gt;#include&lt;unordered_map&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 50010;int times[maxn];vector&lt;int&gt; rec;bool inRec[maxn] = {false};bool comp(int r1, int r2){ if (times[r1] != times[r2]) { return times[r1] &gt; times[r2]; } else return r1 &lt; r2;}int main(){ int n, k, r; memset(times, 0, sizeof(times)); cin &gt;&gt; n &gt;&gt; k &gt;&gt; r; rec.emplace_back(r); times[r]++; inRec[r] = true; for (int i = 0; i &lt; n - 1; i++) { cin &gt;&gt; r; cout &lt;&lt; r &lt;&lt; \":\"; for (int j = 0; j &lt; k &amp;&amp; j &lt; rec.size(); j++) { cout &lt;&lt; ' ' &lt;&lt; rec[j]; } cout &lt;&lt; endl; if (i == n - 2)break; times[r]++; if (inRec[r] == false) { if (rec.size() &lt; k) { rec.emplace_back(r); inRec[r] = true; } else { if (times[rec.back()] &lt; times[r] || (times[rec.back()] == times[r] &amp;&amp; r &lt; rec.back())) { inRec[rec.back()] = false; rec.pop_back(); rec.emplace_back(r); inRec[r] = true; } } } sort(rec.begin(), rec.end(), comp); }}    这个是看了网上的博客才恍然大悟，根本没必要对整个数组都排序，只要给k个以内的数排序就行了，这样排很多次也不用怕，就看怎么更新了： 首先要增加一次产品的浏览次数times 判断该产品是否在推荐列表里 如果不在：检查推荐列表是否已满 如果没满，直接加入推荐列表 如果满了，与最后一个比较，看是否能替代最后一个 最后把新的推荐列表根据规则排序 A1130 Infix Expression#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cstring&gt;#include&lt;unordered_map&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 22;struct node{ string v; int left, right;}tree[maxn];bool isRoot[maxn] = { false };int Realroot;void travelsal(int root){ if (root == -1) return; if (root == Realroot) { travelsal(tree[root].left); cout &lt;&lt; tree[root].v; travelsal(tree[root].right); } else if (tree[root].left == -1 &amp;&amp; tree[root].right != -1) { //pre cout &lt;&lt; '('; cout &lt;&lt; tree[root].v; travelsal(tree[root].right); cout &lt;&lt; ')'; } else//in { if(tree[root].left != -1) cout &lt;&lt; '('; travelsal(tree[root].left); cout &lt;&lt; tree[root].v; travelsal(tree[root].right); if (tree[root].right != -1) cout &lt;&lt; ')'; }}int main(){ int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt;tree[i].v &gt;&gt; tree[i].left &gt;&gt; tree[i].right; if (tree[i].left != -1) isRoot[tree[i].left] = true; if (tree[i].right != -1) isRoot[tree[i].right] = true; } for (int i = 1; i &lt;= n ; i++) { if (isRoot[i] == false) { Realroot = i; break; } } travelsal(Realroot);}    得益于昨天做的后缀表达式，今天这个中缀表达式很快就写完了，而且也是唯一一道ac的题目，需要注意的就是如果是叶子节点，不需要打括号，还有就是如果一个节点只有右子树（比如负号），这时候要特判成类后序遍历（因为不需要遍历左子树，遍历顺序为右根，就叫类后序遍历吧）。A1131 Subway Map#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cstring&gt;#include&lt;set&gt;#include&lt;unordered_map&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;using namespace std;const int inf = 0x3fffffff;const int maxn = 101;vector&lt;vector&lt;int&gt;&gt; neighbor(maxn);unordered_map&lt;int, int&gt; station2index;unordered_map&lt;int, int&gt; index2station;unordered_map&lt;int, set&lt;int&gt;&gt; station2line;int dis[maxn], transCnt[maxn], pre[maxn];bool vis[maxn];void Dijkstra(int s){ fill(dis, dis + maxn, inf); fill(transCnt, transCnt + maxn, 0); fill(vis, vis + maxn, false); dis[s] = 0; transCnt[s] = 0; for (int i = 0; i &lt; station2index.size(); i++) { int u = -1, min = inf; for (int j = 0; j &lt; station2index.size(); j++) { if (vis[j] == false &amp;&amp; dis[j] &lt; min) { min = dis[j]; u = j; } } if (u == -1) return; vis[u] = true; for (auto n : neighbor[u]) { if (vis[n] == false) { int trCnt = transCnt[u]; if (station2line[index2station[u]].size() &gt; 1 &amp;&amp; u != s)trCnt++; if (dis[u] + 1 &lt; dis[n]) { dis[n] = dis[u] + 1; pre[n] = u; transCnt[n] = trCnt; } if (dis[u] + 1 == dis[n] &amp;&amp; trCnt &lt; transCnt[n]) { dis[n] = dis[u] + 1; pre[n] = u; transCnt[n] = trCnt; } } } }}vector&lt;int&gt; path;void dfs(int start, int cur){ if (cur == start) { path.emplace_back(cur); return; } dfs(start,index2station[pre[station2index[cur]]]); //transfer if(station2line[cur].size() &gt; 1) path.emplace_back(cur);}int stationsLine(int s1, int s2){ for (auto l1 : station2line[s1]) { for (auto l2 : station2line[s2]) { if (l1 == l2) return l1; } } return -1;}void printPath(){ for (int i = 0; i &lt; path.size() - 1; i++) { int line = stationsLine(path[i], path[i+1]); printf(\"Take Line#%d from %04d to %04d.\\n\", line, path[i], path[i + 1]); }}int main(){ int n, m, index = 0; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; m; vector&lt;int&gt; line(m); for (int j = 0; j &lt; m; j++) { int station; cin &gt;&gt; station; if (!station2index.count(station)) { station2index[station] = index; index2station[index] = station; index++; } station2line[station].insert(i); line[j] = station2index[station]; } for (int j = 0; j &lt; m - 1; j++) { neighbor[line[j]].emplace_back(line[j + 1]); neighbor[line[j + 1]].emplace_back(line[j]); } } int k; cin &gt;&gt; k; while (k--) { int start, end; cin &gt;&gt; start &gt;&gt; end; Dijkstra(station2index[start]); cout &lt;&lt; dis[station2index[end]]&lt;&lt;endl; path.clear(); dfs(start, end); path.emplace_back(end); printPath(); }}    这些代码写了一个半小时，也没写完，最后超时9min才写完，就这也就拿了16/30分，麻了。关键是debug了很久，光算最短路的时候就debug了一会儿，发现n写成了u，哎。还有就是各种哈希映射太多了，有的搞混了，要么中断，要么答案有问题。我看网上是有用dfs写的，今天不早了，明天看看。#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;unordered_map&gt;#include&lt;cstdio&gt;using namespace std;const int maxn = 10000;const int inf = 0x3fffffff;vector&lt;vector&lt;int&gt; &gt; neighbor(maxn);unordered_map&lt;int, int&gt; line;//记录两个节点所在线路int Start, End, minDis, minStop;bool vis[maxn] = { false };vector&lt;int&gt; tmppath, path;int getStops(vector&lt;int&gt; v){ int preline = line[v[0]*maxn + v[1]], cnt = 0; for (int i = 1; i &lt; v.size() - 1; i++) { int curLine = line[v[i] * maxn + v[i + 1]]; if (curLine != preline) { cnt++; preline = curLine; } } return cnt;}void dfs(int curS, int curDis){ if (curS == End &amp;&amp; (curDis &lt; minDis || (curDis == minDis &amp;&amp; getStops(tmppath) &lt; minStop))) { path = tmppath; minDis = curDis; minStop = getStops(tmppath); return; } for (int n : neighbor[curS]) { if (vis[n] == false) { vis[n] = true; tmppath.emplace_back(n); dfs(n, curDis + 1); tmppath.pop_back(); vis[n] = false; } }}int main(){ int n, m; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; m; int preS, curS; cin &gt;&gt; preS; for (int j = 1; j &lt; m; j++) { cin &gt;&gt; curS; neighbor[preS].emplace_back(curS); neighbor[curS].emplace_back(preS); line[preS * maxn + curS] = i; line[curS * maxn + preS] = i; preS = curS; } } int k; cin &gt;&gt; k; while (k--) { cin &gt;&gt; Start &gt;&gt; End; vis[Start] = true; minDis = inf; tmppath.emplace_back(Start); dfs(Start, 0); tmppath.pop_back(); vis[Start] = false; cout &lt;&lt; minDis &lt;&lt; endl; int preline = line[path[0] * maxn + path[1]], preS = Start; for (int i = 1; i &lt; path.size() -1 ; i++) { if (line[path[i] * maxn + path[i + 1]] != preline) { printf(\"Take Line#%d from %04d to %04d.\\n\", preline, preS, path[i]); preline = line[path[i] * maxn + path[i + 1]]; preS = path[i]; } } printf(\"Take Line#%d from %04d to %04d.\\n\", preline, preS, path.back()); }}    看了柳神的思路，真是非常妙： 直接使用车站号作为数组下标，毕竟也就1万了（我还傻乎乎地去哈希来哈希去） 如何判断某个车站位于几号线呢？直接设置一个哈希表line[preS*10000 + curS]代表着上一个车站到当前车站所属线路，这样的话完美解决中转站可能属于好几条线的问题，两个车站必定只属于一条线，而中转站的判断，恰恰根据三个站点中前两个和后两个是否属于一条线，如果不属于，说明三个的中央就是中转站 使用深度优先遍历即可，要使用vis数组     尽管该方法很巧妙，但我写完后依旧debug了会儿，麻了。注意： vis数组赋值我竟然用了==，实在是无语 minDis在每次询问都要重置为inf，不然根本dfs不出正确答案 因为这次是读取的时候直接互相加邻接表（第一次我是先存到数组，再互相加邻接表），所以要储存上一个站点preS，我一开始忘了存 " }, { "title": "PAT-Sexy Primes & Anniversary & Telefraud Detection & Structure of a Binary Tree & find()函数 & sscanf()函数", "url": "/posts/PAT-Sexy-Primes-&-Anniversary-&-Telefraud-Detection-&-Structure-of-a-Binary-Tree-&-find()%E5%87%BD%E6%95%B0-&-sscanf()%E5%87%BD%E6%95%B0/", "categories": "算法刷题, PAT", "tags": "素数, 哈希表, 模拟, 并查集, 二叉树, 满二叉树", "date": "2022-08-30 12:00:00 +0000", "snippet": "    今天这次模拟题目有点过山车，前两题有点太简单了，35分钟就ac了前两道题，但是，后两道题简直是噩梦，剩下所有时间都在写这两道题，最后还没写完，又多花了9分钟debug，才把最后一题写完拿了27分，200行真是写麻了，第三题也没全对，所以统计下来，3h拿了64分，3h09min拿了91分，中间上了个厕所，但也没几分钟，估计连两分钟都没，哎。教训就是考试过程一定要滴水不沾，万一就差这两分...", "content": "    今天这次模拟题目有点过山车，前两题有点太简单了，35分钟就ac了前两道题，但是，后两道题简直是噩梦，剩下所有时间都在写这两道题，最后还没写完，又多花了9分钟debug，才把最后一题写完拿了27分，200行真是写麻了，第三题也没全对，所以统计下来，3h拿了64分，3h09min拿了91分，中间上了个厕所，但也没几分钟，估计连两分钟都没，哎。教训就是考试过程一定要滴水不沾，万一就差这两分钟呢。A1156 Sexy Primes#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;bool isPrime(int n){ if (n &lt;= 1) return false; int sqr = (int)sqrt(n); for (int i = 2; i &lt;= sqr; i++) { if (n % i == 0) return false; } return true;}int main(){ int n; cin &gt;&gt; n; if (isPrime(n) &amp;&amp; isPrime(n - 6)) { cout &lt;&lt; \"Yes\" &lt;&lt; endl &lt;&lt; n - 6; } else if (isPrime(n) &amp;&amp; isPrime(n + 6)) { cout &lt;&lt; \"Yes\" &lt;&lt; endl &lt;&lt; n + 6; } else { while (1) { n++; if (isPrime(n) &amp;&amp; isPrime(n - 6)) break; if (isPrime(n) &amp;&amp; isPrime(n + 6)) break; } cout &lt;&lt; \"No\" &lt;&lt; endl &lt;&lt; n; }}    这道题就是个素数判断题，知道怎么判断素数的话，很快就能写完。A1157 Anniversary#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;unordered_map&gt;using namespace std;unordered_map&lt;string, int&gt; alumnus;string alumnusMin, guestMin = \"\";string older(string s1, string s2){ string s11 = s1.substr(6, 8); string s22 = s2.substr(6, 8); if (stoi(s11) &lt; stoi(s22)) { return s1; } else return s2;}int main(){ int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) { string s; cin &gt;&gt; s; alumnus[s]++; } cin &gt;&gt; n; int cnt = 0; for (int i = 0; i &lt; n; i++) { string s; cin &gt;&gt; s; if (alumnus.count(s)) { cnt++; if (cnt == 1) alumnusMin = s; else { alumnusMin = older(alumnusMin, s); } } else { if (guestMin == \"\") guestMin = s; else { guestMin = older(guestMin, s); } } } if (cnt &gt; 0) { cout &lt;&lt; cnt &lt;&lt; endl &lt;&lt; alumnusMin; } else { cout &lt;&lt; cnt &lt;&lt; endl &lt;&lt; guestMin; }}    这算是一道哈希表的题吧，也没多难，会用string的话很简单。A1158 Telefraud Detection#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;set&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;unordered_map&gt;#include&lt;cstring&gt;using namespace std;const int maxn = 1010;int connect[maxn][maxn], father[maxn];int k, n, m;set&lt;int&gt; suspects;vector&lt;int&gt; suspects2;vector&lt;int&gt; realSus;vector&lt;set&lt;int&gt;&gt; callDiff(maxn);int FindFather(int x){ int a = x; while (x != father[x]) { x = father[x]; } while (a != father[a]) { int z = a; a = father[a]; father[z] = x; } return x;}int main(){ cin &gt;&gt; k &gt;&gt; n &gt;&gt; m; memset(connect, 0, sizeof(connect)); for (int i = 0; i &lt; m; i++) { int p, q, t; cin &gt;&gt; p &gt;&gt; q &gt;&gt; t; connect[p][q] += t; callDiff[p].insert(q); if (callDiff[p].size() &gt; k) { suspects.insert(p); } } for (auto it = suspects.begin(); it != suspects.end(); it++) { int shortCallCnt = callDiff[*it].size(), cnt = 0; for (int s : callDiff[*it]) { if (connect[*it][s] &gt; 5) { shortCallCnt--; } else if (connect[s][*it] &gt; 0) { cnt++; } } if (shortCallCnt &gt; k) { if (double(cnt) / double(shortCallCnt) &lt;= 0.2) { realSus.emplace_back(*it); } } } for (int i = 0; i &lt; maxn; i++) { father[i] = i; } if (realSus.size() == 0) { cout &lt;&lt; \"None\"; return 0; } for (int i = 0; i &lt; realSus.size() - 1; i++) { for (int j = i + 1; j &lt; realSus.size(); j++) { int fi = FindFather(realSus[i]); int fj = FindFather(realSus[j]); if (fi == fj) continue; if (connect[realSus[i]][realSus[j]] &amp;&amp; connect[realSus[j]][realSus[i]]) { if (fi &lt; fj) father[fj] = fi; else father[fi] = fj; } } } int gangNum = 0, index = 0; unordered_map&lt;int, int&gt; n2index; vector&lt;vector&lt;int&gt;&gt; gangs(realSus.size()); for (int i = 0; i &lt; realSus.size(); i++) { int p = realSus[i]; int fp = father[p]; if (fp == p) { gangs[index].emplace_back(p); n2index[p] = index++; gangNum++; } else { gangs[n2index[fp]].emplace_back(p); } } if (gangNum == 0) cout &lt;&lt; \"None\"; else { for (int i = 0; i &lt; gangNum; i++) { for (int j = 0; j &lt; gangs[i].size(); j++) { if (j != 0) cout &lt;&lt; ' '; cout &lt;&lt; gangs[i][j]; } cout &lt;&lt; endl; } }}    模拟，黑帮检测题，这题描述很多，很复杂，难在数据处理上了，花了很久写完，最后一个测试点没过（6分），本来想着写完第四题再回来debug的，结果第四题直接把时间干完了……    这道题问题其实挺好发现的，因为我漏了一段话，就是用例1下面的Note没看，他意思是说，一个人给另一个人打多次电话时，要合并成一个来判断是不是短电话，最后一个测试点就是这里。    看了下柳神的代码，绝了，就五十多行代码。她把每个人的电话时长存在了一个二维数组里，就像邻接矩阵一样，把数据都统计完了，再去判断的，我这是一边判断一边存值，很麻烦。还有就是开辟一个数组后，会默认都赋值为0，bool的话会默认赋值为false。A1159 Structure of a Binary Tree    先粘一下我写的屎山代码（其实写完了发现可以用一个flag，但也没时间写了）#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;using namespace std;struct node{ int v; node* left = nullptr, * right = nullptr; node(int _v) : v(_v) {}}*root;const int maxn = 32;vector&lt;int&gt; post(maxn);vector&lt;int&gt; in(maxn);node* build(int pL, int pR, int iL, int iR){ if (pL &gt; pR) return nullptr; node* n = new node(post[pR]); int index; for (int i = iL; i &lt;= iR; i++) { if (in[i] == post[pR]) { index = i; break; } } n-&gt;left = build(pL, pL + index - 1 - iL, iL, index - 1); n-&gt;right = build(pL + index - iL, pR - 1, index + 1, iR); return n;}void case1(int v){ if (root-&gt;v == v) { cout &lt;&lt; \"Yes\" &lt;&lt; endl; } else cout &lt;&lt; \"No\" &lt;&lt; endl;}bool flag2, flag3, flag4, flag5, flag7;void travelsal2(node* root, int v1, int v2){ if (root == nullptr) return; if (root-&gt;left &amp;&amp; root-&gt;right) { if ((root-&gt;left-&gt;v == v1 &amp;&amp; root-&gt;right-&gt;v == v2) || (root-&gt;left-&gt;v == v2 &amp;&amp; root-&gt;right-&gt;v == v1)) { flag2 = true; return; } } travelsal2(root-&gt;left, v1, v2); travelsal2(root-&gt;right, v1, v2);}void case2(int v1, int v2){ flag2 = false; travelsal2(root, v1, v2); if (flag2) cout &lt;&lt; \"Yes\" &lt;&lt; endl; else cout &lt;&lt; \"No\" &lt;&lt; endl;}void travelsal3(node* root, int p, int c){ if (root == nullptr) return; if (root-&gt;v == p) { if (root-&gt;left &amp;&amp; root-&gt;left-&gt;v == c) { flag3 = true; flag4 = true; } else if (root-&gt;right &amp;&amp; root-&gt;right-&gt;v == c) { flag3 = true; flag5 = true; } } travelsal3(root-&gt;left, p, c); travelsal3(root-&gt;right, p, c);}void case3(int p, int c){ flag3 = false; travelsal3(root, p, c); if (flag3) cout &lt;&lt; \"Yes\" &lt;&lt; endl; else cout &lt;&lt; \"No\" &lt;&lt; endl;}void case4(int p, int c){ flag4 = false; travelsal3(root, p, c); if (flag4) cout &lt;&lt; \"Yes\" &lt;&lt; endl; else cout &lt;&lt; \"No\" &lt;&lt; endl;}void case5(int p, int c){ flag5 = false; travelsal3(root, p, c); if (flag5) cout &lt;&lt; \"Yes\" &lt;&lt; endl; else cout &lt;&lt; \"No\" &lt;&lt; endl;}int l1, l2;void getLevel(node* root, int level, int n1, int n2){ if (root == nullptr) return; if (root-&gt;v == n1) l1 = level; else if (root-&gt;v == n2) l2 = level; getLevel(root-&gt;left, level + 1, n1, n2); getLevel(root-&gt;right, level + 1, n1, n2);}void case6(int n1, int n2){ getLevel(root, 0, n1, n2); if (l1 == l2)cout &lt;&lt; \"Yes\" &lt;&lt; endl; else cout &lt;&lt; \"No\" &lt;&lt; endl;}void travelsal7(node* root){ if (root == nullptr) return; if (root-&gt;left &amp;&amp; !root-&gt;right) flag7 = false; else if (root-&gt;right &amp;&amp; !root-&gt;left) flag7 = false; travelsal7(root-&gt;left); travelsal7(root-&gt;right);}void case7(){ flag7 = true; travelsal7(root); if (flag7) cout &lt;&lt; \"Yes\" &lt;&lt; endl; else cout &lt;&lt; \"No\" &lt;&lt; endl;}int main(){ int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; post[i]; } for (int i = 0; i &lt; n; i++) { cin &gt;&gt; in[i]; } root = build(0, n - 1, 0, n - 1); int m; cin &gt;&gt; m; while (m--) { int CASE; string s[4], stmp; for (int i = 0; i &lt; 4; i++) { cin &gt;&gt; s[i]; } if (s[3] == \"root\") CASE = 1; else if (s[3] == \"are\") { cin &gt;&gt; stmp; if (stmp == \"siblings\") CASE = 2; else { CASE = 6; getline(cin, stmp); } } else if (s[3] == \"parent\") { CASE = 3; cin &gt;&gt; s[1]; cin &gt;&gt; s[1]; } else if (s[3] == \"left\") { CASE = 4; cin &gt;&gt; s[1]; cin &gt;&gt; s[1]; cin &gt;&gt; s[1]; } else if (s[3] == \"right\") { CASE = 5; cin &gt;&gt; s[1]; cin &gt;&gt; s[1]; cin &gt;&gt; s[1]; } else { CASE = 7; cin &gt;&gt; s[1]; } switch (CASE) { case 1: { int root = stoi(s[0]); case1(root); break; } case 2: { int v1 = stoi(s[0]), v2 = stoi(s[2]); case2(v1, v2); break; } case 3: { int p = stoi(s[0]), c = stoi(s[1]); case3(p, c); break; } case 4: { int p = stoi(s[1]), c = stoi(s[0]); case4(p, c); break; } case 5: { int p = stoi(s[1]), c = stoi(s[0]); case5(p, c); break; } case 6: { int n1 = stoi(s[0]), n2 = stoi(s[2]); case6(n1, n2); break; } case 7: { case7(); break; } default: break; } }}    这两百多行的代码，也没拿满分，差三分，我也不打算找bug了，直接重构好吧，这两百行在考试的情况下是必不可能写的，太浪费时间了。下面是优化的代码：#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;unordered_map&gt;using namespace std;struct node{ int v, level; node* left = nullptr, * right = nullptr, *parent = nullptr; node(int _v) : v(_v) {}}*root;const int maxn = 32;vector&lt;int&gt; post(maxn);vector&lt;int&gt; in(maxn);bool isFull = true;unordered_map&lt;int, node*&gt; v2node;node* build(int pL, int pR, int iL, int iR){ if (pL &gt; pR) return nullptr; node* n = new node(post[pR]); int index; for (int i = iL; i &lt;= iR; i++) { if (in[i] == post[pR]) { index = i; break; } } n-&gt;left = build(pL, pL + index - 1 - iL, iL, index - 1); n-&gt;right = build(pL + index - iL, pR - 1, index + 1, iR); if (n-&gt;left) n-&gt;left-&gt;parent = n; if (n-&gt;right) n-&gt;right-&gt;parent = n; v2node[n-&gt;v] = n; return n;}void dfs(node* root){ if (root == nullptr) return; if (root-&gt;parent)root-&gt;level = root-&gt;parent-&gt;level + 1; if (root-&gt;left &amp;&amp; !root-&gt;right)isFull = false; if (root-&gt;right &amp;&amp; !root-&gt;left)isFull = false; dfs(root-&gt;left); dfs(root-&gt;right);}int main(){ int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; post[i]; } for (int i = 0; i &lt; n; i++) { cin &gt;&gt; in[i]; } root = build(0, n - 1, 0, n - 1); root-&gt;level = 1; dfs(root); int m; cin &gt;&gt; m; getchar(); while (m--) { bool flag = false; int a, b; string s; getline(cin, s); if (s.find(\"root\") != string::npos) { sscanf(s.c_str(), \"%d is the root\", &amp;a); flag = root-&gt;v == a ? true : false; } else if (s.find(\"siblings\") != string::npos) { sscanf(s.c_str(), \"%d and %d are siblings\", &amp;a, &amp;b); flag = v2node[a]-&gt;parent == v2node[b]-&gt;parent ? true : false; } else if (s.find(\"parent\") != string::npos) { sscanf(s.c_str(), \"%d is the parent of %d\", &amp;a, &amp;b); flag = v2node[a] == v2node[b]-&gt;parent ? true : false; } else if (s.find(\"left\") != string::npos) { sscanf(s.c_str(), \"%d is the left child of %d\", &amp;a, &amp;b); flag = v2node[b]-&gt;left == v2node[a] ? true : false; } else if (s.find(\"right\") != string::npos) { sscanf(s.c_str(), \"%d is the right child of %d\", &amp;a, &amp;b); flag = v2node[b]-&gt;right == v2node[a] ? true : false; } else if (s.find(\"level\") != string::npos) { sscanf(s.c_str(), \"%d and %d are on the same level\", &amp;a, &amp;b); flag = v2node[a]-&gt;level == v2node[b]-&gt;level ? true : false; } else { flag = isFull; } if (flag) cout &lt;&lt; \"Yes\" &lt;&lt; endl; else cout &lt;&lt; \"No\" &lt;&lt; endl; }}    这个优化版的得益于string的find函数，之前知道这个函数，但没用过，所以没敢用，结果就是写出了屎山。find还是很好使的，find不到了就会返回string::npos。    还有一个函数，之前从来没用过，就是sscanf，可以像scanf那样读取一个字符串，这个字符串可以设置为已有的字符串，就是得是char数组，只要用c_str()转化下就行了。" }, { "title": "PAT-Forever & Merging Linked Lists & Postfix Expression & Dijkstra Sequence", "url": "/posts/PAT-Forever-&-Merging-Linked-Lists-&-Postfix-Expression-&-Dijkstra-Sequence/", "categories": "算法刷题, PAT", "tags": "素数, 最大公因数, dfs, 排序, 链表, 二叉树的遍历, 后缀表达式, Dijkstra", "date": "2022-08-29 10:12:00 +0000", "snippet": "    算法笔记基本上刷了一遍了（有些没看，哈夫曼树、欧几里得算法、组合数、提高篇（6）和专题扩展都没看），这几天模拟训练下子，过几天回学校了把没看的看看。    2h22min91分，四道题都写完了，但第一题和第三题没拿满分，第一题差3分，第三题差6分。最后剩7min的时候，第一题查出问题了，94分，但第三题到最后也没改对。A1160 Forever#include&lt;iostream...", "content": "    算法笔记基本上刷了一遍了（有些没看，哈夫曼树、欧几里得算法、组合数、提高篇（6）和专题扩展都没看），这几天模拟训练下子，过几天回学校了把没看的看看。    2h22min91分，四道题都写完了，但第一题和第三题没拿满分，第一题差3分，第三题差6分。最后剩7min的时候，第一题查出问题了，94分，但第三题到最后也没改对。A1160 Forever#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 10000000;bool prime[maxn] = { false }, flag;vector&lt;pair&lt;int, int&gt;&gt; p;vector&lt;int&gt; digits;int k, sum;void Era(){ for (int i = 2; i &lt; maxn; i++) { if (prime[i] == false) { for (int j = i * 2; j &lt; maxn; j += i) { prime[j] = true; } } }}int gcd(int a, int b){ if (b != 0) return gcd(b, a % b); else return a;}bool comp(pair&lt;int, int&gt;&amp; p1, pair&lt;int, int&gt;&amp; p2){ if (p1.first != p2.first) return p1.first &lt; p2.first; else return p1.second &lt; p2.second;}void dfs(int pos, int curSum){ if (curSum &gt; sum || curSum + (k - pos) * 9 &lt; sum || pos &gt; k) { return; } else if (pos == k &amp;&amp; curSum == sum) { int n = sum, a = 0; for (int i = digits.size() - 1, j = 1; i &gt;= 0; i--, j *= 10) { a += digits[i] * j; } int num = a; while (a % 10 == 9) { n -= 9; a /= 10; } n += 1; int gcdmn = gcd(sum, n); if (gcdmn &gt; 2 &amp;&amp; prime[gcdmn] == false) { flag = true; p.emplace_back(make_pair(n, num)); //cout &lt;&lt; n &lt;&lt; ' ' &lt;&lt; num &lt;&lt; endl;; } return; } for (int i = 0; i &lt;= 9; i++) { digits.emplace_back(i); dfs(pos + 1, curSum + i); digits.pop_back(); }}int main(){ Era(); int N; cin &gt;&gt; N; for (int i = 1; i &lt;= N; i++) { flag = false; p.clear(); cin &gt;&gt; k &gt;&gt; sum; cout &lt;&lt; \"Case \" &lt;&lt; i &lt;&lt; endl; for (int j = 1; j &lt;= 9; j++) { digits.emplace_back(j); dfs(1, j); digits.pop_back(); } if (flag == false) { cout &lt;&lt; \"No Solution\" &lt;&lt; endl; } else { sort(p.begin(), p.end(), comp); for (int j = 0; j &lt; p.size(); j++) { cout &lt;&lt; p[j].first &lt;&lt; ' ' &lt;&lt; p[j].second &lt;&lt; endl; } } }}    这道题挺巧的，考察内容很多，所以第一题写了将近50min，考察了素数、最大公因数、dfs和排序。一开始有3分没拿到，就是因为忘排序了，按n升序排，如果出现n一样的再按A来排，还好就一个测试点需要排序。A1161 Merging Linked Lists#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;using namespace std;const int maxn = 100010;int address2v[maxn], address2next[maxn];vector&lt;int&gt; l1, l2;void printList(vector&lt;int&gt;&amp; l1, vector&lt;int&gt;&amp; l2)//l1&gt;l2{ int i = 0, j = l2.size() - 1; for (; i &lt; l1.size() &amp;&amp; j &gt;= 0; i+=2, j--) { printf(\"%05d %d %05d\\n\", l1[i], address2v[l1[i]], l1[i + 1]); printf(\"%05d %d %05d\\n\", l1[i + 1], address2v[l1[i + 1]], l2[j]); if (l1.size() != i+2) { printf(\"%05d %d %05d\\n\", l2[j], address2v[l2[j]], l1[i + 2]); } else printf(\"%05d %d -1\\n\", l2[j], address2v[l2[j]]); } for (; i &lt; l1.size(); i++) { if(i != l1.size() -1) printf(\"%05d %d %05d\\n\", l1[i], address2v[l1[i]], l1[i + 1]); else printf(\"%05d %d -1\\n\", l1[i], address2v[l1[i]]); }}int main(){ int head1, head2, n; cin &gt;&gt; head1 &gt;&gt; head2 &gt;&gt; n; while (n--) { int addr; cin &gt;&gt; addr; cin &gt;&gt; address2v[addr] &gt;&gt; address2next[addr]; } while (head1 != -1) { l1.emplace_back(head1); head1 = address2next[head1]; } while (head2 != -1) { l2.emplace_back(head2); head2 = address2next[head2]; } if (l1.size() &gt; l2.size()) { printList(l1, l2); } else { printList(l2, l1); }}    这个就是链表题，一开始题没审清，按a1-&gt;a2-&gt;b1-&gt;a3-&gt;a4-&gt;b2的顺序输出了，b数组（短的那个）应该要倒过来输出。A1162 Postfix Expression#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;using namespace std;const int maxn = 25;bool isRoot[maxn] = { false };struct node{ int left, right; string syntax;}tree[maxn];void travelsal(int root){ if (root == -1) return; cout &lt;&lt; '('; if (tree[root].left == -1) { cout &lt;&lt; tree[root].syntax; travelsal(tree[root].right); } else { travelsal(tree[root].left); travelsal(tree[root].right); cout &lt;&lt; tree[root].syntax; } cout &lt;&lt; ')';}int main(){ int n, root; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; tree[i].syntax &gt;&gt; tree[i].left &gt;&gt; tree[i].right; isRoot[tree[i].left] = isRoot[tree[i].right] = true; } for (int i = 1; i &lt;= n; i++) { if (isRoot[i] == false) root = i; } travelsal(root);}    这道题亏在不是很懂后缀表达式上了，我看样例里负号是要先打印的，所以我就加了个特判，如果遇到负号，就先序遍历，其他的符号都是后序遍历，但测试点4一直过不去，还6分呢，我一开始猜会不会还有别的符号跟负号一样要先序，但没试出来。    后来查了啥是后缀表达式，我看人家的负号跟其他负号的安排是一样的，都是后打印，所以应该是这的问题，负号有两种情况，一种是后打印（作为双目运算符），另一种就是先打印，就是取相反数。看了一个博客，他是按左孩子空为条件改先序遍历的，我试了下，果然是这样。如果左孩子是空的，说明这个负号（也有可能是其他啥负号）就要先打印，如果左孩子不空（其实右孩子也就不空了），就要后打印。A1163 Dijkstra Sequence#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;using namespace std;const int maxn = 1010;const int inf = 0x3fffffff;int neighbor[maxn][maxn], dis[maxn];bool vis[maxn] = {false};int n, m, k;vector&lt;int&gt; sequence;bool Dijkstra(int s){ fill(dis, dis + maxn, inf); fill(vis, vis + maxn, false); dis[s] = 0; int index = 0; for (int i = 0; i &lt; n; i++) { int u = -1, min = inf; for (int j = 1; j &lt;= n; j++) { if (vis[j] == false ) { if (dis[j] &lt; min) { min = dis[j]; u = j; } else if (dis[j] == min) { if (j == sequence[index]) { u = j; } } } } //if (u == -1) return true; if (u != sequence[index]) return false; index++; vis[u] = true; for (int v = 1; v &lt;= n; v++) { if (vis[v] == false &amp;&amp; neighbor[u][v] != inf) { if (neighbor[u][v] + dis[u] &lt; dis[v]) { dis[v] = neighbor[u][v] + dis[u]; } } } } return true;}int main(){ fill(neighbor[0], neighbor[0] + maxn * maxn, inf); cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; i++) { int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; neighbor[u][v] = neighbor[v][u] = w; } cin &gt;&gt; k; for (int i = 0; i &lt; k; i++) { sequence.clear(); int tmp = 0; for (int i = 0; i &lt; n; i++) { int v; cin &gt;&gt; v; sequence.emplace_back(v); } if (Dijkstra(sequence[0])) cout &lt;&lt; \"Yes\" &lt;&lt; endl; else cout &lt;&lt; \"No\" &lt;&lt; endl; }}    这道题我一开始还担心如果每次询问都做一遍Dijkstra会超时，但看来是我多虑了。    一开始因为担心超时，所以就做一次Dijkstra，记录最短路径长度，去遍历每个序列，先看两两之间是不是有路，在看最后路的长度是不是等于最短路径，但这么做是大错特错的。    因为所谓Dijkstra序列，指的不是路径而是vis = true的顺序，这个顺序和路径顺序是不一样的，这个vis = true的顺序，相邻两个节点是有可能没路的。所以要稍加修改Dijkstra函数，最后每次都做一遍Dijkstra就行了，也没超时。    写完这个题还剩38分钟，就去检查之前没过的测试点了。" }, { "title": "PAT-Stack", "url": "/posts/PAT-Stack/", "categories": "算法刷题, PAT", "tags": "块", "date": "2022-08-28 14:12:00 +0000", "snippet": "A1057Stack#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 100001;const int maxb = 317;int tab...", "content": "A1057Stack#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 100001;const int maxb = 317;int table[maxn], block[maxb];int n, cnt;int main(){ memset(table, 0, sizeof(table)); memset(block, 0, sizeof(block)); cin &gt;&gt; n; stack&lt;int&gt; st; for (int i = 0; i &lt; n; i++) { string s; cin &gt;&gt; s; if (s == \"Pop\") { if (st.empty()) { cout &lt;&lt; \"Invalid\\n\"; } else { int num = st.top(); st.pop(); table[num]--; //算块号 block[num / 316]--; cout &lt;&lt; num &lt;&lt; endl; } } else if (s == \"PeekMedian\") { if (st.empty()) { cout &lt;&lt; \"Invalid\\n\"; continue; } int median = (st.size() + 1) / 2; int sum = 0, b = 0;//b块号 while (sum + block[b] &lt; median) { sum += block[b++]; } int index = b * 316; while (sum + table[index] &lt; median) { sum += table[index++]; } cout &lt;&lt; index &lt;&lt; endl; } else { int num; cin &gt;&gt; num; st.push(num); table[num]++; block[num / 316]++; } }}    这道题使用了分块的思想，很巧妙，注意： 在取中位数时，可以使用while，更方便快捷 输出中位数直接输出index，table[index]代表的时index的个数 用sum来表示之前块的个数，然后直接从所属块第一个开始查，我之前是算出median是第几个后，企图计算出在b块的第几个，不记录sum的话，没法算，要么就算个前缀和数组，随时查，要么就临时记录 " }, { "title": "PAT-Public Bike Management & Pop Sequence & Mice and Rice", "url": "/posts/PAT-Public-Bike-Management-&-Pop-Sequence-&-Mice-and-Rice/", "categories": "算法刷题, PAT", "tags": "SPFA, 栈, 队列", "date": "2022-08-27 14:43:00 +0000", "snippet": "A1018 Public Bike Management#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;queue&gt;using namespace std;struct node{ int v, w; node(int _v, int _w) :v(_v),...", "content": "A1018 Public Bike Management#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;queue&gt;using namespace std;struct node{ int v, w; node(int _v, int _w) :v(_v), w(_w) {}};const int maxn = 510;const int inf = 0x3fffffff;vector&lt;vector&lt;node&gt;&gt; neighbor(maxn);int bikes[maxn], send[maxn], dis[maxn], pre[maxn], take[maxn];bool inq[maxn];int c, n, s, m;void SPFA(int s){ fill(inq + 1, inq + n + 1, false); fill(dis + 1, dis + n + 1, inf); fill(send, send + n + 1, 0); fill(take, take + n + 1, 0); dis[s] = 0; queue&lt;int&gt; q; q.push(s); inq[s] = true; while (!q.empty()) { int u = q.front(); q.pop(); inq[u] = false; for (node n : neighbor[u]) { int v = n.v, w = n.w; if (dis[u] + w &lt; dis[v]) { dis[v] = dis[u] + w; pre[v] = u; if (bikes[v] &gt;= c / 2) { send[v] = send[u]; take[v] = take[u] + bikes[v] - c / 2; } else { int cur = take[u] - (c / 2 - bikes[v]); if (cur &lt; 0) { send[v] = send[u] - cur; take[v] = 0; } else { send[v] = send[u]; take[v] = cur; } } if (inq[v] == false) { q.push(v); inq[v] = true; } } else if (dis[u] + w == dis[v]) { //先算出现这条最短路的send和take int curs, curt; if (bikes[v] &gt;= c / 2) { curs = send[u]; curt = take[u] + bikes[v] - c / 2; } else { int cur = take[u] - (c / 2 - bikes[v]); if (cur &lt; 0) { curs = send[u] - cur; curt = 0; } else { curs = send[u]; curt = cur; } } if (curs &lt; send[v] ||(curs == send[v] &amp;&amp; curt &lt; take[v])) { pre[v] = u; send[v] = curs; take[v] = curt; if (inq[v] == false) { q.push(v); inq[v] = true; } } } } }}void dfs(int s){ if (s == 0) { cout &lt;&lt; 0; return; } dfs(pre[s]); cout &lt;&lt; \"-&gt;\" &lt;&lt; s;}int main(){ cin &gt;&gt; c &gt;&gt; n &gt;&gt; s &gt;&gt; m; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; bikes[i]; } for (int i = 0; i &lt; m; i++) { int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; neighbor[u].emplace_back(node(v, w)); neighbor[v].emplace_back(node(u, w)); } SPFA(0); cout &lt;&lt; send[s] &lt;&lt; ' '; dfs(s); cout &lt;&lt; ' ' &lt;&lt; take[s];}    这题之前用dfs做过，代码量也不长，但这次为了熟悉下SPFA算法，就拿这道题试试刀，结果就出问题了，先说最大的问题，测试点7过不去，是因为dis可以用最短路算法，但send和take不能，这个有点复杂，题目要求的是终点send和take大小比较，但最短路的判断过程中，每个点的send和take都是最优的，但局部最优不一定是全局最优，所以如果非要用SPFA，那还得把所有相等的路径存起来，算每条路终点的send和take，进行比较才行，真遇到这种send和take计算比较复杂的，还是用深度优先遍历吧，只有到终点的时候再判断是不是要这条路。SPFA算法注意： 我的判断很繁琐，时刻注意更新send和take数组，一旦忘一个，就有可能出错 一开始我只想用一个send数组，根据正负来判断送车还是带回车，结果就是拿了20分，其实也不错了哈哈哈，但send这个比较特殊，后面车站的车不能send到前一个 #include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int C, N, Sp, M;//C站点最大车数，N站点数（0,1~N），Sp问题车站编号，M路径数int bike[501];//每个站点车数vector&lt;int&gt;v[501];//每个站点的邻居int dis[501][501];//站点间距离int minDis[501];vector&lt;int&gt;path;vector&lt;int&gt;finalPath;int finalDis,finalSend,finalTake;void dfs(int curStation,int curDis,int curSend,int curTake){ //先判断距离是否大于最小距离 if(curDis &gt; minDis[curStation]) return; //将该节点加入路径 path.emplace_back(curStation); //判断是否抵达问题车站 if(curStation == Sp) { if ( curDis &lt; minDis[curStation]) { minDis[curStation] = curDis; finalDis = curDis; finalSend = curSend; finalTake = curTake; finalPath = path; } else if (curDis == minDis[curStation])//路径长度相等时 { if(curSend &lt; finalSend)//发送车辆少的优先 { finalSend = curSend; finalTake = curTake; finalPath = path; } else if (curSend == finalSend)//发送车辆相同 { if(curTake &lt; finalTake)//带回车辆少的 { finalTake = curTake; finalPath = path; } } } } else//如果没有抵达问题车站 { if(curDis &lt; minDis[curStation])minDis[curStation] = curDis; for (int i = 0; i &lt; v[curStation].size(); i++) { int j = v[curStation][i];//邻居编号 if(bike[j] + curTake &lt;= (C / 2)) dfs(j, curDis + dis[curStation][j],curSend + (C / 2) - bike[j] - curTake,0 ); else if (bike[j] + curTake &gt; (C / 2))dfs(j, curDis + dis[curStation][j],curSend, bike[j] + curTake - (C / 2)); } } path.pop_back();} int main() { int i,j,k; cin&gt;&gt;C&gt;&gt;N&gt;&gt;Sp&gt;&gt;M; for ( i = 1; i &lt;= N; i++) { cin&gt;&gt;j; bike[i] = j; } while(M--) { cin&gt;&gt;i&gt;&gt;j&gt;&gt;k; dis[i][j] = dis[j][i] = k;//距离矩阵 v[i].emplace_back(j); v[j].emplace_back(i); } ////////// for (i = 0; i &lt;= N; i++) minDis[i] = 99999999; dfs(0,0,0,0); //输出 cout&lt;&lt;finalSend&lt;&lt;' '&lt;&lt;0; for ( i = 1; i &lt; finalPath.size(); i++) { cout&lt;&lt;\"-&gt;\"&lt;&lt;finalPath[i]; } cout&lt;&lt;' '&lt;&lt;finalTake; }    这是dfs版本。A1051 Pop Sequence#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;stack&gt;using namespace std;int m, n, k;int main(){ cin &gt;&gt; m &gt;&gt; n &gt;&gt; k; for (int i = 0; i &lt; k; i++) { stack&lt;int&gt; s; vector&lt;int&gt; sequence(n); for (int j = 0; j &lt; n; j++) { cin &gt;&gt; sequence[j]; } int order = 1, seIndex = 0; bool flag = true; for(seIndex = 0; seIndex &lt; n; seIndex++) { if (s.empty()) s.push(order++); while (sequence[seIndex] != s.top() &amp;&amp; s.size() &lt; m) { s.push(order++); } if (sequence[seIndex] == s.top()) { s.pop(); } else if (s.size() == m) { cout &lt;&lt; \"NO\" &lt;&lt; endl; flag = false; break; } } if(flag) cout &lt;&lt; \"YES\" &lt;&lt; endl; }}    非常朴素的想法，就是用栈来模拟，中间debug了会儿，发现给数组赋值的时候赋错了，sequence[j]里面写成i了，怪不得一开始全是NO，数组里只有一个数据，麻了。A1056 Mice and Rice#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;/*0 1 2 3 4 5 6 7 8 9 1025 18 0 46 37 3 19 22 57 56 106 0 8 7 10 5 9 1 4 2 319 25 57 22 10 3 56 18 37 0 46 5 5 5 2 5 5 5 3 1 3 5*/struct player{ int w, r;};const int maxn = 1010;vector&lt;player&gt; playerlist(maxn);int p, g;int main(){ cin &gt;&gt; p &gt;&gt; g; for (int i = 0; i &lt; p; i++) { cin &gt;&gt; playerlist[i].w; } queue&lt;int&gt; q; int groupCnt, matchMem = p; for (int i = 0; i &lt; p; i++) { int order; cin &gt;&gt; order; q.push(order); } while (q.size() != 1) { matchMem = q.size(); if (matchMem % g == 0) groupCnt = matchMem / g; else groupCnt = matchMem / g + 1; for (int i = 0; i &lt; groupCnt; i ++) { int max = q.front(); playerlist[q.front()].r = groupCnt + 1; q.pop(); for (int j = 1; j &lt; g; j++) { if (i * g + j &gt;= matchMem) break; if (playerlist[q.front()].w &gt; playerlist[max].w) { max = q.front(); } playerlist[q.front()].r = groupCnt + 1; q.pop(); } q.push(max); } } playerlist[q.front()].r = 1; for (int i = 0; i &lt; p; i++) { if (i != 0) cout &lt;&lt; ' '; cout &lt;&lt; playerlist[i].r; }}    队列的一道模拟题，有点绕，有两点非常重要：他给的顺序意思是6号第一个，0号第二个，8号第三个……而不是0号是第6个，1号是第0个，2号是第8个，因为我理解错了，测试样例就没看懂，卡住了。第二处就是，我在想怎么搞排名，要不要用栈来存淘汰的，最后再输出排名，但实际上淘汰的时候就已经知道排名了，只要能够算出组数，那么淘汰的人的名次就是组数+1，这一点很巧妙，省下很多功夫。注意： 每一组的名次都可以先赋值成淘汰者的名次，因为晋级的话，会更新的，最后只需要把冠军再单独更新下就行了 比的是每个老鼠的重量，而不是编号:( " }, { "title": "晴问-最小生成树 & 最小造路成本 & 最大删边权值 & 最小连通成本", "url": "/posts/%E6%99%B4%E9%97%AE-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-&-%E6%9C%80%E5%B0%8F%E9%80%A0%E8%B7%AF%E6%88%90%E6%9C%AC-&-%E6%9C%80%E5%A4%A7%E5%88%A0%E8%BE%B9%E6%9D%83%E5%80%BC-&-%E6%9C%80%E5%B0%8F%E8%BF%9E%E9%80%9A%E6%88%90%E6%9C%AC/", "categories": "算法刷题", "tags": "MST, Prime, Kruskal", "date": "2022-08-26 09:00:00 +0000", "snippet": "最小生成树-Prim算法#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;using namespace std;struct node{ int v, w; node(int _v, int _w) :v(_v), w(_w) {}};const int inf = 0x3fffffff;co...", "content": "最小生成树-Prim算法#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;using namespace std;struct node{ int v, w; node(int _v, int _w) :v(_v), w(_w) {}};const int inf = 0x3fffffff;const int maxn = 510;vector&lt;vector&lt;node&gt;&gt; neighbor(maxn);int n, m, sum, dis[maxn];bool vis[maxn] = {false};void Prime(int s){ fill(dis, dis + n, inf); dis[s] = 0; sum = 0; for (int i = 0; i &lt; n; i++) { int u = -1, min = inf; for (int j = 0; j &lt; n; j++) { if (vis[j] == false &amp;&amp; dis[j] &lt; min) { min = dis[j]; u = j; } } if (u == -1) { sum = -1; return; } vis[u] = true; sum += dis[u]; for (node n : neighbor[u]) { if (vis[n.v] == false &amp;&amp; n.w &lt; dis[n.v]) { dis[n.v] = n.w; } } }}int main(){ cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; i++) { int v1, v2, w; cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w; neighbor[v1].emplace_back(node(v2, w)); neighbor[v2].emplace_back(node(v1, w)); } Prime(0); cout &lt;&lt; sum;}    和Dijkstra算法很像，唯一不同的就是Dijkstra更新dis数组是更新的源点到某个点的最短距离，而Prime算法更新的是已遍历集合（即vis为true的所有节点中任意一个）到某个点的最短距离。注意： 因为每次都将一个节点加入已遍历集合中，所以一定会遍历n次，如果遍历n次前就退出循环，说明不是连通图 中间debug时，法线大括号括错位置了……新的错误类型，麻了 最小生成树-Kruskal算法#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;const int maxe = 100010;const int maxn = 10010;struct edge{ int u, v, w; edge(int _u, int _v, int _w) :u(_u), v(_v), w(_w) {}};vector&lt;edge&gt; E;int n, m, sum, father[maxn];int Find(int x){ int a = x; while (x != father[x]) { x = father[x]; } //路径压缩 while (a != father[a]) { int z = a; a = father[a]; father[z] = x; } return x;}bool comp(edge&amp; e1, edge&amp; e2){ return e1.w &lt; e2.w;}int Kruskal(){ sum = 0; int edgeN = 0; for (int i = 0; i &lt; n; i++) { father[i] = i; } sort(E.begin(), E.end(), comp); for (int i = 0; i &lt; E.size(); i++) { int u = E[i].u, v = E[i].v, w = E[i].w; int faU = Find(u); int faV = Find(v); if (faU != faV) { father[faV] = faU; sum += w; edgeN++; if (edgeN == n - 1) break; } } if (edgeN == n - 1) return sum; else return -1;}int main(){ cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; i++) { int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; E.emplace_back(edge(u, v, w)); } cout&lt;&lt;Kruskal();}    这个算法很简单，就是根据边权把边排序，判断边的两个端点是否属于一个块，不属于的话这条边就加入最小生成树中去，正所谓边贪心。注意： 在find函数里，我查父亲的时候，while写成if了，麻了，这也行 第二处错就是在判断是否属于一块的时候，查两个点的父亲，如果不是一个父亲，意味着不是一块，那么该边加入最小生成树的边，此时两个父亲应该选择其中一个成为对方的父亲，而不是两个点中间选一个成为对方父亲，这样的话会使答案偏小。因为本来某两个点该成为一个家族，但因为不是父亲联合了，而是父亲的孩子联合了，那么就可能导致了父亲的其他孩子没联系起来，也就是说容易误判为不是一块，那么自然也就越快结束，那么就说明边权和会变小。 最小造路成本#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;const int maxn = 100;const int inf = 0x3fffffff;int w[maxn][maxn], n, dis[maxn];bool vis[maxn] = { false };int Prime(int s){ for (int i = 0; i &lt; n; i++) { dis[i] = inf; } dis[s] = 0; int sum = 0; for (int i = 0; i &lt; n; i++) { int u = -1, min = inf; for (int j = 0; j &lt; n; j++) { if (vis[j] == false &amp;&amp; dis[j] &lt; min) { u = j; min = dis[u]; } } if (u == -1) { return -1; } sum += dis[u]; vis[u] = true; for (int j = 0; j &lt; n; j++) { if (vis[j] == false &amp;&amp; w[u][j] &lt; dis[j]) { dis[j] = w[u][j]; } } } return sum;}int main(){ cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { cin &gt;&gt; w[i][j]; } } cout &lt;&lt; Prime(0);}    这道题使用Prime算法，因为这道题，点很少就100个，但边很多，每两个点之间就有一条边。Prime算法擅长处理点少边多的稠密图，因为邻接矩阵写法，复杂度为$O(V^2)$，使用邻接表的堆优化复杂度为$O(VlogV + E)$（我没写过这个堆优化的，所以还不知道这个E咋来的）最大删边权值#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;const int maxn = 100;const int inf = 0x3fffffff;int w[maxn][maxn], n, m, dis[maxn];bool vis[maxn] = { false };int Prime(int s){ for (int i = 0; i &lt; n; i++) { dis[i] = inf; } dis[s] = 0; int sum = 0; for (int i = 0; i &lt; n; i++) { int u = -1, min = inf; for (int j = 0; j &lt; n; j++) { if (vis[j] == false &amp;&amp; dis[j] &lt; min) { u = j; min = dis[u]; } } if (u == -1) { return -1; } sum += dis[u]; vis[u] = true; for (int j = 0; j &lt; n; j++) { if (vis[j] == false &amp;&amp; w[u][j] &lt; dis[j]) { dis[j] = w[u][j]; } } } return sum;}int main(){ cin &gt;&gt; n &gt;&gt; m; fill(w[0], w[0] + maxn * maxn, inf); int totalW = 0; for (int i = 0; i &lt; m; i++) { int _u, _v, _w; cin &gt;&gt; _u &gt;&gt; _v &gt;&gt; _w; w[_u][_v] = w[_v][_u] = _w; totalW += _w; } int minW = Prime(0); if (minW == -1) cout &lt;&lt; -1; else cout &lt;&lt; totalW - minW;}    图方便，用了上一题的邻接矩阵，没有用物品平时经常用的邻接表，就出错了哈哈。注意： 二维邻接表使用fill初始化时，要fill(w[0], w[0] + maxn * maxn, inf);这样，不加[0]就会中断 在输入邻接表的时候，一定要记得邻接矩阵两个对称的位置都要赋值，就像邻接表也要往两个表里互相填值一样 最后注意判定，如果Prime后返回-1了，就直接输出就行，别再减了最小连通成本#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;struct edge{ int u, v, w; edge(int _u, int _v, int _w) : u(_u), v(_v), w(_w) {}};const int maxn = 100;const int inf = 0x3fffffff;int n, k, w[maxn][maxn], connect[maxn], father[maxn];vector&lt;edge&gt; E;bool comp(edge&amp; e1, edge&amp; e2){ return e1.w &lt; e2.w;}int Find(int x){ int a = x; while (x != father[x]) { x = father[x]; } while (a != father[a]) { int z = a; a = father[a]; father[z] = x; } return x;}int Kuraskal(){ int sum = 0, edgeCnt = 0; for (int i = 0; i &lt; n; i++) { father[i] = i; } for (int i = 0; i &lt; k; i++) { father[connect[i]] = connect[0]; } for (int i = 0; i &lt; n - 1; i++) { for (int j = i + 1; j &lt; n; j++) { if (w[i][j] != inf) { E.emplace_back(edge(i, j, w[i][j])); } } } sort(E.begin(), E.end(), comp); for (int i = 0; i &lt; E.size(); i++) { int faU = Find(E[i].u); int faV = Find(E[i].v); if (faU != faV) { sum += E[i].w; edgeCnt++; father[faV] = faU; if (edgeCnt == n - k) return sum; } } return -1;}int main(){ cin &gt;&gt; n &gt;&gt; k; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { cin &gt;&gt; w[i][j]; } } for (int i = 0; i &lt; k; i++) { cin&gt;&gt;connect[i]; } for (int i = 0; i &lt; k - 1; i++) { for (int j = i + 1; j &lt; k; j++) { w[connect[i]][connect[j]] = w[connect[j]][connect[i]] = inf; } } cout &lt;&lt; Kuraskal();}    这道题因为有的结点已经连通，那么所有连通的点之间的边都不能再选了，所以此时使用Kruskal比较方便，有两点需要注意： 第一就是，因为已经有点连通了，所以就是求剩下的点和已经连通了的这一块的最小生成树，那么边等于n-k时，就算找完了 第二就是，因为已经连通的结点算一个块，所以要初始化他们的父亲为同一个，不然的话，就有可能存在多条边连向这一块的不同节点，可能导致结果偏小 " }, { "title": "GAMES101-Lecture 09 Shading3(Texture Mapping cont.)", "url": "/posts/GAMES101-Lecture-09-Shading3(Texture-Mapping-cont.)/", "categories": "Computer Graphics, GAMES101", "tags": "图形学, 学习笔记", "date": "2022-08-25 15:00:00 +0000", "snippet": "Interpolation Across Triangles: Barycentric Coordinates(重心坐标) 为了获得三角形内值的平滑过渡 纹理坐标、颜色、法线的插值 Barycentric Coordinates：重心坐标是定义在一个三角形上的$(\\alpha, \\beta , \\gamma)$ \\[(x,y)=\\alpha A+\\be...", "content": "Interpolation Across Triangles: Barycentric Coordinates(重心坐标) 为了获得三角形内值的平滑过渡 纹理坐标、颜色、法线的插值 Barycentric Coordinates：重心坐标是定义在一个三角形上的$(\\alpha, \\beta , \\gamma)$ \\[(x,y)=\\alpha A+\\beta B + \\gamma C\\\\\\alpha+ \\beta + \\gamma =1\\] 三角形是二维的，所以用两个数就可以表示，因此三个未知数知道两个即可 如果点在三角形内部，那么$\\alpha、 \\beta 、\\gamma$都是非负的 A点的重心坐标$(\\alpha, \\beta ,\\gamma)=(1,0,0)$就是A点自己 计算任何一点的重心坐标：（$A_A、B_B、C_C$代表的是面积） \\[\\alpha = \\frac{A_A}{A_A+B_B+C_C}\\\\\\beta = \\frac{B_B}{A_A+B_B+C_C}\\\\\\gamma = \\frac{C_C}{A_A+B_B+C_C}\\] $(\\alpha, \\beta ,\\gamma)=(1/3,1/3,1/3)$是三角形的重心 计算每个点的重心坐标的一般公式：(懒得手打了，免得敲半天再像作业1时候那样敲错) 使用重心坐标：\\[V=\\alpha V_A + \\beta V_B+\\gamma V_C\\] V可以是位置、纹理坐标、颜色、法线、深度、材质属性 缺点：投影前后对同一个三角形内得同一个点求重心坐标很有可能就不同了 所以如果是三维空间内，那就求三维空间内的重心坐标：屏幕上的一个像素逆变换回去，到三维空间中，求出该像素的重心坐标，再插值 Applying Textrue 已知的是三角形顶点的uv，通过重心坐标就可以求得三角形内任意一点的uv，就可以获得uv图的信息了 可以认为，纹理定义的就是漫反射系数 Texture Magnification(纹理的放大) 纹理图相较于物体太小，很高清的墙，贴了一张很低清的图 a pixel on a texture - a texel(纹理元素) Bilinear interpolation 双线性插值 先横向插值得到u0和u1，再纵向插值，得到最终的点的颜色值，我认为可以根据分割的四个矩形的面积来分配四个点对目标点的贡献 缺点：质量还是差一些 Bicubic interpolation 双三次插值：取一个点临近16个点，做插值，每四个做三次的插值（不是线性）Texture Magnification(hard case) 纹理相对物体过大 走样 屏幕上的像素覆盖的纹理上的区域大小是不相同的（近处的像素覆盖小，也就是说物体对于纹素较小，取最近的点就会产生锯齿；而远处的像素覆盖大，也就是物体对于文素来说较大，需要取平均而产生摩尔纹） 解决： 超采样：开销太大 避免采样：Range Query（范围查询）Mipmap ：允许（快速、近似、方形）的范围查询 在渲染之前把一张纹理的mipmap都生成 只是多了1/3的存储量 可以这么想，把第0层复制三份，放在左上右上和左下，接着把第1层放在右下角方块的左上右上和左下，然后递归，最后会发现，第一层和往上的所有层复制三份后刚好是一份第0层，所以就是1/3 ComPuting Mipmap Level D: 图解：某个像素取其上面和右面的像素，映射到uv图（先从投影也就是光栅化后的像素映射回三维空间中的点（使用逆变换），插值得到uv的坐标），计算在uv图上，两点距离中心点的距离（其实是微分，理解成中心点移动到右边或者上边点的距离），L1和L2，L取二者较大值，以L为近似方形的边长，$D=log_2L$。如果区域为1*1，那么D=0，说明就在原来的纹理图上，如果区域为4*4，那么D=2，说明在第2张纹理图（32*32）上，该区域代表这张纹理图的一个像素 mipmap缺点是不是渐变的，层数是离散的，所以怎么办呢，插值！ Trilinear Interpolation三线性插值查第1.8层（带小数）的，先分别在第1层和第2层分别在自己对应的uv图上通过双线性插值算一个值，再把计算得来的两个值做一次线性插值。在游戏的实时渲染中应用很广泛。 在远处会发现糊掉了，叫做overblur，过分模糊，如上图 原因：正方形区域导致 解决：Anisotropic Filtering 各向异性过滤，这样就可以近似成长方形，可以在一个长条形区域快速查询(Ripmap)。但仍然存在问题：就是如果是个倾斜的矩形，还是不好框。而且除此之外，开销增加了3倍。还会选择几x，选择2x就是算到第二层 EWA filtering : 拆成很多不同的圆形去覆盖一个不规则的矩形（多次查询），代价开销大 作业3 作业描述：     在这次编程任务中，我们会进一步模拟现代图形技术。我们在代码中添加了 Object Loader(用于加载三维模型), Vertex Shader 与 Fragment Shader，并且支持 了纹理映射。     而在本次实验中，你需要完成的任务是: 修改函数 rasterize_triangle(const Triangle&amp; t) in rasterizer.cpp: 在此 处实现与作业 2 类似的插值算法，实现法向量、颜色、纹理颜色的插值。 修改函数 get_projection_matrix() in main.cpp: 将你自己在之前的实验中 实现的投影矩阵填到此处，此时你可以运行 ./Rasterizer output.png normal 来观察法向量实现结果。 修改函数 phong_fragment_shader() in main.cpp: 实现 Blinn-Phong 模型计 算 Fragment Color. 修改函数 texture_fragment_shader() in main.cpp: 在实现 Blinn-Phong 的基础上，将纹理颜色视为公式中的 kd，实现 Texture Shading Fragment Shader. 修改函数 bump_fragment_shader() in main.cpp: 在实现 Blinn-Phong 的 基础上，仔细阅读该函数中的注释，实现 Bump mapping. 修改函数 displacement_fragment_shader() in main.cpp: 在实现 Bump mapping 的基础上，实现 displacement mapping 上来报错namespace “std” has no member “optional”，这是因为optional是C++17新特性，我的vs默认是C++14，在项目属性-&gt;常规中修改标准版本为C++17即可 " }, { "title": "GAMES101-Lecture 08 Shading2(Shading,Pipeline and Texture Mapping)", "url": "/posts/GAMES101-Lecture-08-Shading2(Shading,Pipeline-and-Texture-Mapping)/", "categories": "Computer Graphics, GAMES101", "tags": "图形学, 学习笔记", "date": "2022-08-25 12:53:00 +0000", "snippet": "Blinn-Phong(后半部分)Specular Term(Blinn-Phong) 观察方向和镜面反射方向接近时，就能看到高光项 注视方向加光照方向（平行四边形法则）就能得到半程向量的方向，如果h和n（法线方向）接近，就说明和镜面反射方向很接近，就能看到高光 \\[\\pmb{h}(半程向量)=bisector(\\pmb{v},\\pmb{l})\\\\=\\frac{...", "content": "Blinn-Phong(后半部分)Specular Term(Blinn-Phong) 观察方向和镜面反射方向接近时，就能看到高光项 注视方向加光照方向（平行四边形法则）就能得到半程向量的方向，如果h和n（法线方向）接近，就说明和镜面反射方向很接近，就能看到高光 \\[\\pmb{h}(半程向量)=bisector(\\pmb{v},\\pmb{l})\\\\=\\frac{\\pmb{v}+\\pmb{l}}{\\lVert \\pmb{v}+\\pmb{l}\\rVert}\\] Ls时镜面反射光强度，Ks时镜面系数，其实就是一个颜色（三通道），通常是白色 \\[L_s = k_s(I/r^2)max(0,cos\\alpha)^p\\\\=k_s(I/r^2)max(0,\\pmb{n\\cdot h})^p\\] 直接算R（镜面反射方向）和V向量的点乘是Phong反射模型，半程向量和法向量做点乘叫Blinn-Phong，这是个改进，因为半程向量相对于反射方向向量来说更好算 这里不考虑吸收和不吸收的颜色是因为phong是个经验模型，简化了这一点 加个p的指数是为了降低余弦的“容忍度”，p越大，那么度数增加一点就会让$max(0,\\pmb{n\\cdot h})^p$值下降很多，意味着，偏很小的角度就看不到高光了，p通常取100到200。相同物体，同一方向去看的话，随着p增大，高光范围会逐渐缩小成一个点Ambient Term 假设来自四面八方的环境光照强度一样，那么环境光照强度就是一个常数（实际上不是这样），$k_a$是环境光系数，其实就是颜色，$I_a$是环境光照的强度 \\[L_a = k_aI_a\\] Blinn-Phong Reflection Model Ambient+Diffuse+Specular=Blinn-Phong Reflection \\[L = L_a+L_d+L_s\\\\=k_aI_a+k_d(I/r^2)max(0,\\pmb{n\\cdot l})+k_s(I/r^2)max(0,\\pmb{n\\cdot h})^p\\] Shading Frequencies(着色频率) 要把着色应用在哪些点上 Shade each triangle(flat shading) 计算每个三角形的法线，三角形的两边做一个叉乘 Shade ezch vertex(Gouraud shading) 求每个顶点的法线方向，根据每个顶点的颜色，通过插值来计算顶点内部颜色的大小 三角形顶点的法线可以通过两种主要方法计算: 面法线计算法:首先计算三角形面法向量,再使用向量插值法求出三个顶点的法向量。面法向量可以通过三角形两边向量的叉积求得。此方法的优点是顶点法线与面法线垂直,缺点是不够平滑,会出现明显的法线变化。 法线平滑法:考虑三角形每个顶点附近的所有相邻三角形,使用所有相邻三角形的面法向量计算顶点法线。通过叠加相邻面法向量再归一化得到平滑的顶点法线。此方法可以产生更平滑的法线变化,但法线不再垂直于面。一般来说,法线平滑法可以产生更高质量的渲染结果,所以更为广泛使用。其计算步骤如下: 找出每个顶点p附近的所有相邻三角形。 计算每个相邻三角形的面法线ni。 求出这些面法线的叠加和:n = n1 + n2 + … + nn 对叠加的法线和进行归一化,得到顶点p的平滑法线:np = normalize(n) 利用顶点的平滑法线np和光照参数计算顶点颜色。 使用Gouraud着色,根据三角形每个顶点颜色为三角形内部所有像素点着色。所以,三角形顶点的法线主要通过两种方法计算: 面法线计算法:简单但不够平滑。 法线平滑法:考虑相邻面信息,可以产生平滑的法线,这也是更为常用的方法。平滑的顶点法线为之后的光照计算和Gouraud着色提供信息,能渲染出更高质量的三维图像。 Shade each pixel(Phong shading)(这是一种着色频率) 根据三角形三个顶点的法线，插值求出三角形内部每个像素的法线方向，对每个像素进行着色，根据像素点法线向量和光照参数计算该点的漫反射光强、镜面高光强度等。 flat着色和Gouraud着色区别是：flat每个面一个法线，而Gouraud每个顶点一个法线，也就是每个三角面三个法线，因此计算出来的三个顶点的颜色是不同的，后面插值后，三角面内部的颜色也就是根据这三个顶点插值的 Gouraud着色,Phong着色的区别是：Gouraud直接根据插值计算像素的颜色值，Phong根据插值计算每个像素的法线，然后根据法线再算每个像素的颜色 相比Gouraud着色,Phong着色的主要优势在于: Phong着色在每个像素点都确定一种颜色,而Gouraud着色在三角形内部进行插值。所以Phong着色没有Gouraud着色的马素尔效应,渲染更为平滑。 Phong着色直接使用每个像素点的法线进行光照计算,可以很好的渲染出镜面高光等效果。而Gouraud着色只使用三角形顶点法线,高光效果较差。 Phong着色考虑每个像素点的明确光照,可以产生更真实的阴影效果。Gouraud着色通过色彩插值很难实现精确的阴影。 当面出现的频率较高时，使用平滑着色也可以。 当面数超过像素数，Phong着色开销自然也会比平滑着色小了Defining Per-vertex Normal Vectors 1.考虑是一个球，直接圆心到顶点 2.顶点相邻面的法线求个平均(根据三角形面积加权)\\[N_v = \\frac{\\sum_iN_i}{\\lVert \\sum_iN_i \\rVert}\\] Graphics(Real-time Rendering)Pipline application:Input vertices in 3D space Vertex Processing(Vertex Stream): Vertices positioned in screen space Trangle Processing(Triangle Stream):Trangles positioned in screen space Rasterization(Fragment Stream):Fragments(one per covered sample)一个fragment就是一个像素 Fragment Processing(Shaded Fragments):Shaded Fragments Frambuffer Operations Display:Output image(pixels) mvp变换在Vertex Processing阶段 对每个像素采样，在Rasterization阶段 判定可见性（z-buffer）在Fragment Processing阶段 如果是顶点着色，那么在Vertex Processing阶段，如果是Phong着色，在Fragment Processing阶段 Shader Programs shader程序应用于每一个顶点或像素（不用写for循环） 着色器有两种，顶点着色器和像素/片段着色器 像素着色器：算像素最后的颜色 GPUTexture Mapping 任何三维物体的表面都是二维的 UV图（纹理图），u和v的范围都在[0,1] 三角形每个顶点都对应着一个uv tiled textures（无缝衔接的纹理） " }, { "title": "PAT-Reversing Linked List & Linked List Sorting & Deduplication on a Linked List & Splitting A Linked List & Good in C", "url": "/posts/PAT-Reversing-Linked-List-&-Linked-List-Sorting-&-Deduplication-on-a-Linked-List-&-Splitting-A-Linked-List-&-Good-in-C/", "categories": "算法刷题, PAT", "tags": "链表, 模拟", "date": "2022-08-25 11:01:00 +0000", "snippet": "A1074Reversing Linked List#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;using namespace std;const int maxn = 100010;struct node{ int v, next;}L[maxn];int head, n, k;int mai...", "content": "A1074Reversing Linked List#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;using namespace std;const int maxn = 100010;struct node{ int v, next;}L[maxn];int head, n, k;int main(){ cin &gt;&gt; head &gt;&gt; n &gt;&gt; k; for (int i = 0; i &lt; n; i++) { int addr; cin &gt;&gt; addr; cin &gt;&gt; L[addr].v &gt;&gt; L[addr].next; } int tmp = head; int preLast = -1, pre, cur; while (tmp != -1) { int tmpK = 1,tmpH = tmp; while (tmpH != -1 &amp;&amp; tmpK &lt; k) { tmpH = L[tmpH].next; tmpK++; } if (tmpK &lt; k) { if(preLast != -1) L[preLast].next = tmp; break; } cur = L[tmp].next; pre = tmp; tmpK -= 1; while (tmpK--) { int next = L[cur].next; L[cur].next = pre; pre = cur; cur = next; } if (tmp == head) head = pre;//记录反转后的头节点 else L[preLast].next = pre; preLast = tmp; L[preLast].next = -1;//每次翻转完后，先设为-1，如果后面还有数据，就会更新的 tmp = cur; } while (head != -1) { if (L[head].next != -1) printf(\"%05d %d %05d\\n\", head, L[head].v, L[head].next); else printf(\"%05d %d %d\\n\", head, L[head].v, L[head].next); head = L[head].next; }}    首先，这是我写的实打实地去翻转链表，但花了很久时间去debug，最开始32分钟只拿了17/25分，后面debug了很久拿到了22分，依旧有一个点过不去，但是在牛客上可以完美通过，麻了。    其实真的去翻转还挺麻烦的，需要注意的点太多了，还不如昨天用哈希表呢，虽然慢但好歹拿满分了，本来想着今天就纯用一次静态链表试试，没想到结果竟是如此，说说这思路需要注意的点吧： 这道题需要设置很多很多变量来存地址，其中prelast就是上一次翻转完的最后一个节点，因为要和后面的一段连接上，并且else L[preLast]每次都要要初始化为-1，这样如果后面没有节点了，就正好了。 要注意变量更改的位置，不能提前更改完了，后面又要用这个变量了，这样就出错了，得先存起来。     好了，不说这个方法了，还是说说普遍的方法吧，就是要把所有有效的节点存起来，然后去翻转每一段的地址的值就行了。#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 100010;struct node{ int v, next;}L[maxn];int head, n, k;int main(){ cin &gt;&gt; head &gt;&gt; n &gt;&gt; k; for (int i = 0; i &lt; n; i++) { int addr; cin &gt;&gt; addr; cin &gt;&gt; L[addr].v &gt;&gt; L[addr].next; } int head2 = head; int list[maxn];//存地址 int sum = 0; while (head2 != -1) { list[sum++] = head2; head2 = L[head2].next; } for (int i = 0; i &lt; (sum - sum % k); i+=k) { reverse(list + i, list + i + k); } for (int i = 0; i &lt; sum - 1; i++) { printf(\"%05d %d %05d\\n\", list[i], L[list[i]].v, list[i + 1]); } printf(\"%05d %d -1\\n\", list[sum - 1], L[list[sum - 1]].v);}    这样写就很简单，很迅速，我咋就想不到呢。注意的点是：在翻转的时候，应该小于(sum - sum % k)而不是(n - n % k)，因为里面可能有无效的数据，我一开始写的n竟然还有24分，怪。A1052Linked List Sorting#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 100010;struct node{ int v, next;}L[maxn];bool comp(int a, int b){ return L[a].v &lt; L[b].v;}int list[maxn];int main(){ int head, n; cin &gt;&gt; n &gt;&gt; head; for (int i = 0; i &lt; n; i++) { int addr; cin &gt;&gt; addr; cin &gt;&gt; L[addr].v &gt;&gt; L[addr].next; } int sum = 0; while (head != -1) { list[sum++] = head; head = L[head].next; } if (sum == 0) { printf(\"0 -1\"); return 0; } sort(list, list + sum, comp); printf(\"%d %05d\\n\", sum, list[0]); for (int i = 0; i &lt; sum - 1; i++) { printf(\"%05d %d %05d\\n\", list[i], L[list[i]].v, list[i + 1]); } printf(\"%05d %d -1\\n\", list[sum - 1], L[list[sum - 1]].v);}    13分钟拿下24/25分，多亏了前面那道题的经验。那么这最后一份怎么回事呢，我猜是sum=0的时候，但我就打印了0，所以还是过不去，去牛客看了眼，得打印0 -1，才对，麻了。A1097 Deduplication on a Linked List#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;unordered_map&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 100010;struct node{ int v, next;}L[maxn];vector&lt;int&gt; List,List2;unordered_map&lt;int, int&gt; map;int main(){ int head, n; cin &gt;&gt; head &gt;&gt; n; for (int i = 0; i &lt; n; i++) { int addr; cin &gt;&gt; addr; cin &gt;&gt; L[addr].v &gt;&gt; L[addr].next; } while (head != -1) { if (map.count(abs(L[head].v))) { List2.emplace_back(head); } else { map[abs(L[head].v)]++; List.emplace_back(head); } head = L[head].next; } for (int i = 0; i &lt; List.size(); i++) { if(i != List.size() - 1) printf(\"%05d %d %05d\\n\", List[i], L[List[i]].v, List[i + 1]); else printf(\"%05d %d -1\\n\", List[i], L[List[i]].v); } for (int i = 0; i &lt; List2.size(); i++) { if(i != List2.size() - 1) printf(\"%05d %d %05d\\n\", List2[i], L[List2[i]].v, List2[i + 1]); else printf(\"%05d %d -1\\n\", List2[i], L[List2[i]].v); }}    15分钟23/25分，19分钟拿满，中间有个段错误，这是因为我之前在打印的时候，会单独把表的最后一个打印，直接用了List.back()，但这个List有可能是空的，自然就会触发段错误。A1133 Splitting A Linked List#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;unordered_map&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 100010;struct node{ int v, next;}L[maxn];vector&lt;int&gt; list1, list2, list3;int main(){ int head, n, k; cin &gt;&gt; head &gt;&gt; n &gt;&gt; k; for (int i = 0; i &lt; n; i++) { int addr; cin &gt;&gt; addr; cin &gt;&gt; L[addr].v &gt;&gt; L[addr].next; } while (head != -1) { if (L[head].v &lt; 0) { list1.emplace_back(head); } else if (L[head].v &lt;= k) { list2.emplace_back(head); } else { list3.emplace_back(head); } head = L[head].next; } for (int i = 0; i &lt; list2.size(); i++) { list1.emplace_back(list2[i]); } for (int i = 0; i &lt; list3.size(); i++) { list1.emplace_back(list3[i]); } for (int i = 0; i &lt; list1.size(); i++) { if (i != list1.size() - 1) printf(\"%05d %d %05d\\n\", list1[i], L[list1[i]], list1[i + 1]); else printf(\"%05d %d -1\\n\", list1[i], L[list1[i]]); }}    8分17秒拿下，pat的链表题属于是套路题了，记得换行，遍历链表的时候记得更新指针为next，不然会内存超限。A1164 Good in C#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;using namespace std;vector&lt;vector&lt;string&gt;&gt; letter(26, vector&lt;string&gt;(7));int main(){ for (int i = 0; i &lt; 26; i++) { for (int j = 0; j &lt; 7; j++) { cin &gt;&gt; letter[i][j]; } } getchar(); string s; getline(cin, s); //while (!s.empty() &amp;&amp; !isupper(s[0])) s.erase(s.begin()); vector&lt;char&gt; word; for (int i = 0; i &lt; s.size(); i++) { if(isupper(s[i]) &amp;&amp; i == s.size() - 1) word.emplace_back(s[i]); if ((!isupper(s[i]) || i == s.size() - 1) &amp;&amp; !word.empty()) { while (i &lt; s.size()-1 &amp;&amp; !isupper(s[i+1])) { i++; } for (int j = 0; j &lt; 7; j++) { for (int k = 0; k &lt; word.size(); k++) { cout &lt;&lt; letter[word[k] - 'A'][j]; if (k != word.size() - 1) cout &lt;&lt; ' '; } cout &lt;&lt; endl; } if (i &lt; s.size() - 1) cout &lt;&lt; endl; word.clear(); } else { word.emplace_back(s[i]); } }}    这个题这段代码，18/20分，测试点1有段错误，我看了好久，终于发现哪里数组越界了。就是cout &lt;&lt; letter[word[k] - 'A'][j];这里，我的这个if ((!isupper(s[i]) || i == s.size() - 1) &amp;&amp; !word.empty())条件其实并不准确，如果word是空而且不是大写字幕的话，那么就会到else那里，就把非大写字母插到word里了，那么之后自然会段错误。#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;using namespace std;vector&lt;vector&lt;string&gt;&gt; letter(26, vector&lt;string&gt;(7));int main(){ for (int i = 0; i &lt; 26; i++) { for (int j = 0; j &lt; 7; j++) { cin &gt;&gt; letter[i][j]; } } getchar(); string s; getline(cin, s); while (!s.empty() &amp;&amp; !isupper(s[0])) s.erase(s.begin()); vector&lt;char&gt; word; for (int i = 0; i &lt; s.size(); i++) { if(isupper(s[i]) &amp;&amp; i == s.size() - 1) word.emplace_back(s[i]); if(isupper(s[i]) &amp;&amp; i != s.size() - 1)word.emplace_back(s[i]); else { while (i &lt; s.size()-1 &amp;&amp; !isupper(s[i+1])) { i++; } for (int j = 0; j &lt; 7; j++) { for (int k = 0; k &lt; word.size(); k++) { cout &lt;&lt; letter[word[k] - 'A'][j]; if (k != word.size() - 1) cout &lt;&lt; ' '; } cout &lt;&lt; endl; } if (i &lt; s.size() - 1) cout &lt;&lt; endl; word.clear(); } }}    这个是满分的答案，需要注意两点： 第一就是给的句子有可能最开始并不是大写字母，所以要提前删除（不删的话就后面改判） 第二就是句子的结尾不一定就是非大写字母，有可能最后一位就是大写字母，这个时候，就要把它打印出来 " }, { "title": "PAT-Cartesian Tree & Summit & Block Reversing", "url": "/posts/PAT-Cartesian-Tree-&-Summit-&-Block-Reversing/", "categories": "算法刷题, PAT", "tags": "堆, 模拟, 链表", "date": "2022-08-24 10:46:00 +0000", "snippet": "A1167 Cartesian Tree#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;vector&lt;int&gt; inOrder(40);int n;const int inf = 2147483647;st...", "content": "A1167 Cartesian Tree#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;vector&lt;int&gt; inOrder(40);int n;const int inf = 2147483647;struct node{\tint v;\tnode* left, * right;\tnode(int _v) :v(_v), left(nullptr), right(nullptr) {}};node* build(int l, int r){\tif (l &gt; r) return nullptr;\tint min = inf;\tint index;\tfor (int i = l; i &lt;= r; i++)\t{\t\tif (inOrder[i] &lt; min)\t\t{\t\t\tmin = inOrder[i];\t\t\tindex = i;\t\t}\t}\tnode* n = new node(min);\tn-&gt;left = build(l, index - 1);\tn-&gt;right = build(index + 1, r);\treturn n;}int main(){\tcin &gt;&gt; n;\tfor (int i = 0; i &lt; n; i++)\t{\t\tcin &gt;&gt; inOrder[i];\t}\tnode* root;\troot = build(0, n - 1);\tvector&lt;int&gt; level;\tqueue&lt;node*&gt; q;\tq.push(root);\twhile (!q.empty())\t{\t\tnode* top = q.front();\t\tq.pop();\t\tlevel.emplace_back(top-&gt;v);\t\tif (top-&gt;left) q.push(top-&gt;left);\t\tif (top-&gt;right) q.push(top-&gt;right);\t}\tfor (int i = 0; i &lt; level.size(); i++)\t{\t\tif (i != 0)cout &lt;&lt; ' ';\t\tcout &lt;&lt; level[i];\t}}    堆+数的构造，利用中序遍历和堆的性质建树，中序遍历中，最小的是根。用时20分36秒，まだまだ。A1166Summit#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;cstdio&gt;using namespace std;const int maxn = 210;bool direct[maxn][maxn] = { false };int n, m, k;bool come[maxn];int main(){\tcin &gt;&gt; n &gt;&gt; m;\tfor (int i = 0; i &lt; m; i++)\t{\t\tint a, b;\t\tcin &gt;&gt; a&gt;&gt;b;\t\tdirect[a][b] = direct[b][a] = true;\t}\tcin &gt;&gt; k;\tfor (int i = 1; i &lt;= k; i++)\t{\t\tfill(come + 1, come + n + 1, false);\t\tint l;\t\tcin &gt;&gt; l;\t\tvector&lt;int&gt; summit(l);\t\tfor (int j = 0; j &lt; l; j++)\t\t{\t\t\tcin &gt;&gt; summit[j];\t\t\tcome[summit[j]] = true;\t\t}\t\tbool flag = false;\t\tfor (int j = 0; j &lt; l - 1; j++)\t\t{\t\t\tfor (int p = j + 1; p &lt; l; p++)\t\t\t{\t\t\t\tif (direct[summit[j]][summit[p]] == false)\t\t\t\t{\t\t\t\t\tflag = true;\t\t\t\t\tprintf(\"Area %d needs help.\\n\", i);\t\t\t\t\tbreak;\t\t\t\t}\t\t\t}\t\t\tif (flag) break;\t\t}\t\tif (flag) continue;\t\t\t\tbool flag2 = false;\t\tfor (int j = 1; j &lt;= n; j++)\t\t{\t\t\tflag = true;\t\t\tif (come[j] == false &amp;&amp; direct[j][summit[0]] == true)//首先这个人没来还是第一个人的朋友，再判断是不是其他人的朋友\t\t\t{\t\t\t\tfor (int p = 1; p &lt; l; p++)\t\t\t\t{\t\t\t\t\tif (direct[j][summit[p]] == false)\t\t\t\t\t{\t\t\t\t\t\tflag = false;//这个人不符合标准，接着找\t\t\t\t\t\tbreak;\t\t\t\t\t}\t\t\t\t}\t\t\t\tif (flag)\t\t\t\t{\t\t\t\t\tflag2 = true;\t\t\t\t\tprintf(\"Area %d may invite more people, such as %d.\\n\", i, j);\t\t\t\t\tbreak;\t\t\t\t}\t\t\t}\t\t}\t\tif (flag2 == false)\t\t{\t\t\tprintf(\"Area %d is OK.\\n\", i);\t\t}\t\t\t}}    53分钟，拿下21/25分，速度有点忒慢了，主要是debug了半天，思路其实就是使用邻接表暴力判断，因为数据量不是很大，就200，所以再暴力也不会超时，需要注意的有以下几点： 如果一个人是暂定成员中的朋友，而且没来，那么这个人不一定就需要邀请过来，还得判断他是不是其他成员的朋友，所以开始我想用每个人的朋友数量来直接判断是不是OK，这样是不对的 有两个flag值（其实是三个，重复利用了第一个），其中在后面判断是否需要再邀请人的时候，每次大for循环都要重置flag为true，不然的话，测试点1会过不去，因为假如第一个人不符合被邀请条件，设置flag为false，那么就算后面有个人符合条件，这时候没有再设置flag为true的话，后面就打印不了了，所以每次大循环都要重置flag A1165 Block Reversing#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;unordered_map&gt;#include&lt;cstdio&gt;using namespace std;const int maxn = 100010;vector&lt;int&gt; linkList;vector&lt;int&gt; reverseLinkList;unordered_map&lt;int, int&gt; address2v;unordered_map&lt;int, int&gt; v2next;unordered_map&lt;int, int&gt; v2address;int head,n, k;void dfs(int i){\tif (i + k &gt;= linkList.size())\t{\t\tfor (int j = i; j &lt; linkList.size(); j++)\t\t{\t\t\treverseLinkList.emplace_back(linkList[j]);\t\t}\t\tv2next[reverseLinkList.back()] = -1;\t\treturn;\t}\tdfs(i + k);\tv2next[reverseLinkList.back()] = v2address[linkList[i]];\tfor (int j = i; j &lt; i + k; j++)\t{\t\treverseLinkList.emplace_back(linkList[j]);\t}\tv2next[reverseLinkList.back()] = -1;}int main(){\tcin &gt;&gt; head &gt;&gt; n &gt;&gt; k;\tfor (int i = 0; i &lt; n; i++)\t{\t\tint addr, v, next;\t\tcin &gt;&gt; addr &gt;&gt; v &gt;&gt; next;\t\taddress2v[addr] = v;\t\tv2next[v] = next;\t\tv2address[v] = addr;\t}\tint tmp = head;\twhile (tmp != -1)\t{\t\tlinkList.emplace_back(address2v[tmp]);\t\ttmp = v2next[address2v[tmp]];\t}\tdfs(0);\tfor (int i = 0; i &lt; reverseLinkList.size(); i++)\t{\t\tif (i != reverseLinkList.size() - 1)\t\t{\t\t\tprintf(\"%05d %d %05d\\n\", v2address[reverseLinkList[i]], reverseLinkList[i], v2next[reverseLinkList[i]]);\t\t}\t\telse printf(\"%05d %d %d\\n\", v2address[reverseLinkList[i]], reverseLinkList[i], v2next[reverseLinkList[i]]);\t}}    1小时1分钟拿下，还是太慢了，这样下去根本做不完题目的，哎。疯狂造哈希表，思路是这样的：用dfs把原序列k个一组翻转，并利用多个哈希表的映射修改next值，代码量不多，思考的地方还挺多。麻了，估计就我搁这dfs，我看别人都是直接链表翻转，麻了。" }, { "title": "PAT-最长矩形序列 & Find More Coins", "url": "/posts/PAT-%E6%9C%80%E9%95%BF%E7%9F%A9%E5%BD%A2%E5%BA%8F%E5%88%97-&-Find-More-Coins/", "categories": "算法刷题, PAT", "tags": "动态规划", "date": "2022-08-23 10:46:00 +0000", "snippet": "最长矩形序列#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cmath&gt;using namespace std;const int maxn = 110;vector&lt;int&gt; dp(maxn, 0);//第i个矩形作为最小矩形时，能嵌套的最大矩形序列个数vector&lt;vector&lt;int&gt...", "content": "最长矩形序列#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cmath&gt;using namespace std;const int maxn = 110;vector&lt;int&gt; dp(maxn, 0);//第i个矩形作为最小矩形时，能嵌套的最大矩形序列个数vector&lt;vector&lt;int&gt;&gt; neighbor(maxn);int a[maxn];int b[maxn];int n;int DP(int i){ if (dp[i] != 0) return dp[i]; dp[i] = 1; for (int n : neighbor[i]) { dp[i] = max(dp[i], 1 + DP(n)); } return dp[i];}int main(){ cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; a[i] &gt;&gt; b[i]; } for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { if (j != i ) { if ((a[i] &lt; a[j] &amp;&amp; b[i] &lt; b[j]) || (a[i] &lt; b[j] &amp;&amp; b[i] &lt; a[j])) { neighbor[i].emplace_back(j); } } } } int maxL = 0; for (int i = 0; i &lt; n; i++) { maxL = max(maxL, DP(i)); } cout &lt;&lt; maxL;}    和昨天写的关键路径动态规划的思路一样，就是判断邻接关系不一样。A1068 Find More Coins#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 10010;const int maxm = 110;int w[maxn];int n, m;vector&lt;vector&lt;int&gt;&gt; dp(maxn, vector&lt;int&gt;(maxm, 0));vector&lt;vector&lt;int&gt;&gt; choice(maxn, vector&lt;int&gt;(maxm, 0));//dp[i][v] 金额容量为v时，使用前i个硬币支付的最大金额vector&lt;int&gt; coin;void dfs(int i, int j){ if (i &lt;= 0 || j &lt;= 0) return; if (choice[i][j] == 1) { coin.emplace_back(w[i]); dfs(i - 1, j - w[i]); } else { dfs(i - 1, j); }}bool comp(int a, int b){ return a &gt; b;}int main(){ cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; w[i]; } sort(w + 1, w + n + 1, comp); for (int i = 1; i &lt;= n; i++) { for (int j = w[i]; j &lt;= m; j++) { if (dp[i - 1][j] &gt; dp[i - 1][j - w[i]] + w[i]) { dp[i][j] = dp[i - 1][j]; choice[i][j] = 0; } else { dp[i][j] = dp[i - 1][j - w[i]] + w[i]; choice[i][j] = 1; } } } if (dp[n][m] != m) cout &lt;&lt; \"No Solution\"; else { dfs(n, m); for (int i = 0; i &lt; coin.size(); i++) { if (i != 0)cout &lt;&lt; ' '; cout &lt;&lt; coin[i]; } }}    动态规划，其实就是01背包问题，但是，这个问题的质量和价值的数组是一致的，开始没看出来，所以也就没想出来。注意，要选小的，那么就从大到小排序，并且在价值相等时，选择当前的硬币，这样就会尽可能地往后选，自然就选了面额小的硬币，很巧妙。" }, { "title": "PAT-Favorite Color Stripe & Longest Symmetric String & 有向无环图的最长路 & 有向无环图固定终点的最长路", "url": "/posts/PAT-Favorite-Color-Stripe-&-Longest-Symmetric-String-&-%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE%E7%9A%84%E6%9C%80%E9%95%BF%E8%B7%AF-&-%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE%E5%9B%BA%E5%AE%9A%E7%BB%88%E7%82%B9%E7%9A%84%E6%9C%80%E9%95%BF%E8%B7%AF/", "categories": "算法刷题, PAT", "tags": "动态规划, 关键路径", "date": "2022-08-22 09:58:00 +0000", "snippet": "A1045 Favorite Color Stripe#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;//动规五部曲//1.确认dp数组以及下标的含义//以数组A[i]结尾的子序列，其最大长度为dp[i]//2.确定递推公式：如果i在序列中： dp[i] = max(1, dp[j] + 1) (j = 1....", "content": "A1045 Favorite Color Stripe#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;//动规五部曲//1.确认dp数组以及下标的含义//以数组A[i]结尾的子序列，其最大长度为dp[i]//2.确定递推公式：如果i在序列中： dp[i] = max(1, dp[j] + 1) (j = 1... i-1 &amp;&amp; color[i] &gt;= color[j])// 如果i不在序列中dp[i] = 0//3.dp数组初始化，初始化第一个即可//4.遍历顺序：从前往后//5.举例 （pat样例）//dp数组：1 2 2 3 4 5 6 3 4 5 6 7 int n, m, l;const int maxm = 210;const int maxl = 10010;vector&lt;int&gt; color(maxm, -1);//color映射成值vector&lt;int&gt; preColor(maxl, -1);//存储序列的colorvector&lt;int&gt; dp(maxl, 1);int main(){ cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; i++) { int c; cin &gt;&gt; c; color[c] = i; } cin &gt;&gt; l; //3.初始化dp数组//已经全初始化为1了 //4.遍历 int maxL = 1; for (int i = 0; i &lt; l; i++) { cin &gt;&gt; preColor[i]; for (int j = 0; j &lt; i; j++) { if (color[preColor[j]] != -1 &amp;&amp; color[preColor[i]] &gt;= color[preColor[j]]) { dp[i] = max(dp[i], dp[j] + 1); } } maxL = max(maxL, dp[i]); } cout &lt;&lt; maxL;}    这道题目就是按最长不下降子序列的方法解，有一处很怪，开始拿了27/30分，去牛客查样例，发现在牛客可以通过，又去网上搜，发现如果只有一个颜色，且这个颜色不在喜欢的里面，最长也要算1，不能算0，麻了。注意： 开始出现了段错误，发现是储存序列L的数组开小了，应该是maxl不是maxm    找到我之前出错的地方了，其实上面这个全初始化为1是不对的，只是恰好能过pat的样例，我之前写的最长不下降子序列是这样的：#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;//动规五部曲//1.确认dp数组以及下标的含义//以数组A[i]结尾的子序列，其最大长度为dp[i]//2.确定递推公式：如果i在序列中： dp[i] = max(1, dp[j] + 1) (j = 1... i-1 &amp;&amp; color[i] &gt;= color[j])// 如果i不在序列中dp[i] = 0//3.dp数组初始化，初始化第一个即可//4.遍历顺序：从前往后//5.举例 （pat样例）//dp数组：1 2 2 3 4 5 6 3 4 5 6 7 int n, m, l;const int maxm = 210;const int maxl = 10010;vector&lt;int&gt; color(maxm, -1);//color映射成值vector&lt;int&gt; preColor(maxl, -1);//存储序列的colorint dp[maxl];int main(){ cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; i++) { int c; cin &gt;&gt; c; color[c] = i; } cin &gt;&gt; l; //3.初始化dp数组 int dp0; cin &gt;&gt; dp0; dp[0] = color[dp0] == -1 ? 0 : 1; preColor[0] = dp0; //4.遍历 int maxL = dp[0]; for (int i = 1; i &lt; l; i++) { cin &gt;&gt; preColor[i]; if (color[preColor[i]] == -1) { dp[i] = 0; } else { dp[i] = 1; for (int j = 0; j &lt; i; j++) { if (color[preColor[j]] != -1 &amp;&amp; color[preColor[i]] &gt;= color[preColor[j]]) { dp[i] = max(dp[i], dp[j] + 1); } } maxL = max(maxL, dp[i]); } } cout &lt;&lt; maxL;}    在这里，初始化为0是对的，只是我maxL应该初始化为dp[0]，因为dp[0]有可能是1，如果序列长度也是1的话，答案应该是1，但因为我是从1开始遍历，序列长度也是1的话，就不会更新maxL了，自然测试点2就没通过。#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;//动规五部曲//1.确认dp数组以及下标的含义//dp[i][j]表示第一个序列的前i位和第二个序列的前j位，最长子序列的长度//2.确定递推公式：确定dp[i][j]时，A[i] != B[j] dp[i][j] = max(dp[i-1][j], dp[i][j-1])// A[i] == B[j] : dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + 1 或者dp[i][j] = dp[i - 1][j - 1] + 1//3.dp数组初始化，初始化i=0和j=0的所有情况为0//4.遍历顺序：从前往后//5.举例 （pat样例）//dp数组： 1 2 3 4 5 6 7 8 9 10 11 12// 1 1 2 2 2 2 2 2 2 2 2 2 2 // 2 1 2 2 2 2 2 2 3 3 3 3 3 // 3 1 2 2 3 3 3 3 3 4 5 5 5// 4 1 2 2 3 4 5 5 5 5 5 6 6// 5 1 2 2 3 4 5 6 6 6 6 6 7const int maxm = 210;const int maxl = 10010;int dp[maxm][maxl];int favoColor[maxm];int colorSequence[maxl];int n, m, l;int main(){ cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; i++) { cin &gt;&gt; favoColor[i]; } cin &gt;&gt; l; for (int i = 1; i &lt;= l; i++) { cin &gt;&gt; colorSequence[i]; } //初始化dp数组 for (int i = 0; i &lt; maxm; i++) { dp[i][0] = 0; } for (int i = 0; i &lt; maxl; i++) { dp[0][i] = 0; } //遍历顺序：从前往后 for (int i = 1; i &lt;= m; i++) { for (int j = 1; j &lt;= l; j++) { if (favoColor[i] != colorSequence[j]) { dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); } else { dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + 1; //dp[i][j] = dp[i - 1][j - 1] + 1; } } } cout &lt;&lt; dp[m][l];}    这是最长公共子序列的方法，这个方法比上一个稍微难一点，涉及到dp二维数组了，但有一点很奇怪，这个dp数组全初始化为0了，但上一个方法必须全初始化为1，按理来讲结果是有区别的，当序列中没有喜欢的颜色时，上一个输出为1，这一个输出为0，但两个方法都能通过pat的测试点，很怪……我知道为啥了……写到这的时候想到了，为啥就写上面了，不在这写了。A1040 Longest Symmetric String#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;using namespace std;//动规五部曲//1.确认dp数组以及下标的含义//dp[i][j]表示i、j之间的字符串是否为回文//2.确认递推方程//if s[i] = s[j] dp[i][j] = dp[i+1][j-1]//else dp[i][j] = 0//3.dp数组初始化//初始化所有长度为1和2的子串//4.遍历顺序//按子串长度遍历//5.举例 ABAC//dp数组： 0 1 2 3// i 0 1 0 1 0// 1 1 0 0// 2 1 0// 3 1//const int maxs = 1010;int dp[maxs][maxs];int main(){ string s; getline(cin, s); int maxL = 1; //3.数组初始化 for (int i = 0; i &lt; s.size(); i++) { dp[i][i] = 1; if (i != s.size() - 1) { dp[i][i + 1] = s[i] == s[i + 1] ? 1 : 0; if (dp[i][i + 1] == 1) maxL = 2; } } if (s.size() &lt;= 2) { cout &lt;&lt; maxL; return 0; } //4.遍历 for (int l = 3; l &lt;= s.size(); l++) { for (int i = 0; i &lt;= s.size() - l; i++) { if (s[i] == s[i + l - 1]) { dp[i][i + l - 1] = dp[i + 1][i + l - 2]; if (dp[i][i + l - 1] == 1) maxL = l; } else dp[i][i + l - 1] = 0; } } cout &lt;&lt; maxL;}    最长回文子串，这道题的难点在于遍历的时候，是以子串长度为一个迭代来遍历的，不然会出现动规时，某个dp值的子问题还没有算。有向无环图的最长路#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;using namespace std;struct edge{ int v, w; edge(int _v, int _w) : v(_v), w(_w) {}};const int maxn = 110;vector&lt;vector&lt;edge&gt;&gt; neighbor(maxn);int n, m;vector&lt;int&gt; dp(maxn, 0);int DP(int i){ if (dp[i] &gt; 0) return dp[i]; for (edge e : neighbor[i]) { dp[i] = max(dp[i], DP(e.v) + e.w); } return dp[i];}int main(){ cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; i++) { int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; neighbor[u].emplace_back(v, w); } int maxL = 0; for (int i = 0; i &lt; n; i++) { if (DP(i) &gt; maxL) { maxL = DP(i); } } cout &lt;&lt; maxL;}    DAG（有向无环图）最长路的动态规划解法，比之前那个方法简洁多了。有向无环图的最长路的最优方案#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;set&gt;#include&lt;algorithm&gt;using namespace std;struct edge{ int v, w; edge(int _v, int _w) : v(_v), w(_w) {}};const int maxn = 110;vector&lt;vector&lt;edge&gt;&gt; neighbor(maxn);vector&lt;int&gt;choice(maxn, -1);int n, m;vector&lt;int&gt; dp(maxn, 0);vector&lt;int&gt; path;int DP(int i){ if (dp[i] &gt; 0) return dp[i]; for (edge e : neighbor[i]) { int tmp = max(dp[i], DP(e.v) + e.w); if (tmp &gt; dp[i]) { dp[i] = tmp; choice[i] = e.v; } } return dp[i];}bool comp(edge e1, edge e2){ return e1.v &lt; e2.v;}void dfs(int i){ if (choice[i] == -1)//走到尽头 { for (int i = 0; i &lt; path.size(); i++) { if (i != 0)cout &lt;&lt; \"-&gt;\"; cout &lt;&lt; path[i]; } cout &lt;&lt; endl; return; } path.emplace_back(choice[i]); dfs(choice[i]); path.pop_back();}int main(){ cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; i++) { int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; neighbor[u].emplace_back(v, w); } for (int i = 0; i &lt; n; i++) { if (neighbor[i].size() != 0) { sort(neighbor[i].begin(), neighbor[i].end(), comp); } } int maxL = 0; for (int i = 0; i &lt; n; i++) { if (DP(i) &gt; maxL) { maxL = DP(i); } } for (int i = 0; i &lt; n; i++) { if (dp[i] == maxL) { path.emplace_back(i); dfs(i); path.pop_back(); } }}    这里只用打印字典序最小的那个，所以对每个节点的邻接表排了下序，其实用邻接矩阵的话可以规避排序。注意： 如果是按字典序打印所有路径的话，使用set来存每个节点后继节点的集合比较方便，同时注意，如果在递归过程中发现了更大的值，要先clear这个set再insert，不然会打印出非最长路径。有向无环图固定终点的最长路#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;set&gt;#include&lt;algorithm&gt;using namespace std;struct edge{ int v, w; edge(int _v, int _w) : v(_v), w(_w) {}};const int inf = 0xfffffff;const int maxn = 110;vector&lt;vector&lt;edge&gt;&gt; neighbor(maxn);int n, m, target;vector&lt;int&gt; dp(maxn, -inf);bool vis[maxn] = { false };int DP(int i){ if (vis[i]) return dp[i]; vis[i] = true; for (edge e : neighbor[i]) { dp[i] = max(dp[i], DP(e.v) + e.w); } return dp[i];}int main(){ cin &gt;&gt; n &gt;&gt; m &gt;&gt; target; for (int i = 0; i &lt; m; i++) { int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; neighbor[u].emplace_back(edge(v, w)); } dp[target] = 0; int maxL = -inf; for (int i = 0; i &lt; n; i++) { if (DP(i) &gt; maxL) maxL = DP(i); } cout &lt;&lt; maxL;}    注意初始化数组变了，其他没变。" }, { "title": "晴问-关键路径长度 & 关键活动 & 关键路径", "url": "/posts/%E6%99%B4%E9%97%AE-%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A6-&-%E5%85%B3%E9%94%AE%E6%B4%BB%E5%8A%A8-&-%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/", "categories": "算法刷题", "tags": "关键路径", "date": "2022-08-21 14:30:00 +0000", "snippet": "关键路径长度#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;queue&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int maxn = 110;struct node{ i...", "content": "关键路径长度#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;queue&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int maxn = 110;struct node{ int v, w; node(int _v, int _w) : v(_v), w(_w) {}};int n, m;vector&lt;vector&lt;node&gt;&gt; neighbor(maxn);vector&lt;int&gt; inDegree(maxn, 0);int ve[maxn];int vl[maxn];stack&lt;int&gt; reverseTopo;int criticalLen = 0;bool TopoLogicalSort(){ memset(ve, 0, sizeof(ve)); queue&lt;int&gt; q; for (int i = 0; i &lt; n; i++) { if (inDegree[i] == 0) { q.push(i); reverseTopo.push(i); } } while (!q.empty()) { int u = q.front(); q.pop(); for (node n : neighbor[u]) { int v = n.v, w = n.w; //更新入度，判断是否进队 inDegree[v]--; if (inDegree[v] == 0) { q.push(v); reverseTopo.push(v); } //更新最早开始时间 数组 if (ve[u] + w &gt; ve[v]) { ve[v] = ve[u] + w; } } } if (reverseTopo.size() == n) return true; else return false;}int CriticalPath(){ int maxW = 0; for (int i = 0; i &lt; n; i++) { if (ve[i] &gt; maxW) maxW = ve[i]; } return maxW; /* fill(vl, vl + n, maxW); while (!reverseTopo.empty()) { int u = reverseTopo.top(); reverseTopo.pop(); for (node n : neighbor[u]) { int v = n.v, w = n.w; if (vl[v] - w &lt; vl[u]) { vl[u] = vl[v] - w; } } } //计算每个关键路径的权值，不一定是关键路径（一条）的长度，可能有分支 for (int u = 0; u &lt; n; u++) { for (node n : neighbor[u]) { int v = n.v, w = n.w; int e = ve[u], l = vl[v] - w; if (e == l) { criticalLen += w; } } } */}int main(){ cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; i++) { int v1, v2, w; cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w; inDegree[v2]++; neighbor[v1].emplace_back(node(v2, w)); } if (TopoLogicalSort()) cout &lt;&lt; \"Yes\" &lt;&lt; endl&lt;&lt; CriticalPath(); else { cout &lt;&lt; \"No\"; return 0; }}    起初我是把vl数组也算出来了，但实际上没必要，反而会出错。因为算vl数组去判断每条边的e与v是否相等，是用来判断这个边是否为关键路径的一条边，但题目问的是关键路径长度，也就是说，是一条路径的最大长度，直接返回汇点或者说是最后一个节点的ve即可。关键活动#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 110;struct node{ int v, w; node(int _v, int _w) : v(_v), w(_w) {}};struct criticalEdge{ int u, v, w; criticalEdge(int _u, int _v, int _w) :u(_u), v(_v), w(_w) {}};int n, m;vector&lt;vector&lt;node&gt;&gt; neighbor(maxn);vector&lt;criticalEdge&gt; path;vector&lt;int&gt; inDegree(maxn, 0);int ve[maxn];int vl[maxn];stack&lt;int&gt; reverseTopo;int criticalLen = 0;bool TopoLogicalSort(){ memset(ve, 0, sizeof(ve)); queue&lt;int&gt; q; for (int i = 0; i &lt; n; i++) { if (inDegree[i] == 0) { q.push(i); reverseTopo.push(i); } } while (!q.empty()) { int u = q.front(); q.pop(); for (node n : neighbor[u]) { int v = n.v, w = n.w; //更新入度，判断是否进队 inDegree[v]--; if (inDegree[v] == 0) { q.push(v); reverseTopo.push(v); } //更新最早开始时间 数组 if (ve[u] + w &gt; ve[v]) { ve[v] = ve[u] + w; } } } if (reverseTopo.size() == n) return true; else return false;}void CriticalPath(){ int maxW = 0; for (int i = 0; i &lt; n; i++) { if (ve[i] &gt; maxW) maxW = ve[i]; } fill(vl, vl + n, maxW); while (!reverseTopo.empty()) { int u = reverseTopo.top(); reverseTopo.pop(); for (node n : neighbor[u]) { int v = n.v, w = n.w; if (vl[v] - w &lt; vl[u]) { vl[u] = vl[v] - w; } } } //计算每个关键路径的权值，不一定是关键路径（一条）的长度，可能有分支 for (int u = 0; u &lt; n; u++) { for (node n : neighbor[u]) { int v = n.v, w = n.w; int e = ve[u], l = vl[v] - w; if (e == l) { path.emplace_back(criticalEdge(u,v,w)); } } }}bool comp(criticalEdge&amp; e1 , criticalEdge&amp; e2){ if (e1.u != e2.u) return e1.u &lt; e2.u; else return e1.v &lt; e2.v;}int main(){ cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; i++) { int v1, v2, w; cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w; inDegree[v2]++; neighbor[v1].emplace_back(node(v2, w)); } if (TopoLogicalSort()) { CriticalPath(); cout &lt;&lt; \"Yes\" &lt;&lt; endl; sort(path.begin(), path.end(), comp); for (criticalEdge e: path) { cout &lt;&lt; e.u &lt;&lt; ' ' &lt;&lt; e.v &lt;&lt; endl; } } else { cout &lt;&lt; \"No\"; }}    其实跟上面的代码差不多，就是这个存路径，其实不一定非得开个结构体，pair也是可以的，那么为什么我开了一个结构体呢，因为一开始我还以为要输出边权。需要注意的就是关键路径函数要在拓扑排序函数执行后再运行。关键路径#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#include&lt;set&gt;using namespace std;const int maxn = 110;struct node{ int v, w; node(int _v, int _w) : v(_v), w(_w) {}};int n, m;vector&lt;vector&lt;node&gt;&gt; neighbor(maxn);vector&lt;set&lt;int&gt;&gt; criticalNeighbor(maxn);vector&lt;int&gt; inDegree(maxn, 0), inDegreeOrigin(maxn, 0);int ve[maxn];int vl[maxn];stack&lt;int&gt; reverseTopo;int criticalLen = 0;bool TopoLogicalSort(){ memset(ve, 0, sizeof(ve)); queue&lt;int&gt; q; for (int i = 0; i &lt; n; i++) { if (inDegree[i] == 0) { q.push(i); reverseTopo.push(i); } } while (!q.empty()) { int u = q.front(); q.pop(); for (node n : neighbor[u]) { int v = n.v, w = n.w; //更新入度，判断是否进队 inDegree[v]--; if (inDegree[v] == 0) { q.push(v); reverseTopo.push(v); } //更新最早开始时间 数组 if (ve[u] + w &gt; ve[v]) { ve[v] = ve[u] + w; } } } if (reverseTopo.size() == n) return true; else return false;}void CriticalPath(){ int maxW = 0; for (int i = 0; i &lt; n; i++) { if (ve[i] &gt; maxW) maxW = ve[i]; } fill(vl, vl + n, maxW); while (!reverseTopo.empty()) { int u = reverseTopo.top(); reverseTopo.pop(); for (node n : neighbor[u]) { int v = n.v, w = n.w; if (vl[v] - w &lt; vl[u]) { vl[u] = vl[v] - w; } } } //计算每个关键路径的权值，不一定是关键路径（一条）的长度，可能有分支 for (int u = 0; u &lt; n; u++) { for (node n : neighbor[u]) { int v = n.v, w = n.w; int e = ve[u], l = vl[v] - w; if (e == l) { criticalNeighbor[u].insert(v); } } }}vector&lt;int&gt; path;void dfs(int u){ if (criticalNeighbor[u].size() == 0) { for (int i = 0; i &lt; path.size(); i++) { if (i != 0) cout &lt;&lt; \"-&gt;\"; cout &lt;&lt; path[i]; } cout &lt;&lt; endl; } for (int v : criticalNeighbor[u]) { path.emplace_back(v); dfs(v); path.pop_back(); }}int main(){ cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; i++) { int v1, v2, w; cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w; inDegree[v2]++; inDegreeOrigin[v2]++; neighbor[v1].emplace_back(node(v2, w)); } if (TopoLogicalSort()) { CriticalPath(); cout &lt;&lt; \"Yes\" &lt;&lt; endl; for (int i = 0; i &lt; n; i++) { if (inDegreeOrigin[i] == 0) { path.emplace_back(i); dfs(i); path.pop_back(); } } } else { cout &lt;&lt; \"No\"; }}    经典使用vector数组和dfs来存储每一条路。" }, { "title": "PAT-Hashing & Consecutive Factors & Come on! Let's C & A Delayed Palindrome", "url": "/posts/PAT-Hashing-&-Consecutive-Factors-&-Come-on!-Let's-C-&-A-Delayed-Palindrome/", "categories": "算法刷题, PAT", "tags": "数学, 素数, 因式分解, 大整数加法", "date": "2022-08-20 09:09:00 +0000", "snippet": "A1078 Hashing#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;unordered_map&gt;using namespace std;const int maxn = 100000;bool primeTable[maxn] ...", "content": "A1078 Hashing#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;unordered_map&gt;using namespace std;const int maxn = 100000;bool primeTable[maxn] = {false};vector&lt;int&gt; prime;int m, n;void Find(){ for (int i = 2; i &lt; maxn; i++) { if (primeTable[i] == false) { prime.emplace_back(i); for (int j = i * 2; j &lt; maxn; j += i) { primeTable[j] = true; } } }}bool isPrime(int n){ if (n &lt;= 1) return false; int sqr = (int)sqrt(1.0 * n); for (int i = 2; i &lt;= sqr; i++) { if (n % i == 0) return false; } return true;}int main(){ Find(); cin &gt;&gt; m &gt;&gt; n; int t; if (isPrime(m)) t = m; else { for (int i = 0; i &lt; prime.size(); i++) { if (prime[i] &gt;= m) { t = prime[i]; break; } } } unordered_map&lt;int, int&gt; map; for (int i = 0; i &lt; n; i++) { int num; cin &gt;&gt; num; if (i != 0)cout &lt;&lt; ' '; if (map.count(num % t)) { //二次方探查法 bool flag = false; for (int j = 1; j &lt; t; j++) { int pos = (num + j * j) % t; if (!map.count(pos)) { map[pos]++; cout &lt;&lt; pos; flag = true; break; } } if (flag == false) cout &lt;&lt; '-'; } else { cout &lt;&lt; num % t; map[num % t]++; } }}    题目中Quadratic probing (with positive increments only) is used to solve the collisions. 这句话没看懂，是二次方探查法（只考虑正向探查）。12分钟20分（满分25），也还凑合，加上二次方探查法就满分了，pat真的带善人。注意： isPrime函数中一定要记得特判，如果n小于等于1，那就返回false，不然1会判断为合数A1096 Consecutive Factors#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;unordered_map&gt;using namespace std;typedef long long LL;LL n;bool isPrime(LL num){ if (num &lt;= 1) return false; LL sqr = (LL)sqrt(1.0 * num); for (LL i = 2; i &lt;= sqr; i++) { if (num % i == 0) return false; } return true;}int main(){ cin &gt;&gt; n; if (isPrime(n)) { cout &lt;&lt; 1 &lt;&lt; endl &lt;&lt; n; return 0; } LL sqr = (LL)sqrt(1.0 * n); LL ansIndex, ansLen = 0; for (LL i = 2; i &lt;= sqr; i++) { LL j = i, tmp = i; while (n % tmp == 0) { j++; tmp *= j; } if (j - i &gt; ansLen) { ansLen = j - i; ansIndex = i; } } cout &lt;&lt; ansLen &lt;&lt; endl; for (int i = 0; i &lt; ansLen; i++) { if (i != 0) cout &lt;&lt; '*'; cout &lt;&lt; ansIndex; ansIndex++; }}    这道题我陷入了一个误区，由于之前做过一道分解质因数，因为给的数肯定时会被分解完的，所以就可以记录每一个质因数，但这道题并不是分解质因数，而是连续的因数，我此时就在想，这样的话分解的情况有很多，并不能把数分解完了再去序列里去查，不是质因数，这怎么分解，十分复杂。这就是我陷入的误区。实际上并不需要把一个数的所有因子分解出来，只需要查哪一段连续的序列乘积正好可以被原数整除即可，这样就方便多了。当然需要特判那些质数。A1116 Come on! Let’s C#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;unordered_map&gt;using namespace std;const int maxn = 20000;vector&lt;bool&gt; p(maxn, false);unordered_map&lt;string, string&gt; map;unordered_map&lt;string, int&gt; check;unordered_map&lt;int, int&gt; prime;int n, q;void Era(){\tfor (int i = 2; i &lt; maxn; i++)\t{\t\tif (p[i] == false)\t\t{\t\t\tprime[i]++;\t\t\tfor (int j = i * 2; j &lt; maxn; j += i)\t\t\t{\t\t\t\tp[j] = true;\t\t\t}\t\t}\t}}int main(){\tEra();\tcin &gt;&gt; n;\tfor (int i = 1; i &lt;= n; i++)\t{\t\tstring id;\t\tcin &gt;&gt; id;\t\tif (i == 1)\t\t{\t\t\tmap[id] = \"Mystery Award\";\t\t}\t\telse if (prime.count(i))\t\t{\t\t\tmap[id] = \"Minion\";\t\t}\t\telse\t\t{\t\t\tmap[id] = \"Chocolate\";\t\t}\t}\tcin &gt;&gt; q;\tfor (int i = 0; i &lt; q; i++)\t{\t\tstring id;\t\tcin &gt;&gt; id;\t\tif (!map.count(id))\t\t{\t\t\tcout &lt;&lt; id &lt;&lt; \": Are you kidding?\" &lt;&lt; endl;\t\t\tcontinue;\t\t}\t\tif (check.count(id))\t\t{\t\t\tcout &lt;&lt; id &lt;&lt; \": Checked\" &lt;&lt; endl;\t\t}\t\telse\t\t{\t\t\tcheck[id]++;\t\t\tcout &lt;&lt; id &lt;&lt; \": \" &lt;&lt; map[id] &lt;&lt; endl;\t\t}\t}}    素数判定+哈希表。注意如果询问的id不存在的情况。16分钟拿下。A1136 A Delayed Palindrome#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int maxn = 1010;struct bign{\tint d[maxn];\tint len;\tbign()\t{\t\tmemset(d, 0, sizeof(d));\t\tlen = 0;\t}};void exchange(bign&amp; a, string&amp; b){\ta.len = b.size();\tfor (int i = 0; i &lt; a.len; i++)\t{\t\ta.d[i] = b[b.size() - 1 - i] - '0';\t}}bign ReverseAdd(bign&amp; bn){\tint len = bn.len;\tbign bn2;\tbn2.len = len;\tfor (int i = 0; i &lt; len; i++)\t{\t\tbn2.d[i] = bn.d[len - 1 - i];\t}\tbign bn3;\tbn3.len = len;\tint carray = 0;\tfor (int i = 0; i &lt; len; i++)\t{\t\tint cur = bn.d[i] + bn2.d[i] + carray;\t\tcarray = cur / 10;\t\tcur %= 10;\t\tbn3.d[i] = cur;\t}\tif (carray &gt; 0)\t{\t\tbn3.d[len] = carray;\t\tbn3.len++;\t}\tfor (int i = len - 1; i &gt;= 0; i--)\t{\t\tcout &lt;&lt; bn.d[i];\t}\tcout &lt;&lt; \" + \";\tfor (int i = len - 1; i &gt;= 0; i--)\t{\t\tcout &lt;&lt; bn2.d[i];\t}\tcout &lt;&lt; \" = \";\tfor (int i = bn3.len - 1; i &gt;= 0; i--)\t{\t\tcout &lt;&lt; bn3.d[i];\t}\tcout &lt;&lt; endl;\treturn bn3;}bool isPalin(bign&amp; bn){\tfor (int i = 0; i &lt; bn.len / 2; i++)\t{\t\tif (bn.d[i] != bn.d[bn.len - 1 - i]) return false;\t}\treturn true;}int main(){\tstring num;\tcin &gt;&gt; num;\tbign bn;\texchange(bn, num);\tif (isPalin(bn))\t{\t\tfor (int j = bn.len - 1; j &gt;= 0; j--)\t\t{\t\t\tcout &lt;&lt; bn.d[j];\t\t}\t\tcout &lt;&lt; \" is a palindromic number.\";\t\treturn 0;\t}\tfor (int i = 0; i &lt; 10; i++)\t{\t\tbn = ReverseAdd(bn);\t\tif (isPalin(bn))\t\t{\t\t\tfor (int j = bn.len - 1; j &gt;= 0; j--)\t\t\t{\t\t\t\tcout &lt;&lt; bn.d[j];\t\t\t}\t\t\tcout &lt;&lt; \" is a palindromic number.\";\t\t\treturn 0;\t\t}\t}\tcout &lt;&lt; \"Not found in 10 iterations.\";}    31分50秒拿下，说实话有点慢了，需要注意的点： 要先判断给的数是不是回文数，是的话就不用反转相加了，不然就只能拿14分 注意开辟数组的大小，不能是1000，否则最后一个测试点过不去，我估计是最高位进1了，到了1001位。 " }, { "title": "PAT-Rational Arithmetic & Prime Factors", "url": "/posts/PAT-Rational-Arithmetic-&-Prime-Factors/", "categories": "算法刷题, PAT", "tags": "数学, 最大公因数, 最小公倍数, 素数, 因式分解", "date": "2022-08-19 14:05:00 +0000", "snippet": "A1088 Rational Arithmetic#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;string&gt;using namespace std;typedef long long LL;vector&lt;LL&gt; numerator(2);vector&lt;L...", "content": "A1088 Rational Arithmetic#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;string&gt;using namespace std;typedef long long LL;vector&lt;LL&gt; numerator(2);vector&lt;LL&gt; denominator(2);LL gcd(LL a, LL b){ if (a &lt; 0) a *= -1; if (b &lt; 0) b *= -1; if (b == 0) return a; else return gcd(b, a % b);}LL lcm(LL a, LL b){ if (a &lt; 0) a *= -1; if (b &lt; 0) b *= -1; return a * (b / gcd(a, b));}LL ansNu, ansDe, a;string sAns;void Plus(){ a = 0; ansDe = lcm(denominator[0], denominator[1]); ansNu = numerator[0] * (ansDe / denominator[0]) + numerator[1] * (ansDe / denominator[1]); LL gc = gcd(ansNu, ansDe); ansNu /= gc; ansDe /= gc; a = ansNu / ansDe;}void Minus(){ ansDe = lcm(denominator[0], denominator[1]); ansNu = numerator[0] * (ansDe / denominator[0]) - numerator[1] * (ansDe / denominator[1]); LL gc = gcd(ansNu, ansDe); ansNu /= gc; ansDe /= gc; a = ansNu / ansDe;}void Multi(){ ansDe = denominator[0] * denominator[1]; ansNu = numerator[0] * numerator[1]; LL gc = gcd(ansNu, ansDe); ansNu /= gc; ansDe /= gc; a = ansNu / ansDe;}void Divide(){ if (numerator[1] == 0) { sAns = \"Inf\"; return; } ansDe = denominator[0] * numerator[1]; ansNu = numerator[0] * denominator[1]; if (ansDe &lt; 0) { ansDe *= -1; ansNu *= -1; } LL gc = gcd(ansNu, ansDe); ansNu /= gc; ansDe /= gc; a = ansNu / ansDe;}void Format(){ if (sAns == \"Inf\") return; if (ansNu % ansDe == 0) sAns = to_string(a);//整数 else if (abs(ansNu) &lt; ansDe)//真分数 { sAns = to_string(ansNu) + \"/\" + to_string(ansDe); } else//假分数 { sAns = to_string(a) + \" \" + to_string(abs(ansNu) % ansDe) + \"/\" + to_string(ansDe); } if (a &lt; 0 || ansNu &lt; 0) { sAns = \"(\" + sAns + \")\"; }}int main(){ scanf(\"%lld/%lld %lld/%lld\", &amp;numerator[0], &amp;denominator[0], &amp;numerator[1], &amp;denominator[1]); //格式化左式 string s[2]; for (int i = 0; i &lt; 2; i++) { if (numerator[i] % denominator[i] == 0)//整数 { s[i] = to_string(numerator[i] / denominator[i]); } else if(abs(numerator[i]) &lt; denominator[i])//真分数 { LL gc = gcd(numerator[i], denominator[i]); numerator[i] /= gc; denominator[i] /= gc; s[i] = to_string(numerator[i]) + \"/\" + to_string(denominator[i]); } else //假分数 { LL gc = gcd(numerator[i], denominator[i]); numerator[i] /= gc; denominator[i] /= gc; s[i] = to_string(numerator[i] / denominator[i]) + \" \" + to_string(abs(numerator[i]) % denominator[i]) + \"/\" + to_string(denominator[i]); } if (numerator[i] &lt; 0)//负数 { s[i] = \"(\" + s[i] + \")\"; } } Plus(); Format(); cout &lt;&lt; s[0] &lt;&lt; \" + \" &lt;&lt; s[1] &lt;&lt; \" = \" &lt;&lt; sAns &lt;&lt; endl; Minus(); Format(); cout &lt;&lt; s[0] &lt;&lt; \" - \" &lt;&lt; s[1] &lt;&lt; \" = \" &lt;&lt; sAns &lt;&lt; endl; Multi(); Format(); cout &lt;&lt; s[0] &lt;&lt; \" * \" &lt;&lt; s[1] &lt;&lt; \" = \" &lt;&lt; sAns &lt;&lt; endl; Divide(); Format(); cout &lt;&lt; s[0] &lt;&lt; \" / \" &lt;&lt; s[1] &lt;&lt; \" = \" &lt;&lt; sAns &lt;&lt; endl;}    这道题写的蛮久的，开始只拿了17min，去查了测试点2才重新拿到满分，注意的点： 一开始有个浮点错误，那是因为忘了特判除数为0输出Inf了 起初调试时，发现除法不对劲，分母出现了负数，加个判断即可 最后是测试点2答案错误，去牛客测试了下（会给错误样例是什么），发现是在等式左侧的不仅整数要化简，能约分的也要约分 算最大公约数和最小公倍数时，要注意参数都应该是正的 A1059 Prime Factors#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;unordered_map&gt;using namespace std;typedef long long LL;const LL maxn = 10010;vector&lt;LL&gt; primeFactors;unordered_map&lt;LL, int&gt; map;int N;bool isPrime(LL n){ //LL sqr = sqrt(1.0 * n); for (LL i = 2; i * i&lt;= n; i++) { if (n % i == 0) return false; } return true;}void Find(){ //LL sqr = sqrt(1.0 * N); for (LL i = 2; i * i &lt; N; i++) { if (N % i == 0 &amp;&amp; isPrime(i)) { primeFactors.emplace_back(i); map[i]++; } }}int main(){ cin &gt;&gt; N; LL ansN = N; Find(); if (primeFactors.size() == 0) { cout &lt;&lt; ansN &lt;&lt; '=' &lt;&lt; ansN; return 0; } for (int i = 0; i &lt; primeFactors.size(); i++) { N /= primeFactors[i]; } int j = 0; while (N != 1) { while (N % primeFactors[j] == 0) { map[primeFactors[j]]++; N /= primeFactors[j]; } j++; } cout &lt;&lt; ansN &lt;&lt; '='; for (int i = 0; i &lt; primeFactors.size(); i++) { if (i == 0) { cout &lt;&lt; primeFactors[i]; } else { cout &lt;&lt; '*' &lt;&lt; primeFactors[i]; } if (map[primeFactors[i]] &gt; 1) { cout &lt;&lt; '^' &lt;&lt; map[primeFactors[i]]; } } return 0;}    32分钟拿到21分（满分25），一个答案错误，一个段错误，搜了下，其实就一个问题，如果输入的数本身就没有质因数，那么就输出等于自己就行了，在pat这里可以拿满分，但在牛客那里还有几个浮点错误，其实就是我设置的find，是小于sqrt（N）了，如果小于N的话能找到，但会超时，也就是说我这个方法并不好。#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;unordered_map&gt;using namespace std;typedef long long LL;const LL maxn = 12000000;vector&lt;LL&gt; prime;vector&lt;LL&gt; factors;bool p[maxn] = { false };LL n;void Era()//使用欧拉筛法算出素数表{ for (LL i = 2; i &lt; maxn; i++) { if (p[i] == false) { prime.emplace_back(i); for (int j = i * 2; j &lt; maxn; j += i) { p[j] = true; } } }}int main(){ Era(); cin &gt;&gt; n; unordered_map&lt;LL, int&gt; map; for (LL p : prime) { if (n % p == 0) { map[p]++; factors.emplace_back(p); } } if (map.empty()) { cout &lt;&lt; n &lt;&lt; '=' &lt;&lt; n; return 0; } LL ansN = n; for (LL f : factors) { n /= f; } int j = 0; while (n != 1) { while (n % factors[j] == 0) { n /= factors[j]; map[factors[j]]++; } j++; } cout &lt;&lt; ansN &lt;&lt; '='; for (int i = 0; i &lt; factors.size(); i++) { if (i == 0) { cout &lt;&lt; factors[i]; } else { cout &lt;&lt; '*' &lt;&lt; factors[i]; } if (map[factors[i]] &gt; 1) { cout &lt;&lt; '^' &lt;&lt; map[factors[i]]; } } return 0;}    使用欧拉筛法，先算出素数表，然后再算，就可以用过牛客的所有样例了，牛客是真狠，最大到一千多万了，得设置maxn为很大很大，不用欧拉筛法估计还得超时，pat数据没那么过分。 注意，如果要使用vector的emplace_back函数，那就不要初始化空间，不然无效（但不报错，也不中断，怪怪的）" }, { "title": "PAT-Sum of Number Segments & Counting Ones & Rational Sum & Scanf()输入格式表", "url": "/posts/PAT-Sum-of-Number-Segments-&-Counting-Ones-&-Rational-Sum-&-Scanf()%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F%E8%A1%A8/", "categories": "算法刷题, PAT", "tags": "数学, 最大公因数， 最小公倍数", "date": "2022-08-18 09:40:00 +0000", "snippet": "A1104 Sum of Number Segments#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;using namespace std;const int maxn = 100010;vector&lt;long double&gt; num(maxn);vector&lt;long double...", "content": "A1104 Sum of Number Segments#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;using namespace std;const int maxn = 100010;vector&lt;long double&gt; num(maxn);vector&lt;long double&gt; dfsSum(maxn);int n;long double sum = 0.0;long double dfs(int i){ if (i &gt;= n) return 0; dfsSum[i] = (n - i) * num[i] + dfs(i + 1); return dfsSum[i];}int main(){ scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; i++) { //cin &gt;&gt; num[i]; scanf(\"%Lf\", &amp;num[i]); } dfs(0); for (int i = 0; i &lt; n; i++) { sum += dfsSum[i]; } printf(\"%.2Lf\", sum);}    这道题有点小坑，我是当dfs做了，但网上很多都是按找规律做的（其实一开始我也想找规律，但刚列了两组数据就懒得列了，就去写dfs了），一开始就纯暴力，后面两个测试点超时，后来我发现又很多重复计算，于是就打表，虽然没有超时了，但测试点2过不去，于是开始查，发现是double的精度问题，改成long double就行了。 scanf和printf读取打印long double类型，要写成%Lf，不然读不了也打不出，或者干脆用cin、cout（一开始超时，我就换了，但问题不在这里）A1049 Counting Ones#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;using namespace std;int numOne(int num){ int cnt = 0; while (num != 0) { if (num % 10 == 1) { cnt++; } num /= 10; } return cnt;}int n;int main(){ int sum = 0; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) { sum += numOne(i); } cout &lt;&lt; sum;}    直接暴力从1开始判断，这样能拿22分（满分30），其实也可以了，一共写了12分钟（其实有点长了，因为一开始还是花了点时间思考怎么才能不超时）#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;using namespace std;int main(){ int now, left, right, sum = 0; int a = 1; int n; cin &gt;&gt; n; while (n / a != 0) { left = n / (a * 10); right = n % a; now = (n / a) % 10; if (now == 0) sum += left * a; else if (now == 1)sum += left * a + right + 1; else sum += (left + 1) * a; a *= 10; } cout &lt;&lt; sum;}    通过计算每一位是1的情况个数，可以通过全部样例，思路来自于算法笔记，真考到这种题目，就是可能得思考一会。A1081 Rational Sum#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;using namespace std;const int maxn = 110;vector&lt;long long&gt; numerator(maxn);vector&lt;long long&gt; denominator(maxn);long long gcd(long long a, long long b){ if (b == 0)return a; else return gcd(b, a % b);}long long lcm(long long a, long long b){ return a * b / gcd(a, b);}void Plus(long long a, long long b){ long long de = lcm(abs(denominator[a]), abs(denominator[b])); long long nu = numerator[a] * (de / denominator[a]) + numerator[b] * (de / denominator[b]); long long g = gcd(de, abs(nu)); numerator[b] = nu / g; denominator[b] = de / g;}int n;int main(){ cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) { scanf(\"%lld/%lld\", &amp;numerator[i], &amp;denominator[i]); } for (int i = 0; i &lt; n - 1; i++) { Plus(i, i + 1); } if (numerator[n - 1] % denominator[n - 1] == 0) { cout &lt;&lt; numerator[n - 1] / denominator[n - 1]; } else if (numerator[n - 1] &gt;= denominator[n - 1]) { cout &lt;&lt; numerator[n - 1] / denominator[n - 1] &lt;&lt; ' ' &lt;&lt; numerator[n - 1] - (denominator[n - 1] * (numerator[n - 1] / denominator[n - 1])) &lt;&lt; '/' &lt;&lt; denominator[n - 1]; } else { cout &lt;&lt; numerator[n - 1] &lt;&lt; '/' &lt;&lt; denominator[n - 1]; }}    写了最大公约数和最小公倍数的函数，这个记住比较好，开始有测试点过不去，把所有变量类型改为long long即可。Scanf()输入格式表 格式控制符 说明 %c 读取一个单一的字符 %hd、%d、%ld、%lld 读取一个十进制整数，并分别赋值给 short、int、long、long long 类型 %ho、%o、%lo 读取一个八进制整数（可带前缀也可不带），并分别赋值给 short、int、long 类型 %hx、%x、%lx 读取一个十六进制整数（可带前缀也可不带），并分别赋值给 short、int、long 类型 %hu、%u、%lu 读取一个无符号整数，并分别赋值给 unsigned short、unsigned int、unsigned long 类型 %f、%lf、%Lf 读取一个十进制形式的小数，并分别赋值给 float、double、long double 类型 %e、%le 读取一个指数形式的小数，并分别赋值给 float、double 类型 %g、%lg 既可以读取一个十进制形式的小数，也可以读取一个指数形式的小数，并分别赋值给 float、double 类型 %s 读取一个字符串（以空白符为结束） " }, { "title": "PAT-LCA in a Binary Tree", "url": "/posts/PAT-LCA-in-a-Binary-Tree/", "categories": "算法刷题, PAT", "tags": "LCA, dfs", "date": "2022-08-17 13:47:00 +0000", "snippet": "A1151 LCA in a Binary Tree#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;using namespace std;const int maxn = 10010;vector&lt;int&gt; in(maxn);vector&lt;int&gt; pre(maxn);struc...", "content": "A1151 LCA in a Binary Tree#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;using namespace std;const int maxn = 10010;vector&lt;int&gt; in(maxn);vector&lt;int&gt; pre(maxn);struct node{ int val; node* left = nullptr, * right = nullptr; node(int _val) : val(_val) {}}*root;int m, n;node* build( int inL, int inR, int preL, int preR){ if (inL &gt; inR || preL &gt; preR) return nullptr; node* root = new node(pre[preL]); int index; for (int i = inL; i &lt;= inR; i++) { if (in[i] == pre[preL]) { index = i; break; } } root-&gt;left = build(inL, index - 1,preL + 1, preL + index - inL); root-&gt;right = build(index + 1, inR, preL + index - inL + 1, preR); return root;}bool flag1, flag2;int LCA = -1;int search(node* root, int u, int v){ if (root == nullptr) return 0; int cnt = 0; cnt = search(root-&gt;left, u, v) + search(root-&gt;right, u, v); if (root-&gt;val == u) { flag1 = true; cnt++; } if (root-&gt;val == v) { flag2 = true; cnt++; } if (LCA == -1 &amp;&amp; cnt == 2) { LCA = root-&gt;val; } return cnt;}int main(){ //freopen(\"input.txt\", \"r\", stdin); cin &gt;&gt; m &gt;&gt; n; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; in[i]; } for (int i = 0; i &lt; n; i++) { cin &gt;&gt; pre[i]; } root = build(0, n - 1, 0, n - 1); for (int i = 0; i &lt; m; i++) { int u, v; cin &gt;&gt; u &gt;&gt; v; LCA = -1; flag1 = false, flag2 = false; search(root, u, v); if (flag1 &amp;&amp; flag2) { if (LCA == u) { printf(\"%d is an ancestor of %d.\\n\", u, v); } else if (LCA == v) { printf(\"%d is an ancestor of %d.\\n\", v, u); } else { printf(\"LCA of %d and %d is %d.\\n\", u, v, LCA); } } else if(!flag1 &amp;&amp; !flag2) { printf(\"ERROR: %d and %d are not found.\\n\", u, v); } else if (flag1) { printf(\"ERROR: %d is not found.\\n\", v); } else { printf(\"ERROR: %d is not found.\\n\", u); } }}    这道题使用了中序+前序建树，和dfs搜索最邻近祖先，先搜索，返回左子树和右子树搜索到目标的数量的和，如果是2而且LCA仍然是初始值，那么就是最邻近祖先了，因为是深度优先搜索，从底往上搜。没能一次ac竟然是因为，cin&gt;&gt;m&gt;&gt;n写成了cout&lt;&lt;m&lt;&lt;n我说怎么上来就打印了俩0啊……第一次出这毛病，可能是白天和高中同学玩累了2333。" }, { "title": "PAT-Heaps & Is It a Complete AVL Tree & Complete Binary Tree & Lowest Common Ancestor", "url": "/posts/PAT-Heaps-&-Is-It-a-Complete-AVL-Tree-&-Complete-Binary-Tree-&-Lowest-Common-Ancestor/", "categories": "算法刷题, PAT", "tags": "堆, AVL, 完全二叉树, LCA", "date": "2022-08-16 09:39:00 +0000", "snippet": "A1147 Heaps#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;using namespace std;const int maxn = 1010;int n, m;vector&lt;int&gt; tree(maxn, -1);vector&lt;int&gt; post;bool checkM...", "content": "A1147 Heaps#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;using namespace std;const int maxn = 1010;int n, m;vector&lt;int&gt; tree(maxn, -1);vector&lt;int&gt; post;bool checkMinHeap(int root){ if (root &gt; m) return true; bool flag = true; if (root * 2 &lt;= m &amp;&amp; tree[root * 2] &lt; tree[root]) { flag = false; } if (root * 2 + 1 &lt;= m &amp;&amp; tree[root * 2 + 1] &lt; tree[root]) { flag = false; } return flag &amp;&amp; checkMinHeap(root * 2) &amp;&amp; checkMinHeap(root * 2 + 1);}bool checkMaxHeap(int root){ if (root &gt; m) return true; bool flag = true; if (root * 2 &lt;= m &amp;&amp; tree[root * 2] &gt; tree[root]) { flag = false; } if (root * 2 + 1 &lt;= m &amp;&amp; tree[root * 2 + 1] &gt; tree[root]) { flag = false; } return flag &amp;&amp; checkMaxHeap(root * 2) &amp;&amp; checkMaxHeap(root * 2 + 1);}void postOrder(int root){ if (root &gt; m) return; postOrder(root * 2); postOrder(root * 2 + 1); post.emplace_back(tree[root]);}void printPost(){ for (int i = 0; i &lt; post.size(); i++) { if (i == 0) cout &lt;&lt; post[i]; else cout &lt;&lt; ' ' &lt;&lt; post[i]; } cout &lt;&lt; endl;}int main(){ //freopen(\"input.txt\", \"r\", stdin); cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) { for (int j = 1; j &lt;= m; j++) { cin &gt;&gt; tree[j]; } post.clear(); if (tree[1] - tree[2] &gt;= 0) { if (checkMaxHeap(1)) { cout &lt;&lt; \"Max Heap\" &lt;&lt; endl; } else { cout &lt;&lt; \"Not Heap\" &lt;&lt; endl; } } else { if (checkMinHeap(1)) { cout &lt;&lt; \"Min Heap\" &lt;&lt; endl; } else { cout &lt;&lt; \"Not Heap\" &lt;&lt; endl; } } postOrder(1); printPost(); }}    堆的判定，比建堆要简单，23分52秒93拿下，注意点： 用数组存堆，从1开始，这样左孩子就是root*2，右孩子就是root*2+1 中间打印出问题，是因为遍历时，把root加到数组中了，应该加tree[root] A1123 Is It a Complete AVL Tree#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;queue&gt;using namespace std;int n;vector&lt;int&gt; levelSequence;struct node{ int val; int height = 1; node* left; node* right; node(int _val) : val(_val), left(nullptr), right(nullptr) {}};int GetHeight(node*&amp; root){ if (root == nullptr) return 0; else return root-&gt;height;}void UpdateHeight(node*&amp; root){ root-&gt;height = max(GetHeight(root-&gt;left), GetHeight(root-&gt;right)) + 1;}int GetBalanceFactor(node*&amp; root){ return GetHeight(root-&gt;left) - GetHeight(root-&gt;right);}void R(node*&amp; root){ node* tmp = root -&gt;left; root-&gt;left = tmp-&gt;right; tmp-&gt;right = root; root = tmp; UpdateHeight(root-&gt;right); UpdateHeight(root);}void L(node*&amp; root){ node* tmp = root-&gt;right; root-&gt;right = tmp-&gt;left; tmp-&gt;left = root; root = tmp; UpdateHeight(root-&gt;left); UpdateHeight(root);}void Insert(node*&amp; root, int val){ if (root == nullptr) { root = new node(val); return; } if (val &lt; root-&gt;val) { Insert(root-&gt;left, val); UpdateHeight(root); if (GetBalanceFactor(root) == 2)//L { if (GetBalanceFactor(root-&gt;left) == 1)//LL { R(root); } else//LR { L(root-&gt;left); R(root); } } } else if(val &gt; root-&gt;val) { Insert(root-&gt;right, val); UpdateHeight(root); if (GetBalanceFactor(root) == -2)//R { if (GetBalanceFactor(root-&gt;right) == -1)//RR { L(root); } else//RL { R(root-&gt;right); L(root); } } }}void PrintLevel(){ for (int i = 0; i &lt; levelSequence.size(); i++) { if (i == 0)cout &lt;&lt; levelSequence[i]; else cout &lt;&lt; ' ' &lt;&lt; levelSequence[i]; } cout &lt;&lt; endl;}void LevelTravelsal(node*&amp; root){ bool isComp = true; bool flag = false; queue&lt;node*&gt; q; q.push(root); while (!q.empty()) { node* top = q.front(); q.pop(); levelSequence.emplace_back(top-&gt;val); if (top-&gt;left == nullptr) { flag = true; } else { if (flag) isComp = false; q.push(top-&gt;left); } if (top-&gt;right == nullptr) { flag = true; } else { if (flag)isComp = false; q.push(top-&gt;right); } } PrintLevel(); if (isComp) { cout &lt;&lt; \"YES\"; } else { cout &lt;&lt; \"NO\"; }}int main(){ //freopen(\"input.txt\", \"r\", stdin); cin &gt;&gt; n; node* root = nullptr; for (int i = 0; i &lt; n; i++) { int val; cin &gt;&gt; val; Insert(root, val); } LevelTravelsal(root);}    1个小时，拿到10分……这道题出现了三个问题，一个比较大的问题是不会判断完全二叉树……我一开始自己写的只能判断一些情况。 完全二叉树直接在层序遍历的时候去判断，如果在入队前，发现有了空的左孩子或者右孩子，此时就要将flag打开，如果之后再遍历到某个节点，发现它有左孩子或者右孩子时，就说明它不再是一个完全二叉树 第二个错就是，左旋的时候更新树高时，更新错了，应该是UpdateHeight(root)，我写成了UpdateHeight(root-&gt;right)，此时root-&gt;right是空的，自然也就没有height，就中断了，也就是段错误 第三个错，就是新建节点时，树高要设置为1，不然有些不平衡的情况，漏掉旋转 1110 Complete Binary Tree#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;queue&gt;using namespace std;const int maxn = 20;vector&lt;int&gt; Left(maxn,-1);vector&lt;int&gt; Right(maxn, -1);vector&lt;bool&gt; isRoot(maxn, true);int n;int main(){ //freopen(\"input.txt\", \"r\", stdin); cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) { string l, r; cin &gt;&gt; l &gt;&gt; r; if (l[0] != '-') { Left[i] = stoi(l); isRoot[stoi(l)] = false; } if (r[0] != '-') { Right[i] = stoi(r); isRoot[stoi(r)] = false; } } int root; for (int i = 0; i &lt; n; i++) { if (isRoot[i] == true) root = i; } queue&lt;int&gt; q; q.push(root); bool flag = false, isComp = true; int last; while (!q.empty()) { int top = q.front(); q.pop(); if (Left[top] == -1) { flag = true; } else { if (flag) isComp = false; q.push(Left[top]); } if (Right[top] == -1) { flag = true; } else { if (flag) isComp = false; q.push(Right[top]); } if (q.empty()) last = top; } if (isComp) { cout &lt;&lt; \"YES \" &lt;&lt; last; } else { cout &lt;&lt; \"NO \" &lt;&lt; root; }}    20分钟16分，30分钟debug+查答案拿到25分。这道题的判断完全二叉树的方法用了上一题的方法，过程中出现了答案错误和内存超限。 在读取l和r的时候，我一开始设置的数据类型是char，但n的个数最多有20个，也就是说，可能有的节点是两位数的编号，而char就只能存一位，自然就出错了。一开始我还想着用string和stoi来转换，但寻思这不纯纯浪费么，char就行了，然鹅事与愿违，忽略了这个点，麻了A1143 Lowest Common Ancestor#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;unordered_map&gt;#include&lt;cstdio&gt;using namespace std;unordered_map&lt;int, int&gt; map;const int maxn = 10010;vector&lt;int&gt; preOrder(maxn);int m, n;void FindLCA(int u, int v){ for (int i = 0; i &lt; n; i++) { if ((preOrder[i] &gt; u &amp;&amp; preOrder[i] &lt; v) || (preOrder[i] &lt; u &amp;&amp; preOrder[i] &gt; v)) { printf(\"LCA of %d and %d is %d.\\n\", u, v, preOrder[i]); return; } else if (preOrder[i] == u) { printf(\"%d is an ancestor of %d.\\n\", u, v); return; } else if (preOrder[i] == v) { printf(\"%d is an ancestor of %d.\\n\", v, u); return; } }}int main(){ cin &gt;&gt; m &gt;&gt; n; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; preOrder[i]; map[preOrder[i]]++; } for (int i = 0; i &lt; m; i++) { int x, y; cin &gt;&gt; x &gt;&gt; y; if (!map.count(x) &amp;&amp; !map.count(y)) { printf(\"ERROR: %d and %d are not found.\\n\", x, y); } else if (!map.count(x)) { printf(\"ERROR: %d is not found.\\n\", x); } else if (!map.count(y)) { printf(\"ERROR: %d is not found.\\n\", y); } else { FindLCA(x, y); } }}    这道题根本就没建树，巧妙地利用了平衡二叉树和前序遍历地性质，如果是公共祖先的话，根据avl的性质，祖先的左侧的节点值都要小于祖先右侧的节点值，所以如果有公共祖先，那么其值一定介于两个节点之间。其次，由于是前序遍历，所以祖先一定会先遍历到，所以只要遍历前序数组即可找到祖先。如果某一方是另一方的祖先，那么只要判断在前序遍历中先遇到谁，谁就是祖先，毕竟前序遍历顺序是根-&gt;左-&gt;右。" }, { "title": "PAT-Online Map & Birds in Forest", "url": "/posts/PAT-Online-Map-&-Birds-in-Forest/", "categories": "算法刷题, PAT", "tags": "Dijkstra, 并查集", "date": "2022-08-15 13:39:00 +0000", "snippet": "A1111 Online Map#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;using namespace std;struct node{ int v,len, time; node(int _v, int _len, int _time) : v(_v), len(_len), tim...", "content": "A1111 Online Map#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;using namespace std;struct node{ int v,len, time; node(int _v, int _len, int _time) : v(_v), len(_len), time(_time) {}};int n, m;const int maxv = 510;const int inf = 0xfffffff;vector&lt;vector&lt;node&gt;&gt; neighbor(maxv);int dis[maxv], preDis[maxv];int t[maxv],preT[maxv], numPath[maxv];bool vis[maxv] = {false};void DijkstraDis(int s){ fill(dis, dis + maxv, inf); fill(t, t + maxv, inf); dis[s] = 0; t[s] = 0; for (int i = 0; i &lt; n; i++) { int u = -1, min = inf; for (int j = 0;j &lt; n; j++) { if (vis[j] == false &amp;&amp; dis[j] &lt; min) { u = j; min = dis[j]; } } if (u == -1) return; vis[u] = true; for (node n : neighbor[u]) { if (vis[n.v] == false) { if (dis[u] + n.len &lt; dis[n.v]) { dis[n.v] = dis[u] + n.len; t[n.v] = t[u] + n.time; preDis[n.v] = u; } else if (dis[u] + n.len == dis[n.v] &amp;&amp; t[u] + n.time &lt; t[n.v]) { t[n.v] = t[u] + n.time; preDis[n.v] = u; } } } }}void DijkstraT(int s){ fill(t, t + maxv, inf); fill(vis, vis + maxv, false); fill(numPath, numPath + maxv, inf); numPath[s] = 0; t[s] = 0; for (int i = 0; i &lt; n; i++) { int u = -1, min = inf; for (int j = 0; j &lt; n; j++) { if (vis[j] == false &amp;&amp; t[j] &lt; min) { u = j; min = t[j]; } } if (u == -1) return; vis[u] = true; for (node n : neighbor[u]) { if (vis[n.v] == false) { if (t[u] + n.time &lt; t[n.v]) { t[n.v] = t[u] + n.time; preT[n.v] = u; numPath[n.v] = numPath[u] + 1; } else if (t[u] + n.time == t[n.v] &amp;&amp; numPath[u] + 1 &lt; numPath[n.v]) { numPath[n.v] = numPath[u] + 1; preT[n.v] = u; } } } }}bool isSame(int s, int e){ while (preDis[e] == preT[e] &amp;&amp; e != s) { e = preDis[e]; } if (e == s) return true; else return false;}void dfsDis(int start, int end){ if (end == start) { cout &lt;&lt; start; return; } dfsDis(start, preDis[end]); cout &lt;&lt; \" -&gt; \" &lt;&lt; end;}void dfsT(int start, int end){ if (end == start) { cout &lt;&lt; start; return; } dfsDis(start, preT[end]); cout &lt;&lt; \" -&gt; \" &lt;&lt; end;}void dfs(int pre[], vector&lt;int&gt;&amp; path, int start, int end){ if (end == start) { path.emplace_back(end); return; } dfs(pre, path, start, pre[end]); path.emplace_back(end);}void printPath(vector&lt;int&gt;&amp; path){ for (int i = 0; i &lt; path.size(); i++) { if (i != 0) cout &lt;&lt; \" -&gt; \"; cout &lt;&lt; path[i]; } cout &lt;&lt; endl;}int main(){ //freopen(\"input.txt\", \"r\", stdin); cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; i++) { int v1, v2, isOne, len, time; cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; isOne &gt;&gt; len &gt;&gt; time; neighbor[v1].emplace_back(node(v2, len, time)); if (isOne == 0) { neighbor[v2].emplace_back(node(v1, len, time)); } } int start, end; cin &gt;&gt; start &gt;&gt; end; DijkstraDis(start); DijkstraT(start); vector&lt;int&gt; pathD; vector&lt;int&gt; pathT; dfs(preDis, pathD, start, end); dfs(preT, pathT, start, end); /*if (isSame(start, end)) { cout &lt;&lt; \"Distance = \" &lt;&lt; dis[end] &lt;&lt; \"; Time = \" &lt;&lt; t[end] &lt;&lt; \": \"; dfsDis(start, end); cout &lt;&lt; endl; } else { cout &lt;&lt; \"Distance = \" &lt;&lt; dis[end] &lt;&lt; \": \"; dfsDis(start, end); cout &lt;&lt; endl; cout &lt;&lt; \"Time = \" &lt;&lt; t[end] &lt;&lt; \": \"; dfsT(start, end); cout &lt;&lt; endl; }*/ if (pathD == pathT) { cout &lt;&lt; \"Distance = \" &lt;&lt; dis[end] &lt;&lt; \"; Time = \" &lt;&lt; t[end] &lt;&lt; \": \"; printPath(pathD); } else { cout &lt;&lt; \"Distance = \" &lt;&lt; dis[end] &lt;&lt; \": \"; printPath(pathD); cout &lt;&lt; \"Time = \" &lt;&lt; t[end] &lt;&lt; \": \"; printPath(pathT); }}    我自己写的初版代码，测试点2和4过不去，只有20分，花了一小时写的，真考到这种题，估计也不继续找bug了，20就20吧。我去网上搜了好久，找到一个跟我思路几乎一模一样，只有一点不一样，我直接dfs打印结果，他是先dfs把结果存到数组，再打印结果，然后我改成这样，测试点2和4就过了……很无语，那说明我那个直接打印结果写的有问题，但我已经检查烂了，也检查不出来啥问题，哎，看不到样例就是这样的，极度痛苦，而且牛客上只有69道题，这道题根本就没有，所以也没发去牛客看样例了。总之，做了1h，找了1h的bug，最后其实也没找到bug，算是积累了个经验，凡是需要打印路径啥的，一定，千万要先存到数组里，再打印，这样好确保万无一失地拿到分数。接下来说说注意的点吧： 目前先不写注释了，节省时间来刷题 注意在遍历邻接表时，加一个判断，如果没访问过也就是visited数组为false再去判断，不加也行，加上无非是节省一点点时间 使用freopen来节省复制粘贴样例的时间，提交时注释掉即可 注意遇到重复性代码时，谨慎复制粘贴，很容易出现某个变量忘记改的问题     麻了！ 就在我码完上面这些字后，找到问题了！！！就在代码里（我就不改了），我想着把我自己写的直接dfs打印给注释掉吧，然后发给发小看看我这俩小时的痛苦代码，结果注释时，忘记注释dfsT这个函数了，紧接着出现了红色波浪线 ，我一看，好家伙，原来是在dfsT的函数里，用了dfsDis的函数来递归（源代码还在上面，我没改，可以看下，笑死了），就这还能过仨样例，太神奇了。A1118 Birds in Forest#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;set&gt;using namespace std;const int maxn = 10010;vector&lt;int&gt; parent(maxn), Rank(maxn);int n;set&lt;int&gt; birds, isRoot;void Init(){ for (int i = 0; i &lt;maxn; i++) { parent[i] = i; } fill(Rank.begin(), Rank.begin() + maxn, 0);}int Find(int b){ int a = b; while (b != parent[b]) { b = parent[b]; } while (a != parent[a]) { int z = a; a = parent[a]; parent[z] = b; } return b;}void Union(int a, int b){ a = Find(a); b = Find(b); if (a == b) return; if (Rank[a] &gt; Rank[b]) { parent[b] = a; } else if (Rank[b] &gt; Rank[a]) { parent[a] = b; } else { parent[b] = a; Rank[a]++; }}int main(){ //freopen(\"input.txt\", \"r\", stdin); cin &gt;&gt; n; Init(); for (int i = 0; i &lt; n; i++) { int k, b0; cin &gt;&gt; k &gt;&gt; b0; birds.insert(b0); for (int j = 1; j &lt; k; j++) { int bj; cin &gt;&gt; bj; Union(b0, bj); birds.insert(bj); } } for (int b : birds) { isRoot.insert(Find(b)); } cout &lt;&lt; isRoot.size() &lt;&lt; ' ' &lt;&lt; birds.size() &lt;&lt; endl; int q; cin &gt;&gt; q; while (q--) { int b1, b2; cin &gt;&gt; b1 &gt;&gt; b2; if (Find(b1) == Find(b2)) { cout &lt;&lt; \"Yes\" &lt;&lt; endl; } else { cout &lt;&lt; \"No\" &lt;&lt; endl; } }}    简单的并查集，35分钟拿下，其实25分钟就足够了，中间发生了两次段错误。第一次是因为在读取b0之前就插入set里了，此时b0是个负数，就引发了中断；第二次是因为题目最大数量是1万个，我初始化就给了1千个，少了个0，就出现了段错误。其实还有一处小错误，虽然不会影响答案，就是路径压缩时，没压好，应该是parent[z]=b，写成了parent[a]=b，不过不会影响答案，只是会导致第一个值没有压缩路径。还有一处可以优化的，在Union时，如果两个节点的根节点一样，直接返回就行了，不用再进行下去了。" }, { "title": "PAT-All Roads Lead to Rome & Topological Order & Family Property", "url": "/posts/PAT-All-Roads-Lead-to-Rome-&-Topological-Order-&-Family-Property/", "categories": "算法刷题, PAT", "tags": "Dijkstra, 拓扑排序, 并查集", "date": "2022-08-14 14:46:00 +0000", "snippet": "A1087 All Roads Lead to Rome#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;unordered_map&gt;using namespace std;//邻接表中需要存的数据：struct node{ int v, cost;//城市编号（map存...", "content": "A1087 All Roads Lead to Rome#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;unordered_map&gt;using namespace std;//邻接表中需要存的数据：struct node{ int v, cost;//城市编号（map存）、到这个地的花费(其实也就是路径长度) node(int _v, int _cost) : v(_v), cost(_cost) {}};const int maxn = 210;//最大城市数量const int inf = 0xfffffff;bool isVisited[maxn] = { false };//访问数组vector&lt;vector&lt;int&gt;&gt; pre(maxn);//记录前缀节点vector&lt;vector&lt;node&gt;&gt; neighbor(maxn);//存邻接表int cost[maxn];//存到每个城市的最少花费int happiness[maxn];//存每个城市的幸福指数int n, k;//城市数目、路数unordered_map&lt;string, int&gt; map;//名字到编号的映射0~n-1unordered_map&lt;int, string&gt; map2name;//标号到名字的映射void Dijkstra(int s){ //初始化数据 fill(cost, cost + n, inf);//费用初始化为极大值 cost[s] = 0;//出发点的费用初始化为0 //遍历n个城市（求到每个城市的最低消费） for (int i = 0; i &lt; n; i++) { int u = -1, min = inf; //在没有访问过的节点中，选取cost最低的 for (int j = 0; j &lt; n; j++) { if (isVisited[j] == false &amp;&amp; cost[j] &lt; min) { min = cost[j]; u = j; } } if (u == -1) return;//说明不连通，或者已经遍历完了 isVisited[u] = true; //遍历u的邻居，看是否要更新值 for (node nd : neighbor[u]) { //u作为中介节点到nd.v节点的花费小于之前存储的最小花费 if (cost[u] + nd.cost &lt; cost[nd.v]) { cost[nd.v] = cost[u] + nd.cost;//更新花费 //更新前缀节点 pre[nd.v].clear(); pre[nd.v].emplace_back(u); } else if (cost[u] + nd.cost == cost[nd.v])//如果出现了相同的花费 { pre[nd.v].emplace_back(u); } } }}//回溯寻找目标路径int ans = 0;//路径数量int tmpHappiness;//临时存储幸福指数和int pathHappiness;//最终幸福指数和vector&lt;int&gt; path;//最终的路径vector&lt;int&gt; tmp;//临时存放路径//1.确认返回类型和参数void dfs(int rom){ //2.终止条件 if (rom == 0)//回到初始点 { ans++; //判断是否要更新为最终选择的路径 if (ans == 1)//说明这是第一条 { pathHappiness = tmpHappiness; path = tmp; } else if (ans &gt; 1)//说明最小花费的路径大于1条 { //如果总幸福指数更高 if (tmpHappiness &gt; pathHappiness) { pathHappiness = tmpHappiness;//更新指数 path.clear();//更新最终路径 path = tmp; } //如果总幸福指数一样，计算平均幸福指数并比较，如果这条路径的平均指数更高 else if (tmpHappiness == pathHappiness &amp;&amp; tmpHappiness / tmp.size() &gt; pathHappiness / path.size()) { pathHappiness = tmpHappiness;//更新指数 path.clear();//更新最终路径 path = tmp; } } return; } //遍历 for (int p : pre[rom])//遍历每一个前缀节点 { tmp.emplace_back(p);//加入临时路径 tmpHappiness += happiness[p];//增加临时幸福指数和 dfs(p); tmp.pop_back();//退出路径 tmpHappiness -= happiness[p];//减少对应的幸福指数 }}int main(){ cin &gt;&gt; n &gt;&gt; k; string start;//出发点 cin &gt;&gt; start; map[start] = 0; map2name[0] = start; happiness[0] = 0; for (int i = 1; i &lt; n; i++)//此时只有n-1个城市（start算一个了，所以要-1） { string _city; cin &gt;&gt; _city &gt;&gt; happiness[i]; map[_city] = i;//将该城市写入map，映射城市编号 map2name[i] = _city;//编号映射城市名字 } //读取路 for (int i = 0; i &lt; k; i++) { string _c1, _c2; int _cost; cin &gt;&gt; _c1 &gt;&gt; _c2 &gt;&gt; _cost; neighbor[map[_c1]].emplace_back(node(map[_c2], _cost)); neighbor[map[_c2]].emplace_back(node(map[_c1], _cost)); } //迪杰斯特拉算法 Dijkstra(map[start]); //寻找目标路径 tmpHappiness = happiness[map[\"ROM\"]];//提前加入rom的幸福指数 dfs(map[\"ROM\"]); cout &lt;&lt; ans &lt;&lt; ' ' &lt;&lt; cost[map[\"ROM\"]] &lt;&lt; ' ' &lt;&lt; pathHappiness &lt;&lt; ' ' &lt;&lt; pathHappiness / path.size() &lt;&lt; endl; for (int i = path.size() - 1; i &gt;= 0; i--) { cout &lt;&lt; map2name[path[i]] &lt;&lt; \"-&gt;\"; } cout &lt;&lt; \"ROM\";}    这题真是写了好久，使用Dijkstra+dfs，麻了，又又又debug半天，好在我发现在牛客网上，提交出现错误了会告诉样例是啥，不然又不知道要debug多久，需要注意的点： 初始化数据的时候，出发点的幸福指数默认应该是0，所以一定要初始化为0，不然一旦加了别的值，应付指数就不对了 遍历过的点，一定要记得设置isVisited数组为true 题目讲了，如果有多条最短花费路径，那就比总幸福指数，总幸福指数一样了，再比平均幸福指数，注意审题（好在这个点就只有3分，开始没拿到） 按我的方法，开始时，需要先加上Rom的幸福指数，我一开始直接加了100，但注意，rom的幸福指数可不一定是100！只是样例中的是100，还好这个不是100的测试点只有6分 在打印地名字的时候，注意是map2name[path[i]]不是map2name[i] 在算平均幸福指数时，出发点是不算数的A1146 Topological Order#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;using namespace std;int n, m, k;//点数、边数、询问数const int maxv = 1010;vector&lt;int&gt; inDegree(maxv, 0);//记录每个点的入度vector&lt;int&gt; tmp;vector&lt;vector&lt;int&gt;&gt; neighbor(maxv);//邻接表bool check(vector&lt;int&gt;&amp; order){ tmp = inDegree; for (int i = 0; i &lt; n; i++) { //如果某个节点的入度大于0 if (tmp[order[i]] &gt; 0) return false; //该节点指向的所有点入度-1 for (int v : neighbor[order[i]]) { tmp[v]--; } } return true;}int main(){ cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; i++) { int v1, v2; cin &gt;&gt; v1 &gt;&gt; v2; neighbor[v1].emplace_back(v2); inDegree[v2]++; } cin &gt;&gt; k; vector&lt;int&gt; ans;//记录不是拓扑排序的序号 vector&lt;int&gt; order(n);//记录询问的顺序 for (int i = 0; i &lt; k; i++) { for (int j = 0; j &lt; n; j++) { cin &gt;&gt; order[j]; } if (!check(order)) { ans.emplace_back(i); } } for (int i = 0; i &lt; ans.size(); i++) { if (i == 0) cout &lt;&lt; ans[i]; else cout &lt;&lt; ' ' &lt;&lt; ans[i]; }}    拓扑排序，有一处问题，就是读取数据时，读取order数组，order[j]写成order[i]了…..这种错误什么时候才能不犯啊……A1114 Family Property#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;algorithm&gt;#include&lt;set&gt;#include&lt;cstdio&gt;using namespace std;struct family{ int id, cnt;//家庭最小id，家庭人数， double avgSets, avgArea;//平均房产数量、面积 family(int _id, int _cnt, double _avgSets, double _avgArea) :id(_id), cnt(_cnt), avgSets(_avgSets), avgArea(_avgArea) {}};int n;//n行数据set&lt;int&gt; ids;//储存所有出现过的idconst int maxid = 10000;int parent[maxid], Rank[maxid], estate[maxid], area[maxid];//父节点、并查集树的高度，某个id（一行数据的代表）房产，某个id的住房面积//初始化并查集void init(){ for (int i = 0; i &lt; maxid; i++) { parent[i] = i; } fill(Rank, Rank + maxid, 0);}//查找父节点int find(int p){ int a = p; while (parent[p] != p) { p = parent[p]; } //路径压缩 while (parent[a] != a) { int z = a; a = parent[a]; parent[z] = p; } return p;}//合并两个家庭void Union(int p, int q){ if (p == -1 || q == -1) return;//不处理-1的情况 p = find(p); q = find(q); //根据rank来看谁做主树，谁高谁做主 if (Rank[p] &gt; Rank[q]) { parent[q] = p; } else if (Rank[q] &gt; Rank[p]) { parent[p] = q; } else//rank一样，p做主 { parent[q] = p; Rank[p]++; }}bool comp(family f1, family f2){ return f1.avgArea != f2.avgArea ? f1.avgArea &gt; f2.avgArea : f1.id &lt; f2.id;}int main(){ init();//初始化 cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) { int id, f, m; cin &gt;&gt; id &gt;&gt; f &gt;&gt; m; ids.insert(id); ids.insert(f); ids.insert(m); Union(id, f); Union(id, m); //小孩 int k; cin &gt;&gt; k; while (k--) { int kid; cin &gt;&gt; kid; ids.insert(kid); Union(id, kid); } cin &gt;&gt; estate[id] &gt;&gt; area[id]; } //清除ids中的-1 ids.erase(-1); //遍历每一个ids中的id，找到他们的父亲 vector&lt;int&gt; tmp[maxid]; for (int id : ids) { tmp[find(id)].emplace_back(id); } vector&lt;family&gt; fa; //把tmp数组抽象出来，形成一个家族 for (int id : ids) { if (tmp[id].empty()) continue;//说明这个id不是parent vector&lt;int&gt;&amp; members = tmp[id]; int totalEstate = 0, totalArea = 0, familyID = members[0], cnt = members.size(); for (int m : members) { if (m &lt; familyID) familyID = m; totalEstate += estate[m];//m是某一行数据的代表，并不会每个人都有房产 totalArea += area[m]; } fa.emplace_back(family(familyID, cnt, (double)totalEstate / (double)cnt, (double)totalArea / (double)cnt)); } sort(fa.begin(), fa.end(), comp); printf(\"%d\\n\", fa.size()); for (family&amp; f : fa) { printf(\"%04d %d %.3lf %.3lf\\n\", f.id, f.cnt, f.avgSets, f.avgArea); }}    这道题目是关于并查集的，有点难度，需要注意的点： 一定一定要记得init，别光写init函数了，结果再main里没调用 要搞清除id之间的关系，在储存某个id的房产时，其实就相当于存了当中某一行的房产 注意-1，-1代表没有父母，所以不能union，并且读取完数据，要从set中删除 这个解中，用了很多大数组，不要在意，能接算出答案就行了 " }, { "title": "PAT-Emergency & Gas Station", "url": "/posts/PAT-Emergency-&-Gas-Station/", "categories": "算法刷题, PAT", "tags": "Djkstra, Bellman-Ford", "date": "2022-08-13 11:51:00 +0000", "snippet": "A1003 Emergency#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;queue&gt;using namespace std;struct node{\tint v, dis;//目标节点编号，距离\tnode(int _v, int _dis) :v(_v), dis(_dis) {}};const int maxn...", "content": "A1003 Emergency#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;queue&gt;using namespace std;struct node{\tint v, dis;//目标节点编号，距离\tnode(int _v, int _dis) :v(_v), dis(_dis) {}};const int maxn = 500;const int inf = 0x3fffffff;vector&lt;vector&lt;node&gt;&gt; neighbor(maxn);//每个节点的邻接表bool isVisited[maxn] = {false};//访问数组//记录源节点到每个节点的最短距离,到达某个节点的最大队伍数量，到达某个节点的最短路径数量int dis[maxn], teamNum[maxn], pathNum[maxn];int team[maxn];//记录每个节点的队伍数量int n, m, c1, c2;//节点数、路数、c1、c2//迪杰斯特拉算法void Djkstra(){\tfill(dis, dis + n, inf);//初始化到达所有结点的最短距离为极大值\tdis[c1] = 0;//先把出发点的距离设置为0\tteamNum[c1] = team[c1];\tpathNum[c1] = 1;\t//接下来要开始遍历n次（攻占n个城市）\tfor (int i = 0; i &lt; n; i++)\t{\t\t//查未访问的节点中，dis最短的（也就是从出发点到目标点距离最短的）\t\tint u = -1, min = inf;//目标点，最短距离\t\tfor (int j = 0; j &lt; n; j++)\t\t{\t\t\tif (!isVisited[j] &amp;&amp; dis[j] &lt; min)\t\t\t{\t\t\t\tu = j;\t\t\t\tmin = dis[j];\t\t\t}\t\t}\t\t//先判断是否存在这么一个点\t\tif (u == -1) return;//说明不是连通图\t\tisVisited[u] = true;//标记该节点已访问过\t\t//开始查u的每一个邻居，更新每个邻居的dis值\t\tfor (auto n : neighbor[u])\t\t{\t\t\t//如果以u为中介节点，到达n节点，距离小于原来的dis\t\t\tif (dis[u] + n.dis &lt; dis[n.v])\t\t\t{\t\t\t\tdis[n.v] = dis[u] + n.dis;//更新该节点的dis值\t\t\t\tpathNum[n.v] = pathNum[u];//到该节点的最短路径更新为到达u的路径总数\t\t\t\tteamNum[n.v] = teamNum[u] + team[n.v];//更新救援队伍人数\t\t\t}\t\t\telse if (dis[u] + n.dis == dis[n.v])\t\t\t{\t\t\t\tpathNum[n.v] += pathNum[u];//到该节点的最短路径+到达u的路径总数\t\t\t\tif (teamNum[u] + team[n.v] &gt; teamNum[n.v])//如果走这条路，救援人员更多\t\t\t\t{\t\t\t\t\tteamNum[n.v] = teamNum[u] + team[n.v];//更新救援队伍人数\t\t\t\t}\t\t\t}\t\t}\t}}int main(){\tcin &gt;&gt; n &gt;&gt; m &gt;&gt; c1 &gt;&gt; c2;\t//储存每个节点救援队伍数量\tfor (int i = 0; i &lt; n; i++)\t{\t\tcin&gt;&gt;team[i];\t}\t//记录每条路\tfor (int i = 0; i &lt; m; i++)\t{\t\tint _c1, _c2, _dis;\t\tcin &gt;&gt; _c1 &gt;&gt; _c2 &gt;&gt; _dis;\t\tneighbor[_c1].emplace_back(node(_c2, _dis));\t\tneighbor[_c2].emplace_back(node(_c1, _dis));\t}\tDjkstra();\tcout &lt;&lt; pathNum[c2] &lt;&lt; ' ' &lt;&lt; teamNum[c2];\t}    Dijkstra算法：    虽然之前做过，但再一次做仍然没能做出来，甚至还是先看了一遍算法笔记的迪杰斯特拉算法详解，也没做出来，还是得看源码。 迪杰斯特拉算法是计算并记录出发点到每一个点的最短距离，感觉有点像贪心+动态规划 计算前，需要初始化的也就是出发点的数据 在做最短路径数量更新时，要记得更新为中介节点路径的数量，而不是归1 不能忘记将遍历过的节点设置为true #include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;set&gt;using namespace std;struct node{\tint v, dis;//目标节点编号，距离\tnode(int _v, int _dis) :v(_v), dis(_dis) {}};const int maxn = 500;const int inf = 0x3fffffff;vector&lt;vector&lt;node&gt;&gt; neighbor(maxn);//每个节点的邻接表//记录源节点到每个节点的最短距离,到达某个节点的最大队伍数量，到达某个节点的最短路径数量int dis[maxn], teamNum[maxn], pathNum[maxn];int team[maxn];//记录每个节点的队伍数量int n, m, c1, c2;//节点数、路数、c1、c2vector&lt;set&lt;int&gt;&gt;pre(maxn);//记录每个节点的前驱节点//贝尔曼福德算法void Bellman(){\tfill(dis, dis + n, inf);//初始化单源最短路径为极大值\tdis[c1] = 0;//到出发点的最短路径为0\tpathNum[c1] = 1;//初始化到出发点的路有一条\tteamNum[c1] = team[c1];//初始化到达c1时的救援队人数\t//遍历n-1次（因为一共n个节点，形成的最短路径树不会超过n层，也就是说最多n-1层\tfor (int i = 0; i &lt; n - 1; i++)\t{\t\t//每一次循环都要遍历每一条边\t\tfor (int j = 0; j &lt; n; j++)\t\t{\t\t\tfor (auto n : neighbor[j])\t\t\t{\t\t\t\t//如果经过j节点到n节点的距离小于之前记录的dis\t\t\t\tif (dis[j] + n.dis &lt; dis[n.v])\t\t\t\t{\t\t\t\t\tdis[n.v] = dis[j] + n.dis;//更新单源最短路(松弛操作)\t\t\t\t\tteamNum[n.v] = teamNum[j] + team[n.v];//更新救援队人数\t\t\t\t\tpathNum[n.v] = pathNum[j];//更新最短路条数\t\t\t\t\tpre[n.v].clear();//清空之前的前缀节点\t\t\t\t\tpre[n.v].insert(j);//加入这个中介节点\t\t\t\t}\t\t\t\telse if (dis[j] + n.dis == dis[n.v])//如果相等\t\t\t\t{\t\t\t\t\tpre[n.v].insert(j);//加入这个中介节点\t\t\t\t\tif (teamNum[j] + team[n.v] &gt; teamNum[n.v])//如果这条路上的救援队员人数更多\t\t\t\t\t{\t\t\t\t\t\tteamNum[n.v] = teamNum[j] + team[n.v];//更新救援队人数\t\t\t\t\t}\t\t\t\t\t//重新计算最短路径条数\t\t\t\t\tpathNum[n.v] = 0;\t\t\t\t\tfor (auto p : pre[n.v])\t\t\t\t\t{\t\t\t\t\t\tpathNum[n.v] += pathNum[p];\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t}\t}}int main(){\tcin &gt;&gt; n &gt;&gt; m &gt;&gt; c1 &gt;&gt; c2;\t//储存每个节点救援队伍数量\tfor (int i = 0; i &lt; n; i++)\t{\t\tcin&gt;&gt;team[i];\t}\t//记录每条路\tfor (int i = 0; i &lt; m; i++)\t{\t\tint _c1, _c2, _dis;\t\tcin &gt;&gt; _c1 &gt;&gt; _c2 &gt;&gt; _dis;\t\tneighbor[_c1].emplace_back(node(_c2, _dis));\t\tneighbor[_c2].emplace_back(node(_c1, _dis));\t}\tBellman();\tcout &lt;&lt; pathNum[c2] &lt;&lt; ' ' &lt;&lt; teamNum[c2];\t}    Bellman-Ford算法：    这个算法有点暴力，需要一直遍历，但就是因为暴力，可以解决负权的问题，需要注意的点： 忘记初始化出发点队伍人员数量了，导致计算结果有误 因为bellman算法没有访问数组（isVisited[]），所以有些中介节点是要多次遍历到的，这时候就要使用set记录前缀节点编号，而且，每当遇到相同长度的路径，都要重新根据前缀节点来计算一次路径数目，哪怕是遇到了相同的中介节点，因为又一次遍历的中介节点可能其路径数和人员数都有所变化了。 A1072 Gas Station#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;cstdio&gt;using namespace std;int n, m, k, d;//居民房数目、加油站候选地数目、路数、最大服务范围const int maxn = 1020;const int inf = 0xfffffff;struct node{\tint v, dis;//邻接表中，目标节点编号，到目标节点距离\tnode(int _v, int _dis) :v(_v), dis(_dis) {}};double minium[11];//记录加油站到最近一个居民楼的距离double average[11];//记录加油站到每个居民区的平均距离bool isVisited[maxn];vector&lt;vector&lt;node&gt;&gt; neighbor(maxn);//其中1~n为居民楼，n+1~n+m是加油站int dis[maxn];//记录某个加油站到各个居民楼的最短距离int minDis, sumDis;//记录每个加油站距离居民楼的最近距离、加油站距离所有居民楼的距离之和void Dijkstra(int s){\t//初始化数据\tfill(isVisited + 1, isVisited + n + m + 1, false);\tfill(dis + 1, dis + n + m + 1, inf);\tdis[s] = 0;\tminDis = inf;\tfor (int i = 0; i &lt; n + m; i++)//要算出到n + m个节点的距离（包括自己和其他加油站）\t{\t\tint u = -1, min = inf;\t\t//从所有节点中遍历没有访问过的，dis值最小的节点\t\tfor (int j = 1; j &lt;= n + m; j++)\t\t{\t\t\tif (isVisited[j] == false &amp;&amp; dis[j] &lt; min)\t\t\t{\t\t\t\tmin = dis[j];\t\t\t\tu = j;\t\t\t}\t\t}\t\t//判断是否有没访问的dis值最小的点\t\tif (u == -1) return;//要么遍历完了，要么不连通了\t\tisVisited[u] = true;//设置为访问过\t\t//遍历u能到的所有节点，看是否需要更新最短距离\t\tfor (node&amp; nd : neighbor[u])\t\t{\t\t\tif (dis[u] + nd.dis &lt; dis[nd.v])\t\t\t{\t\t\t\tdis[nd.v] = dis[u] + nd.dis;//更新距离\t\t\t\t//判断是否要更新最近的距离(必须是居民楼，不能是和其他加油站的距离)\t\t\t\tif (dis[nd.v] &lt; minDis &amp;&amp; nd.v &lt;= n) minDis = dis[nd.v];\t\t\t}\t\t}\t}\t//判断是否有居民楼超出服务区\tsumDis = 0;\tfor (int i = 1; i &lt;= n; i++)\t{\t\tif (dis[i] &gt; d)\t\t{\t\t\tminDis = inf;\t\t\tbreak;\t\t}\t\telse\t\t{\t\t\tsumDis += dis[i];\t\t}\t}}int main(){\tcin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; d;\tfor (int i = 0; i &lt; k; i++)\t{\t\tstring _s1, _s2;//节点编号\t\tint _p1, _p2, _d;//节点编号、两点距离\t\tcin &gt;&gt; _s1 &gt;&gt; _s2 &gt;&gt; _d;\t\t//判断是否为加油站，其中1~n为居民楼，n+1~n+m是加油站\t\tif (_s1[0] == 'G')\t\t{\t\t\t_p1 = n + stoi(_s1.substr(1));\t\t}\t\telse _p1 = stoi(_s1);\t\tif (_s2[0] == 'G')\t\t{\t\t\t_p2 = n + stoi(_s2.substr(1));\t\t}\t\telse _p2 = stoi(_s2);\t\tneighbor[_p1].emplace_back(node(_p2, _d));\t\tneighbor[_p2].emplace_back(node(_p1, _d));\t}\t//遍历每一个加油站\tvector&lt;int&gt; minD(11);//储存每一个加油站距离居民楼的最近距离\tvector&lt;int&gt; sumD(11);//储存每一个加油站到各个居民楼的距离之和\tfor (int i = 1; i &lt;= m; i++)\t{\t\tDijkstra(n + i);\t\tif (minDis == inf)//说明不在服务区\t\t{\t\t\tminD[i] = -1;\t\t}\t\telse\t\t{\t\t\tminD[i] = minDis;\t\t\tsumD[i] = sumDis;\t\t}\t}\t//比较并打印结果\tint maxDis = -1;//用来记录当中最大的最短距离\tint sum = 0;//记录对应的sum\tint station = -1;//记录要建在哪个站\tfor (int i = 1; i &lt;= m; i++)\t{\t\tif (minD[i] &gt; maxDis)\t\t{\t\t\tmaxDis = minD[i];//更新maxDis\t\t\tsum = sumD[i];\t\t\tstation = i;\t\t}\t\telse if (minD[i] == maxDis &amp;&amp; sumD[i] &lt; sum)\t\t{\t\t\tmaxDis = minD[i];//更新maxDis\t\t\tsum = sumD[i];\t\t\tstation = i;\t\t}\t}\tif (station == -1) printf(\"No Solution\");\telse printf(\"G%d\\n%.1lf %.1lf\", station, (double)minD[station], (double)sumD[station] / (double)n);}    这道题是迪杰斯特拉算法，debug了好久…… 要注意，虽然加油站可以不建，但可以当隐形节点去经过 跑的时候有中断，问题出在_p1 = n + stoi(_s1.substr(1));这一行，一开始我寻思就一行代码，不加花括号了，然后就中断了，加了花括号括起来，就没中断了 有一次跑的时候，发现记录的minDis（也就是每个加油站距离居民楼最近的距离）不是inf（超出服务区）就是0，debug了下，发现是在遍历u能到的所有节点，看是否需要更新最短距离处，if (dis[u] + nd.dis &lt; dis[nd.v])这行代码，写成了if (dis[u] + dis[nd.dis] &lt; dis[nd.v]) 最后一处，就是发现最大的距离求对了，但平均数不对，debug了半天，发现是某一个dis算错了，于是开始查，查着查着发现怎么2号节点成了2号节点自己的邻居了？于是查输入，发现把_s2打成_s1了，麻了……最大距离都能求对是我没想到的…… 太马虎了，注意力可得提高点 " }, { "title": "PAT-Forwards on Weibo", "url": "/posts/PAT-Forwards-on-Weibo/", "categories": "算法刷题, PAT", "tags": "图的遍历", "date": "2022-08-12 09:38:00 +0000", "snippet": "A1076 Forwards on Weibo#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;using namespace std;const int maxn = 1010;vector&lt;vector&lt;int&gt;&gt; users(1...", "content": "A1076 Forwards on Weibo#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;using namespace std;const int maxn = 1010;vector&lt;vector&lt;int&gt;&gt; users(1010);int n, l, k, forwards;//用户总人数、间接粉丝层数、询问个数、最大转发数bool isVisited[maxn] = { false };//回溯三部曲//1.确认返回类型和参数void dfs(int user, int level){ //2.终止条件 if (level &gt; l) return; //3.每次回溯的遍历过程 for (int fan : users[user])//遍历该user的粉丝以及粉丝的粉丝 { if (!isVisited[fan])//如果没有遍历过 { isVisited[fan] = true;//先置为true forwards++; } dfs(fan, level + 1); }}int main(){ cin &gt;&gt; n &gt;&gt; l; for (int i = 1; i &lt;= n; i++) { int _num; scanf(\"%d\", &amp;_num); for (int j = 0; j &lt; _num; j++)//遍历每个用户关注的人 { int _follows; scanf(\"%d\", &amp;_follows); users[_follows].emplace_back(i);//给他关注的人的粉丝列表中添加自己 } } cin &gt;&gt; k; for (int i = 0; i &lt; k; i++) { int _user; cin &gt;&gt; _user; //重置最大转发数和visited数组 forwards = 0; fill(isVisited + 1, isVisited + 1 + n, false); isVisited[_user] = true;//先把自己设置为true，也就是说自己不能算转发量 dfs(_user, 1); //cout &lt;&lt; forwards &lt;&lt; endl; printf(\"%d\\n\", forwards); }}    这个使用dfs写的，但最后一组数据会超时（换成printf和scanf也超时），而且调试正确也花了段时间，这里面有一些坑： 遍历过的节点就不能继续dfs了吗？错误的，只有level超限了才不能dfs，因为如果最开始以level的层数（因为是深度优先遍历）遍历过一个节点（也就是说visted设置为true了），那么在回溯时，发现了这个节点，但level可能并没有超限，所以尽管遍历过它，仍然需要继续遍历它的邻接表，只是不用再多加一次转发数了 由于dfs最后一组会超时，所以还是采用bfs吧 #include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;queue&gt;using namespace std;const int maxn = 1010;vector&lt;vector&lt;int&gt;&gt; fans(maxn);//每个用户的粉丝列表vector&lt;int&gt; layer(maxn);//记录每个用户的层数bool isVisited[maxn] = { false };int n, l, k;//用户总数、层数、询问次数//广度优先遍历int BFS(int user){ queue&lt;int&gt; q;//储存粉丝的队列 q.push(user);//先把自己加进去 //设置自己为0层 layer[user] = 0; fill(isVisited + 1, isVisited + 1 + n, false);//重置visited数组 isVisited[user] = true;//先把自己设置为true int forwards = 0;//统计转发数 while (!q.empty()) { int top = q.front(); q.pop(); for (int fan : fans[top])//遍历自己的每一个粉丝 { if (isVisited[fan]) continue;//如果之前遍历过，直接跳过 layer[fan] = layer[top] + 1;//自己粉丝的层数为自己的+1 if (layer[fan] &lt;= l)//如果没遍历过，而且所在层数小于等于l { isVisited[fan] = true; forwards++;//转发数+1 q.push(fan);//将这个粉丝加入队列 } } } return forwards;}int main(){ cin &gt;&gt; n &gt;&gt; l; for (int i = 1; i &lt;= n; i++) { int _num;//关注人数 cin &gt;&gt; _num; for (int j = 0; j &lt; _num; j++) { int _follows; cin &gt;&gt; _follows; fans[_follows].emplace_back(i);//将自己加入到关注的人的粉丝列表 } } cin &gt;&gt; k; for (int i = 0; i &lt; k; i++) { int _user; cin &gt;&gt; _user; cout &lt;&lt; BFS(_user) &lt;&lt; endl; }}    这个BFS还是有点坑的： 关于层数的增加时机，不能在遍历到粉丝的开始就将当前粉丝置为top的层数+1，这样会导致一种情况：更改某个用户所在的层数。什么意思呢？就是说，其实每个用户在整个遍历过程中有且只有一个对应的层数。假设用户A有粉丝B和C，C有粉丝B，一旦在用户C的粉丝列表那里再一次遇到已经遍历过的用户B，如果上来就让B的层数+1，显然就更改了B的层数，那么在遍历B的粉丝的时候，B的粉丝层数就会多1，这样就会导致最终的转发数减少。所以，遇到遍历过的节点，直接continue跳过最方便了。" }, { "title": "PAT-Insertion or Heap Sort", "url": "/posts/PAT-Insertion-or-Heap-Sort/", "categories": "算法刷题, PAT", "tags": "堆", "date": "2022-08-11 09:38:00 +0000", "snippet": "1098 Insertion or Heap Sort#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 101;int n;//元素个数vector&lt;int&gt; origin(maxn);//原始数组vector&lt...", "content": "1098 Insertion or Heap Sort#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 101;int n;//元素个数vector&lt;int&gt; origin(maxn);//原始数组vector&lt;int&gt; partial(maxn);//部分排序的数组bool IsSame(vector&lt;int&gt;&amp; tmp)//比较当前排序的序列是否和partial一致{ for (int i = 1; i &lt;= n; i++) { if (tmp[i] != partial[i]) return false; } return true;}void ShowArray(vector&lt;int&gt; a){ for (int i = 1; i &lt;= n; i++) { if (i == 1) cout &lt;&lt; a[i]; else cout &lt;&lt; ' ' &lt;&lt; a[i]; }}//插入排序bool Insert(vector&lt;int&gt;&amp; origin){ bool flag = false;//用来判断是否和partial一致 for (int i = 2; i &lt;= n; i++)//进行n-1次插入 { if (i != 2 &amp;&amp; IsSame(origin))//第一次插入前不进行判断 { flag = true; } //开始插入 int j = i; while (j &gt; 1 &amp;&amp; origin[j - 1] &gt; origin[j])//如果j前一位大于j { int tmp = origin[j - 1]; origin[j - 1] = origin[j]; origin[j] = tmp; j--; } //判断是否是否和partial一样，一样的话就终止循环，返回true了 if (flag) return true; } //排完了，也没和partial一样 return false;}//向下调整函数void DownAdjust(int low, int high){ int i = low, j = i * 2;//i为欲调整节点，j为孩子节点 while (j &lt;= high)//还有孩子节点 { //判断是否有右孩子,如果有右孩子而且比左孩子大 if (j + 1 &lt;= high &amp;&amp; origin[j + 1] &gt; origin[j]) { j = j + 1;//记录最大的孩子为右孩子 } //判断i与j的大小 if (origin[i] &lt; origin[j])//如果欲调整节点小于其最大的孩子节点 { //那就要开始向下走了 swap(origin[i], origin[j]);//交换两个节点的值 i = j;//i移动到j了，要继续向下调整，直到调整到合适的位置 j = i * 2;//j还是i的孩子节点 } else break;//如果调整到合适位置了，就退出 }}//堆排序void Heap(){ bool flag = false;//判断是否已经和partial一致了 //先建堆 for (int i = n / 2; i &gt;= 1; i--)//只用向下调整每个非叶子节点（一共有n/2个非叶子节点） { DownAdjust(i, n); } //开始堆排序 for (int i = n; i &gt; 1; i--)//排n-1次 { //先判断是否和partial一样了 if (i != n &amp;&amp; IsSame(origin)) { flag = true; } swap(origin[1], origin[i]);//堆顶元素（最大的）放到序列尾部 //堆排序 DownAdjust(1, i - 1);//要把i排除掉，因为i往后都是排好序的了 if (flag) { ShowArray(origin); break; } }}int main(){ cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; origin[i]; } for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; partial[i]; } vector&lt;int&gt; temp(origin); if (Insert(temp)) { cout &lt;&lt; \"Insertion Sort\" &lt;&lt; endl; ShowArray(temp); } else//说明是堆排序 { cout &lt;&lt; \"Heap Sort\" &lt;&lt; endl; Heap(); }}    这道题涉及到了堆排序，堆排序主要就是向下调整函数，需要注意的点： 堆的构建直接用数组，并且起始下标从1开始，这样方便之后计算其孩子节点的下标，即i*2，所以插入排序也要从下标1开始 创建堆时，只需要向下调整非叶子节点，对于完全二叉树而言，非叶子节点的个数为n/2个 堆排序时，需要调换数组首尾的值，并且接着做向下调整来维持堆，注意此时向下调整的high要为i-1，因为i及往后都已经是排好序的了 堆排序是大顶堆 需要注意的一点是，刚开始还没有排的时候，不要判断是否和partial一致，否则会出现歧义 " }, { "title": "PAT-Build A Binary Search Tree & Root of AVL Tree & Social Clusters", "url": "/posts/PAT-Build-A-Binary-Search-Tree-&-Root-of-AVL-Tree-&-Social-Clusters/", "categories": "算法刷题, PAT", "tags": "BST, AVL, 并查集", "date": "2022-08-10 15:38:00 +0000", "snippet": "A1099 Build A Binary Search Tree#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;struct node{ int val, left, right;};const int maxn...", "content": "A1099 Build A Binary Search Tree#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;struct node{ int val, left, right;};const int maxn = 100;vector&lt;node&gt; bst(maxn);vector&lt;int&gt; keys(maxn);int n;//树的节点总数int index = 0;//从0开始赋值vector&lt;int&gt; levelkey;void inTravelsal(int root){ //终止条件 if (root &gt;= n || root == -1) return;//说明这个节点不存在 //中序遍历 inTravelsal(bst[root].left); bst[root].val = keys[index++]; inTravelsal(bst[root].right);}void levelTravelsal(int root){ queue&lt;int&gt; q; q.push(root); while (!q.empty()) { int top = q.front(); q.pop(); levelkey.emplace_back(bst[top].val); //把该节点的孩子都放入队列中 if (bst[top].left != -1) q.push(bst[top].left); if (bst[top].right != -1) q.push(bst[top].right); }}int main(){ cin &gt;&gt; n; //读取树的结构 for (int i = 0; i &lt; n; i++) { cin &gt;&gt; bst[i].left; cin &gt;&gt; bst[i].right; } //读取键值 for (int i = 0; i &lt; n; i++) { cin &gt;&gt; keys[i]; } sort(keys.begin(), keys.begin() + n); //中序遍历为树的每个节点来赋值 inTravelsal(0); //层序遍历输出答案 levelTravelsal(0); //输出答案 for (int i = 0; i &lt; n; i++) { if (i == 0) cout &lt;&lt; levelkey[i]; else cout &lt;&lt; ' ' &lt;&lt; levelkey[i]; }}    这道题目就是中序遍历建二叉搜索树，再层序遍历输出，需要注意的地方有两点： sort时，由于我初始化数组，给了数组maxn的空间，所以排序时不能简单地调用sort(keys.begin(), keys.end())，要明确排序地范围 在中序遍历时，终止条件要记得加上root != -1否则会提示数组越界 A1066Root of AVL Tree#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;//AVL树的节点struct node{ int height = 1;//默认新建一个节点的高度是1 int val;//节点的权值 node* left = nullptr, * right = nullptr;//左右孩子，默认是空值 node(int _val) :val(_val) {}};//获取某个节点的高度（包括空节点）int GetHeight(node*&amp; root){ if (root == nullptr) return 0; else return root-&gt;height;}//实现获取当前平衡因子的函数int BalanceFactor(node*&amp; root){ return GetHeight(root-&gt;left) - GetHeight(root-&gt;right);}void UpdateHeight(node*&amp; root){ root-&gt;height = max(GetHeight(root-&gt;left), GetHeight(root-&gt;right)) + 1;}//实现AVL树右旋void R(node*&amp; root){ node* tmp = root-&gt;left;//存下root的左子树指针 //root的left更新为其左子树的右子树 root-&gt;left = tmp-&gt;right; //root左子树的right指向root tmp-&gt;right = root; //旋转后要更新两个节点的高度 UpdateHeight(root);//先更新低的 UpdateHeight(tmp);//再更新高的 //将root更新为tmp root = tmp;}//实现AVL树左旋void L(node*&amp; root){ node* tmp = root-&gt;right;//储存root的right指针 //root的right要更新为其右子树的左子树 root-&gt;right = tmp-&gt;left; //root右子树的left要指向root tmp-&gt;left = root; //更新两个节点的高度 UpdateHeight(root);//先更新低的 UpdateHeight(tmp); //将root更新 root = tmp;}//实现插入节点的函数void Insert(node*&amp; root, int val){ if (root == nullptr)//当前递归到的节点为空时，在此处插入节点 { node* n = new node(val); root = n; return; } //如果不空，说明还要继续寻找合适的位置 if (val &lt; root-&gt;val)//如果要插入的值小于当前节点的值 { //那么就要插入该节点的左孩子处 Insert(root-&gt;left, val); //更新root的高度(因为是插入了root的左孩子处)(最先更新的时候，已经是最后一层递归) UpdateHeight(root); //根据新高度的值来进行旋转 //都往左插了，只可能能是L型树 if (BalanceFactor(root) == 2)//说明是L型树 { if (BalanceFactor(root-&gt;left) == 1)//说明是LL型树 { //直接右旋即可 R(root); } else if (BalanceFactor(root-&gt;left) == -1)//说明是LR型树 { //先左旋再右旋 L(root-&gt;left); R(root); } } } else//如果要插入的值大于当前节点的值 { //那么就要插入该节点的右孩子处 Insert(root-&gt;right, val); //更新root的高度(因为是插入了root的左孩子处)(最先更新的时候，已经是最后一层递归) UpdateHeight(root); //既然往右插了，只可能是R型树 if (BalanceFactor(root) == -2)//说明是R型树 { if (BalanceFactor(root-&gt;right) == -1)//说明是RR型树 { //直接左旋 L(root); } else if (BalanceFactor(root-&gt;right) == 1)//说明是RL型树 { //先右旋再左旋 R(root-&gt;right); L(root); } } }}int main(){ int n;//节点总数 cin &gt;&gt; n; node* root = nullptr; for (int i = 0; i &lt; n; i++) { int _val; cin &gt;&gt; _val; Insert(root, _val); } cout &lt;&lt; root-&gt;val;}    这道题目非常具有挑战性。需要对AVL树（二叉平衡树）有足够的了解，要懂得AVL树的插入方法，也就是左旋以及右旋的方法，具体思路在算法笔记已经很详细了，我就不记了，主要说一些我出错的一些点： 首先在写的时候我寻思直接调取height不就行了么，何必非得写个GetHeight函数呢，写到后面才发现，如果调取height的root是空指针呢？这不就报错了，所以，写成函数的话，可以加一层判断，如果是空指针，那就放回0的高度 其次是左旋右旋的问题，其实搞明白了左右旋，但运行时，出现了中断，提示说tmp为空指针，那么为什么tmp是空指针呢？这是因为我函数名写反了，我在推导时，LL型树要进行右旋才可以，但写完右旋函数后，函数命名却是L（受LL型树混淆了），所以才会出现空指针的问题 最后就是，在跑测试样例时发现第二个不对，看了下，插入时只写了要插入的值小于当前节点值的情况了，把另一个分支给忘了（代码太长了，忘写另一部分了）。此时也正好发现，两种分支各对应一种树也就是R型和L型，这个大类可以率先分开 A1107 Social Clusters#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 1010;vector&lt;int&gt; father(maxn);//记录每个人的父亲节点vector&lt;int&gt; isRoot(maxn, 0);//记录每个节点是否为根节点，是的话，记录集合有几个元素vector&lt;int&gt; hobbyFather(maxn, 0);//记录每种hobby的father是谁int n;//记录节点总数// 寻找x的根父亲节点 函数int FindFather(int x){ int a = x;//储存x，用于接下来路径压缩 //只有x = father[x]时，x才是根节点 while (x != father[x]) { x = father[x]; } //循环完也就找到x是根父节点 //路径压缩 while (a != father[a]) { int z = a; a = father[a];//要把a的直接father的父节点也更新 father[a] = x;//将a也就是一开始的x的父节点重置为根父节点，这样方便下次查询 } return x;//返回父节点}//合并两个集合的函数void Union(int a, int b){ //先找到两个人的根节点 int fa = FindFather(a); int fb = FindFather(b); //把其中一个人(fb)的父亲节点设置为对方(fa) if(fa != fb) father[fb] = fa;}//初始化father数组，每个人在成为集合前，自己是自己的father，也就是说随时可以做某个hobby的根父节点void init(){ for (int i = 1; i &lt;= n; i++) { father[i] = i; }}bool comp(int a, int b){ return a &gt; b;//大的在前面}int main(){ //读取节点总数 cin &gt;&gt; n; init(); for (int i = 1; i &lt;= n; i++) { int _num; cin &gt;&gt; _num; getchar();//吸收冒号 while (_num--) { int _hobby; cin &gt;&gt; _hobby; //先检查这个hobby之前有没有人 if (hobbyFather[_hobby] == 0)//说明没有人 { //那么i就让自己的father自告奋勇，做第一个这个集群的father hobbyFather[_hobby] = i; } //不管有没有人，都将这个i合并到这个爱好的根父节点(之前没有人的话，其实不union也行) Union(FindFather(hobbyFather[_hobby]), i); } } //接下来统计每个人的根父节点是谁 for (int i = 1; i &lt;= n; i++) { isRoot[FindFather(i)]++; } int ans = 0;//记录集群总数 for (int i = 1; i &lt;= n; i++) { if (isRoot[i] != 0) ans++; } cout &lt;&lt; ans &lt;&lt; endl; //给集群人数排序 sort(isRoot.begin() + 1, isRoot.begin() + 1 + n, comp); for (int i = 1; i &lt;= ans; i++) { if (i == 1) cout &lt;&lt; isRoot[i]; else cout &lt;&lt; ' ' &lt;&lt; isRoot[i]; }}    这道题是并查集的一道题，之前从来没做过并查集的题，长见识了，第一次接触还是有点生疏的，注意下面几个点： 关于记录根节点，其实只要记录住每个爱好的同好有一个人就行，这样就能直接找到这个爱好所属的集合的根节点，这样的话，都遍历完后，再遍历每个人，去查他的根节点是谁，就可以记录准确的集群人数了" }, { "title": "GAMES101-Lecture 07 Shading 1(Illumination, Shading and Graphics Pipeline) & 作业2", "url": "/posts/GAMES101-Lecture-07-Shading-1(Illumination,-Shading-and-Graphics-Pipeline)/", "categories": "Computer Graphics, GAMES101", "tags": "图形学, 学习笔记", "date": "2022-08-09 10:08:00 +0000", "snippet": "Rasterization 前两点算是上一节光栅化的内容Painter’s Algorithm 从远到近画，把深度排序（O(nlogn)），然后画出来Z-Buffer 每个像素永远去记录这个像素所表示的几何最浅的深度 z目前设置为总为正的，意为与相机的距离 生成最终渲染图的同时，还需要另一个图像，储存像素所看到的最浅的深度信息（深度图/深度缓存） ...", "content": "Rasterization 前两点算是上一节光栅化的内容Painter’s Algorithm 从远到近画，把深度排序（O(nlogn)），然后画出来Z-Buffer 每个像素永远去记录这个像素所表示的几何最浅的深度 z目前设置为总为正的，意为与相机的距离 生成最终渲染图的同时，还需要另一个图像，储存像素所看到的最浅的深度信息（深度图/深度缓存） Z-Buffer Algorithm //初始化深度缓冲为正无穷//在光栅化过程中：for(each triangle T){ for(each sample(x,y,z)in T) { if(z&lt;zbuffer[x,y])//目前最近的采样点 { framebuffer[x,y]=rgb;//更新颜色 zbuffer[x,y]=z;//跟新深度图中该像素的深度 } }} 复杂度：O(n)（n个三角形*常数个像素个数） 由于深度是浮点型，而浮点型的相等是很困难的，基本上是不会一样的，但也是有出现的可能，但在本课不做讨论 不是对每个像素做z-buffer而是每个采样点（比如MSAA） 这是一个非常重要的算法，应用在所有的GPU上 Shading（着色） 对一个物体应用一个材质 一个简单的着色模型：Blinn-Phong Reflectance Model 镜面高光(Specular highlights)、漫反射(Diffuse reflection)、环境光照(Ambient lighting)Shading is Local（着色具有局部性，不管阴影）    先定义一些变量，每一个shading point都有以下inputs（方向都是单位向量） 注视方向，v 表面法线，n 光照方向，l 表面参数，颜色、亮度 着色具有局部性，并不会生成阴影 Diffuse Reflection 反射到四面八方 Lambert’s cosine law（光线与发现的夹角的余弦）:$\\cos\\theta = \\vec{l}*\\vec{n}$ shading point处接收到的光照能量与cosθ成正比 点光源的光线传播的能量衰减与距离半径r^2成反比 $k_d$是漫反射系数（颜色吸收，1意味着不吸收能量，全部反射出去，0意味着全吸收，表现为黑色；如果是一个向量，就可以表示颜色了，其实就可以是rgb），$I/r^2$是光线到达着色点处的能量大小\\[L_d = k_d(I/r^2)max(0, \\vec{n}\\cdot\\vec{l})\\] 当光线方向和法线方向夹角大于90°时不考虑这个光，此时$\\vec{l}*\\vec{n}&lt;0$，因此取0 无论从哪个方向看，同一个着色点的亮度是一样的 作业2 任务描述： 创建三角形的 2 维 bounding box。 遍历此 bounding box 内的所有像素（使用其整数索引）。然后，使用像素中 心的屏幕空间坐标来检查中心点是否在三角形内。 如果在内部，则将其位置处的插值深度值 (interpolated depth value) 与深度 缓冲区 (depth buffer) 中的相应值进行比较。 如果当前点更靠近相机，请设置像素颜色并更新深度缓冲区 (depth buffer)。 创建bounding box其实就是取三角形三个点的最小x值作为box左上角的x坐标，三个点的最大y值作为box左上角的y坐标，三个点的最大x值作为box右下角的x坐标，三个点的最小y值作为box右下角的y坐标 检查是否在三角形内，就是利用insideTriangle函数来判断，通过判断向量叉乘的z的正负来确定点是否在三角形内。已知Q点和三角形$P_0P_1P_2$，分成三个向量：$\\vec{P_0P_1}、\\vec{P_1P_2}、\\vec{P_2P_0}$，分别和$\\vec{P_0Q}、\\vec{P_1Q}、\\vec{P_2Q}$做叉积，如果得到的向量方向一致，说明点Q在三条边的同侧（如都在边的左侧），那么就在三角形内，否则（一旦出现叉积结果方向不一致），就说明在三角形外。 深度插值算法给了，但注意要取个负号才能变正 使用set_pixel函数来设置像素 源码： static bool insideTriangle(int x, int y, const Vector3f* _v){ // TODO : Implement this function to check if the point (x, y) is inside the triangle represented by _v[0], _v[1], _v[2] Eigen::Vector3f p0p1(_v[1].x() - _v[0].x(), _v[1].y() - _v[0].y(), 0); Eigen::Vector3f p1p2(_v[2].x() - _v[1].x(), _v[2].y() - _v[1].y(), 0); Eigen::Vector3f p2p0(_v[0].x() - _v[2].x(), _v[0].y() - _v[2].y(), 0); Eigen::Vector3f p0Q(x - _v[0].x(), y - _v[0].y(), 0); Eigen::Vector3f p1Q(x - _v[1].x(), y - _v[1].y(), 0); Eigen::Vector3f p2Q(x - _v[2].x(), y - _v[2].y(), 0); if (p0p1.cross(p0Q).z() &lt; 0 || p1p2.cross(p1Q).z() &lt; 0 || p2p0.cross(p2Q).z() &lt; 0) { return false; } else return true;}void rst::rasterizer::rasterize_triangle(const Triangle&amp; t) { auto v = t.toVector4(); float alpha, beta, gamma; // TODO : Find out the bounding box of current triangle. // iterate through the pixel and find if the current pixel is inside the triangle Eigen::Vector2f leftTop(floor(std::min(std::min(v[0].x(), v[1].x()), v[2].x())),ceil(std::max(std::max(v[0].y(), v[1].y()), v[2].y()))); Eigen::Vector2f rightBottom(ceil(std::max(std::max(v[0].x(), v[1].x()), v[2].x())), floor(std::min(std::min(v[0].y(), v[1].y()), v[2].y()))); for (float i = leftTop.x(); i &lt;= rightBottom.x(); i++) { for (float j = rightBottom.y(); j &lt;= leftTop.y(); j++) { if (insideTriangle(i, j, t.v)) { std::tie(alpha, beta, gamma) = computeBarycentric2D(i+0.5, j+0.5, t.v); float w_reciprocal = 1.0/(alpha / v[0].w() + beta / v[1].w() + gamma / v[2].w()); float z_interpolated = alpha * v[0].z() / v[0].w() + beta * v[1].z() / v[1].w() + gamma * v[2].z() / v[2].w(); z_interpolated *= w_reciprocal; if (-z_interpolated &lt; depth_buf[get_index(i, j)]) { set_pixel({ i,j,1 }, t.getColor()); depth_buf[get_index(i, j)] = -z_interpolated; } } } } // If so, use the following code to get the interpolated z value. //auto[alpha, beta, gamma] = computeBarycentric2D(x, y, t.v); //float w_reciprocal = 1.0/(alpha / v[0].w() + beta / v[1].w() + gamma / v[2].w()); //float z_interpolated = alpha * v[0].z() / v[0].w() + beta * v[1].z() / v[1].w() + gamma * v[2].z() / v[2].w(); //z_interpolated *= w_reciprocal; // TODO : set the current pixel (use the set_pixel function) to the color of the triangle (use getColor function) if it should be painted.} MSAA超采样反走样：就是把一个像素分为四块，检查四个小块是否在三角形内，根据个数比例修改颜色大小的比例void rst::rasterizer::rasterize_triangle(const Triangle&amp; t) { auto v = t.toVector4(); float alpha, beta, gamma; // TODO : Find out the bounding box of current triangle. // iterate through the pixel and find if the current pixel is inside the triangle Eigen::Vector2f leftTop(floor(std::min(std::min(v[0].x(), v[1].x()), v[2].x())),ceil(std::max(std::max(v[0].y(), v[1].y()), v[2].y()))); Eigen::Vector2f rightBottom(ceil(std::max(std::max(v[0].x(), v[1].x()), v[2].x())), floor(std::min(std::min(v[0].y(), v[1].y()), v[2].y()))); Eigen::Vector2f pos[4] = { {0.25,0.25}, {0.25,0.75}, {0.75,0.25}, {0.75,0.75} }; for (float i = leftTop.x(); i &lt;= rightBottom.x(); i++) { for (float j = rightBottom.y(); j &lt;= leftTop.y(); j++) { int cnt = 0; for (int k = 0; k &lt; 4; k++) { if (insideTriangle(i + pos[k][0], j + pos[k][1], t.v)) cnt++; } if (cnt) { std::tie(alpha, beta, gamma) = computeBarycentric2D(i+0.5, j+0.5, t.v); float w_reciprocal = 1.0/(alpha / v[0].w() + beta / v[1].w() + gamma / v[2].w()); float z_interpolated = alpha * v[0].z() / v[0].w() + beta * v[1].z() / v[1].w() + gamma * v[2].z() / v[2].w(); z_interpolated *= w_reciprocal; if (-z_interpolated &lt; depth_buf[get_index(i, j)]) { set_pixel({ i,j,1 }, t.getColor() * cnt / 4); depth_buf[get_index(i, j)] = -z_interpolated; } } } } // If so, use the following code to get the interpolated z value. //auto[alpha, beta, gamma] = computeBarycentric2D(x, y, t.v); //float w_reciprocal = 1.0/(alpha / v[0].w() + beta / v[1].w() + gamma / v[2].w()); //float z_interpolated = alpha * v[0].z() / v[0].w() + beta * v[1].z() / v[1].w() + gamma * v[2].z() / v[2].w(); //z_interpolated *= w_reciprocal; // TODO : set the current pixel (use the set_pixel function) to the color of the triangle (use getColor function) if it should be painted.} 注意： 开始自己写的时候，只写了个判断是否在三角形内的函数，开始想用叉乘出来的向量进行判断，但标准化可能出问题了（我直接用的Identity()函数），导致绘制出来的是矩形，怪。后来改成用z值得正负来判断就行了 光栅器自带得depth_buf数组其实就是深度缓冲区，并且使用get_index()函数可以通过坐标映射到缓冲区中的位置 在算bounding box的时候注意向下取整和向上取整，不然绘制的那个小三角形会很奇怪 在遍历bounding box的时候，用的是float变量 要把main.cpp文件中get_projection_matrix函数的t值加个负号，才能显示正的三角形（t也就是摄像机的向上方向） 上面其实也不一定需要给t加负号，在设置投影矩阵的时候，zNear和zFar都加个负号也行 又写了一遍，但大体上差不多，就不再记录了 " }, { "title": "PAT-Highest Price in Supply Chain & The Largest Generation & Lowest Price in Supply Chain & Path of Equal Weight & Complete Binary Search Tree", "url": "/posts/PAT-Highest-Price-in-Supply-Chain-&-The-Largest-Generation-&-Lowest-Price-in-Supply-Chain-&-Path-of-Equal-Weight-&-Complete/", "categories": "算法刷题, PAT", "tags": "树的遍历, BST", "date": "2022-08-09 09:22:00 +0000", "snippet": "A1090 Highest Price in Supply Chain#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;using namespace std;//节点结构体struct node{ vector&lt;int&gt; child;};int ...", "content": "A1090 Highest Price in Supply Chain#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;using namespace std;//节点结构体struct node{ vector&lt;int&gt; child;};int n;//节点总数double price, r;//单价和涨幅double highest = 0.0;//最高价格int retailersNum = 0;//销售最高价的零售商个数const int maxn = 100010;int root;//根节点下标vector&lt;node&gt; supply(maxn);//回溯三部曲//1.确认返回类型和参数void travelsal(int root, int depth){ //2.终止条件 //先判断是不是叶子节点 if (supply[root].child.empty())//是叶子节点，算钱,中止 { double tmp = (price * pow(1 + r, depth)); if (tmp &gt; highest) { highest = tmp;//更新最大值 retailersNum = 1;//刷新人数 } else if (tmp == highest) { retailersNum++; } } else//不是叶子节点 { //3.每个回溯的遍历过程 for (int c : supply[root].child) { travelsal(c, depth + 1); } }}int main(){ cin &gt;&gt; n &gt;&gt; price &gt;&gt; r; r /= 100; for (int i = 0; i &lt; n; i++) { int _num; cin &gt;&gt; _num;//自己的供应商 if (_num == -1)//说明是根节点 { root = i; } else//说明_num是i的供应商 { supply[_num].child.emplace_back(i); } } travelsal(root, 0); printf(\"%.2f %d\", highest, retailersNum);}    这道题和昨天做的最后一题几乎一样，就是要算的东西不一样，尽管如此也有需要注意的地方。 算价钱时要用double不能用int 开始中断显示数组越界，我就猜哪里可能出-1了，果然，在读取数据时，遇到根节点root=i才对，不能是root=_num，因为此时_num是-1。 A1094 The Largest Generation#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;using namespace std;//节点结构体struct node{ vector&lt;int&gt; children;};int n, m;//家族总人数，有孩子的人数vector&lt;node&gt; family(100);//家族静态树vector&lt;int&gt; population(100, 0);//记录每层的人口int maxPop = 0;int maxDep = 0;//回溯三部曲//1.确认返回类型，参数void travelsal(int root, int depth){ //先计算本层孩子 population[depth]++; if (population[depth] &gt; maxPop)//更新人口最大代 { maxPop = population[depth]; maxDep = depth; } //2.中止条件 if (family[root].children.empty()) return; else { //3.每次回溯的遍历 for (int c : family[root].children) { travelsal(c, depth + 1); } }}int main(){ cin &gt;&gt; n &gt;&gt; m; //读取家族树 for (int i = 0; i &lt; m; i++) { int _index, _num; cin &gt;&gt; _index &gt;&gt; _num; for (int j = 0; j &lt; _num; j++) { int _child; cin &gt;&gt; _child; family[_index].children.emplace_back(_child); } } travelsal(1, 1); cout &lt;&lt; maxPop &lt;&lt; ' ' &lt;&lt; maxDep;}    依旧是遍历，并记录深度，更之前的两道题很类似。A1106 Lowest Price in Supply Chain#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;using namespace std;//节点结构体struct node{ vector&lt;int&gt; children;};int n;double price, r;int maxn = 100010;vector&lt;node&gt; supply(maxn);double lowest = 1e10;//最低价int lowNum = 0;//最低价人数//回溯三部曲//1.确认返回类型和参数void travelsal(int root, int depth){ //2.中止条件 if (supply[root].children.empty())//是叶子节点 { double tmp = price * pow(1 + r, depth); if (tmp &lt; lowest)//更新最低价格 { lowest = tmp; lowNum = 1; } else if (tmp == lowest) { lowNum++; } } else//3.每次回溯的遍历 { for (int c : supply[root].children) { travelsal(c, depth + 1); } }}int main(){ cin &gt;&gt; n &gt;&gt; price &gt;&gt; r; r /= 100; for (int i = 0; i &lt; n; i++) { int _num; cin &gt;&gt; _num; if (_num != 0)//说明有孩子 { for (int j = 0; j &lt; _num; j++) { int _child; cin &gt;&gt; _child; supply[i].children.emplace_back(_child); } } } travelsal(0, 0); printf(\"%.4f %d\", lowest, lowNum);}    还是供应商问题，出现了段错误，查了下，发现是maxn初始化小了，初始化成一万了，应该是十万，不然有的数据会越界。A1053 Path of Equal Weight#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;//节点结构体struct node{ int weight; vector&lt;int&gt; children;};const int maxn = 100;int n, m, s;//节点总数、非叶子节点数、目标权重和vector&lt;node&gt; tree(maxn);vector&lt; vector&lt;int&gt;&gt; path;vector&lt;int&gt; tmpPath;//回溯三部曲//1.确认返回类型和参数void travelsal(int root, int sum){ //2.中止条件:和已经超过s，或者满足条件 if (sum &gt; s) return; if (tree[root].children.empty() &amp;&amp; sum == s) { //先把临时路径存到总路径中 path.emplace_back(tmpPath); return;//也返回，不继续找了，因为都是正数 } //3.每次回溯的遍历 for (int c : tree[root].children) { tmpPath.emplace_back(tree[c].weight);//先把c的权重加入临时路径 travelsal(c, sum + tree[c].weight); tmpPath.pop_back();//把c再弹出来 }}bool comp2(vector&lt;int&gt;&amp; p1, vector&lt;int&gt;&amp; p2){ int times = min(p1.size(), p2.size()); for (int i = 0; i &lt; times; i++) { if (p1[i] != p2[i]) { //大的在前面 return p1[i] &gt; p2[i]; } } //完全相同的 return false;}int main(){ cin &gt;&gt; n &gt;&gt; m &gt;&gt; s; //读取每个节点的权重 for (int i = 0; i &lt; n; i++) { cin &gt;&gt; tree[i].weight; } //读取每个非叶子节点的孩子 for (int i = 0; i &lt; m; i++) { int _id, _num; cin &gt;&gt; _id &gt;&gt; _num; for (int j = 0; j &lt; _num; j++) { int _child; cin &gt;&gt; _child; tree[_id].children.emplace_back(_child); } } tmpPath.insert(tmpPath.begin(), tree[0].weight); travelsal(0, tree[0].weight); //找完所有的路径了，开始排序 //把所有的路排一下 sort(path.begin(), path.end(), comp2); //输出 for (auto p : path) { for (int i = 0; i &lt; p.size(); i++) { if (i != 0) cout &lt;&lt; ' ' &lt;&lt; p[i]; else cout &lt;&lt; p[i]; } cout &lt;&lt; endl; }}    这道题看似不难，但实际上坑很多，题目比较绕。 首先需要注意的是，放入路径的不是节点的序号，而是节点的权重 其次，题目中所说的non-increasing指的是所有的路径之间是非升序的，而不是单个路径中的权重是非升序的，也就是说不需要对单个路径的权重单独排序 最后有一处中断，就是一直提示是比较器错误，那么也就是sort函数的comp函数的问题，debug后发现，如果两个序列完全一样的话，return true就会比较错误，return false就不会比较错误了，怪。还好测试样例有两个一样的数据，不然如果是别的样例，那我又不知道要查多久了 A1064 Complete Binary Search Tree#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 1010;vector&lt;int&gt; CBT(maxn);//静态二叉树vector&lt;int&gt; val(maxn);int n;//节点个数int index = 0;//val数组下标//中序遍历void in(int root){ //中止条件 if (root &gt; n) return; //完全bst也就是cbt的节点，左孩子下标为root*2，有孩子下标为root*2 + 1 in(root * 2); CBT[root] = val[index++]; in(root * 2 + 1);}int main(){ cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; val[i]; } //给节点的值排序 sort(val.begin(), val.begin() + n); //bst的中序遍历是有序的 in(1); //打印结果，按顺序就是层序遍历的结果 for (int i = 1; i &lt;= n; i++) { if (i == 1) cout &lt;&lt; CBT[i]; else cout &lt;&lt; ' ' &lt;&lt; CBT[i]; }}    二叉搜索树，想做这道题，需要了解两个知识点： 二叉搜索树的中序遍历是递增的 完全二叉搜索树（静态树）的某个节点下标为root，其左孩子下标就是root×2，其右孩子下标是root×2 + 1 " }, { "title": "PAT-Integer Factorization & Acute Stroke & Tree Traversals Again & Invert a Binary Tree & Total Sales of Supply Chain", "url": "/posts/PAT-Integer-Factorization-&-Acute-Stroke-&-Tree-Traversals-Again-&-Invert-a-Binary-Tree-&-Total-Sales-of-Supply-Chain/", "categories": "算法刷题, PAT", "tags": "dfs, bfs, 二叉树的遍历, 树的遍历", "date": "2022-08-08 13:54:00 +0000", "snippet": "A1103 Integer Factorization#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;using namespace std;vector&lt;int&gt; fac, ans, tmp;//fa...", "content": "A1103 Integer Factorization#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;using namespace std;vector&lt;int&gt; fac, ans, tmp;//fac储存小于n的i^p数组，ans储存最后的底，tmp储存临时的底int n = -1, k = -1, p = -1;int maxSum = -1;void Fac(){ for (int i = 0; i &lt;= n; i++) { int power = pow(i, p); if (power &gt; n) break; else { fac.emplace_back(power); } }}//回溯三部曲//1.确认返回类型和参数//当前回溯的fac数组下标index，目前和sum，当前数字个数curK，当前底的和facSumvoid dfs(int index, int sum, int curK, int facSum){ //2.中止条件 if (curK == k &amp;&amp; sum == n)//当数字个数满足条件k，而且当前和已经相等了 { //先判断是否要更新当前的答案数组 if (facSum &gt; maxSum) { maxSum = facSum;//更新最大和 ans = tmp;//更新答案数组 } return; } //如果当前数字个数到k了，但总和却不是n；或者当前总和大于等于n，但数字个数不到k if (curK &gt; k || sum &gt; n ) return; //3.每层回溯的遍历过程 for (int i = index; i &gt; 0; i--) { tmp.emplace_back(i); dfs(i, sum + fac[i], curK + 1, facSum + i); tmp.pop_back(); }}int main(){ //cin &gt;&gt; n &gt;&gt; k &gt;&gt; p; scanf(\"%d %d %d\", &amp;n, &amp;k, &amp;p); //先算出i^p小于n的数组 Fac(); //回溯,从最大下标开始算 dfs(fac.size() - 1, 0, 0, 0); //打印结果： if (ans.empty()) { cout &lt;&lt; \"Impossible\"; } else { cout &lt;&lt; n &lt;&lt; \" =\"; for (int i = 0; i &lt; ans.size(); i++) { if (i != ans.size() - 1)//如果不是最后一项 printf(\" %d^%d +\", ans[i], p); //cout &lt;&lt; ' ' &lt;&lt; ans[i] &lt;&lt; '^' &lt;&lt; p &lt;&lt; \" +\"; else printf(\" %d^%d\", ans[i], p); //cout &lt;&lt; ' ' &lt;&lt; ans[i] &lt;&lt; '^' &lt;&lt; p; } }}    许久不做回溯的题目，这道题都有点不会了。主要是开始不知道该遍历哪些数，看了算法笔记，提前把需要遍历的数存到fac数组中去，有几个点需要注意下： 开始输出不对，检查后发现是在插入tmp中时，应该插入i而不是index 后来有一处一直超时，把cin和cout全改为printf和scanf还是不行；接着又改了下遍历部分，其实i是不会=0的，还是不行；又改了下剪枝，if (curK &gt; k || sum &gt; n ) return;，之前此处是个比较复杂的判断：if((curK == k &amp;&amp; sum != n) || sum &gt; n)，这样会超时。 A1091Acute Stroke#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;queue&gt;using namespace std;//节点结构体struct node{ int x, y, z;}Node;int m, n, l, t;//m*n矩阵，l切片层数, t阈值int ans = 0;//最终结果vector&lt; vector&lt; vector&lt;int&gt; &gt; &gt; brain(1290, vector&lt;vector&lt;int&gt;&gt;(130, vector&lt;int&gt;(61)));//int brain[1290][130][61];bool inque[1290][130][61] = {false};//增量数组int xOff[6] = { 0, 0, 0, 0, 1, -1 };int yOff[6] = { 0, 0, 1, -1, 0, 0 };int zOff[6] = { 1, -1, 0, 0, 0, 0 };//判断是否应该入队bool valid(int x, int y, int z){ //越界返回false if (x &lt; 0 || x &gt;= m || y &lt; 0 || y &gt;= n || z &lt; 0 || z &gt;= l) return false; //如果之前入过队或者是0，也返回false if (inque[x][y][z] || brain[x][y][z] == 0) return false; //否则就可以入队 return true;}//返回这一区域的所有为1的个数int bfs(int x, int y, int z){ int total = 0;//统计当前块的所有1的数量 queue&lt;node&gt; q;//储存坐标的队列 Node.x = x; Node.y = y; Node.z = z; //先设置为入过队了 inque[x][y][z] = true; q.push(Node); //只要队列不空，就遍历队列中的每个元素，去查它上下前后左右6个元素是否连接 while (!q.empty()) { node top = q.front();//获取队首 q.pop();//出队 //总数++ total++; for (int i = 0; i &lt; 6; i++) { int newX = top.x + xOff[i]; int newY = top.y + yOff[i]; int newZ = top.z + zOff[i]; if (valid(newX, newY, newZ))//如果该节点有效，入队 { inque[newX][newY][newZ] = true;//设置该坐标为入过队了 Node.x = newX, Node.y = newY, Node.z = newZ; q.push(Node);//入队 } } } if (total &gt;= t) return total; else return 0;}int main(){ cin &gt;&gt; m &gt;&gt; n &gt;&gt; l &gt;&gt; t; for (int z = 0; z &lt; l; z++)//z层切片 { for (int x = 0; x &lt; m; x++)//x行矩阵 { for (int y = 0; y &lt; n; y++)//y列矩阵 { cin&gt;&gt;brain[x][y][z]; } } } for (int z = 0; z &lt; l; z++)//z层切片 { for (int x = 0; x &lt; m; x++)//x行矩阵 { for (int y = 0; y &lt; n; y++)//y列矩阵 { if (brain[x][y][z] == 1 &amp;&amp; !inque[x][y][z]) { ans += bfs(x, y, z); } } } } cout &lt;&lt; ans;}    这道题目还是有一定难度的，需要注意的点比较多，接下来一一列出： 首先，也是最最需要注意的一点就是x,y,z这三个坐标所对应的三位数组的x,y,z，比如，在这道题目中x,y,z分别对应的是行，列和层，其实顺序可以颠倒，只要对应关系都保持一致即可，不然的话会内存超限，卡在循环里出不来。比如我开始是拿y做行，但是呢，我申请的数组y确实列的大小，在设置inque数组时x,y,z的对应也出了问题，导致卡在循环里出不来 其次，申请数组时，可以根据需求申请，其实直接申请数组，比申请vector要方便的多 注意total变量自加的区域，不要重复添加 需要写三个增量数组，这样的话方便搜索时循环遍历 A1086 Tree Traversals Again#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;//节点结构体struct node{ int val; node* left; node* right; node(int _val) :val(_val), left(nullptr), right(nullptr) {}}*root;int n;//节点个数vector&lt;int&gt; pre, in, post;node* build(int preL, int preR, int inL, int inR){ if (preL &gt; preR) return nullptr; //创建新的节点 node* n = new node(pre[preL]); //查找val在中序遍历数组中的下标 int index; for (int i = 0; i &lt; in.size(); i++) { if (in[i] == pre[preL]) index = i; } //构建该节点的左右子树 n-&gt;left = build(preL + 1, index - inL + preL, inL, index - 1); n-&gt;right = build(preR - inR + index + 1, preR, index + 1, inR); return n;}//后序遍历void travelsal(node* root){ //中止条件 if (root == nullptr) return; //后序遍历 travelsal(root-&gt;left); travelsal(root-&gt;right); post.emplace_back(root-&gt;val);}int main(){ cin &gt;&gt; n; vector&lt;int&gt; stack; for (int i = 0; i &lt; 2*n; i++) { string str; cin &gt;&gt; str; if (str == \"Push\") { int _pre; cin &gt;&gt; _pre; pre.emplace_back(_pre); stack.emplace_back(_pre);//入栈 } else { in.emplace_back(stack.back());//获取栈顶元素，放入中序遍历数组中 stack.pop_back();//出栈 } } //通过前序遍历数组和中序遍历数组构造二叉树，再得到后序遍历数组 root = build(0, n - 1, 0, n - 1); //后序遍历 travelsal(root); //打印结果 for (int i = 0; i &lt; n; i++) { if (i == 0) cout &lt;&lt; post[i]; else cout &lt;&lt; ' ' &lt;&lt; post[i]; }}    这道题经典通过两序推另一序，没啥好说的。A1102 Invert a Binary Tree#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;string&gt;using namespace std;//节点结构体struct node{ int left = -1; int right = -1;};vector&lt;node&gt; tree;vector&lt;bool&gt; isRoot(11, true);int n;//节点个数vector&lt;int&gt; level, in;void levelTravelsal(int root){ queue&lt;int&gt; q; q.push(root); while (!q.empty()) { int top = q.front(); level.emplace_back(top); q.pop(); //查top的左右子树，并加入队列 if (tree[top].left != -1) q.push(tree[top].left); if (tree[top].right != -1) q.push(tree[top].right); }}void inTravelsal(int root){ if (root == -1) return; inTravelsal(tree[root].left); in.emplace_back(root); inTravelsal(tree[root].right);}int main(){ cin &gt;&gt; n; //读取的时候顺便也就翻转了 for (int i = 0; i &lt; n; i++) { node n; string l, r; cin &gt;&gt; r &gt;&gt; l; if (l != \"-\")//说明不是空节点 { n.left = stoi(l); isRoot[n.left] = false;//该节点不可能是根节点 } if (r != \"-\") { n.right = stoi(r); isRoot[n.right] = false; } tree.emplace_back(n); } //寻找根节点下标 int root; for (int i = 0; i &lt; n; i++) { if (isRoot[i]) root = i; } //层序遍历 levelTravelsal(root); for (int i = 0; i &lt; n; i++) { if (i == 0) cout &lt;&lt; level[i]; else cout &lt;&lt; ' ' &lt;&lt; level[i]; } cout &lt;&lt; endl; //中序遍历 inTravelsal(root); for (int i = 0; i &lt; n; i++) { if (i == 0) cout &lt;&lt; in[i]; else cout &lt;&lt; ' ' &lt;&lt; in[i]; }}    这道题目不是很难，用到了静态树，没有用指针。需要注意的是，得记录根节点的下标。A1079 Total Sales of Supply Chain#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;using namespace std;//节点结构体struct node{ double weight;//货物量 vector&lt;int&gt; child;};int n;//节点总数double price, r;//单价和涨幅double total = 0.0;vector&lt;node&gt; supply;//回溯三部曲//1.确认返回类型和参数void travelsal(int root, int depth){ //2.终止条件 //先判断是不是叶子节点 if (supply[root].child.empty())//是叶子节点，算钱,中止 { total += (supply[root].weight * price * pow(1 + r, depth)); } else//不是叶子节点 { //3.每个回溯的遍历过程 for (int c : supply[root].child) { travelsal(c, depth + 1); } }}int main(){ cin &gt;&gt; n &gt;&gt; price &gt;&gt; r; r /= 100; for (int i = 0; i &lt; n; i++) { int _num; cin &gt;&gt; _num; node nd; if (_num == 0)//说明是零售商 { cin&gt;&gt;nd.weight;//读取需求量 } else//不是零售商 { for (int j = 0; j &lt; _num; j++)//记录每一个孩子 { int _child; cin &gt;&gt; _child; nd.child.emplace_back(_child); } } supply.emplace_back(nd);//将该节点加到静态树中 } travelsal(0, 0); printf(\"%.1f\", total);}    这道题目呢，其实就是一个多叉树的遍历，顺便记录下深度，需要注意的就是读入的r要除以一百。" }, { "title": "GAMES101-Lecture 06 Rasterization 2(Antialiasing and Z-Buffering)", "url": "/posts/GAMES101-Lecture-06-Rasterization-2(Antialiasing-and-Z-Buffering)/", "categories": "Computer Graphics, GAMES101", "tags": "图形学, 学习笔记", "date": "2022-08-05 12:59:00 +0000", "snippet": "Sample Artifacts(Errors,mistakes,inaccuracies图形学黑话) 锯齿、摩尔纹、车轮效应 信号的变化太快导致采样速度跟不上，就会产生走样 Antialias反走样 先做一个模糊/滤波，再采样（不能先采样再滤波） 需要先模糊再采样，不能反过来。那么为什么不能反过来呢，那是因为先采样会发生混叠，如果要完全删掉混叠就要删掉大量信号...", "content": "Sample Artifacts(Errors,mistakes,inaccuracies图形学黑话) 锯齿、摩尔纹、车轮效应 信号的变化太快导致采样速度跟不上，就会产生走样 Antialias反走样 先做一个模糊/滤波，再采样（不能先采样再滤波） 需要先模糊再采样，不能反过来。那么为什么不能反过来呢，那是因为先采样会发生混叠，如果要完全删掉混叠就要删掉大量信号，这样显然是不对的方法（原因放在后面看，后面会说什么是混叠）Frequency Domain 傅里叶级数展开：任何一个周期函数都可以写成一系列正弦、余弦函数的线性组合以及一个常数项 傅里叶变换：一个函数经过一个复杂的变换，变换成了另一个函数，也可以通过逆变换变回来 走样：同样一种采样方法，去采样两种频率截然不同的函数，得出的结果却一样，无法区分 滤波：把某个特定的频段删掉 傅里叶变换：时域-&gt;频域,中心低频，周围高频(越往外，频率越高，图像的频率是表征图像中灰度变化剧烈程度的指标) 白色代表着在该频段信号较多，比如中心很多白色说明图像的低频信号较多 为什么下面右侧的频域图会有横竖两条白线，那是因为傅里叶变换要变换周期函数，而这张图并不是，所以就当成在边缘会再次重复这张图，横竖都会这样重复，所以可以忽略这两条线 高通滤波：删掉低频段内容-&gt;提取出了轮廓 轮廓边缘信号变化非常大，意味着高频信息 低通滤波：删掉高频段内容-&gt;边界模糊 带通滤波：去掉高频和低频，留某一段Filtering = Convolution (卷积)(=Averaging) 时域上的卷积对应频域上的乘积，时域上的乘积对应频域上的卷积 卷积核也可以做傅里叶变换，这样的话频域图乘以卷积核的频域图得到的新图再逆变换回去得到的结果==时域图直接乘卷积核得到的结果 盒式滤波（如3×3），盒子越大（对应的频域图中，低频变多，高频变少，中心白色面积越小），越模糊，盒子越小，说明删掉的频段越少，更多的频率留了下来 Sampling=Repeating Frequency Contents 给一个原始的信号，乘上一个冲击函数，就可以得到采样结果；在频域上，频谱函数卷积冲击函数（傅里叶变换后的冲击函数），得到采样结果（采样就是重复一个原始信号的频谱） 如果采样速度不够大，也就是采样间隔越大，频谱复制的间隔就会变小造成混叠(至于为什么会一个变大一个变小，我目前还不是很清楚) 走样：因为采样的不同间隔会引起频谱以另外一个不同的间隔进行移动，频谱在复制粘贴搬移的过程中发生了混合/混叠Antialiasing 1：提高分辨率（但不属于反走样） 2：先拿掉高频信息，再采样 那么如何模糊？使用低通滤波器来卷积（也可以说是求个平均）Antialiasing by supersampling(MSAA:Multi Sample Anti Aliasing) 反走样的近似，一个像素被划分为多个区域，比如4*4，根据一个像素内区域覆盖率来模糊 MSAA只是做到了模糊，并没有提高屏幕的分辨率 牺牲了什么：4*4的话就是16倍的计算量 工业上并没有划分成规则的区域，而是一些特殊图案的采样点 里程碑： FXAA（Fast Approximate AA）快速近似抗锯齿（与采样无关，是先算出有锯齿的图，再想办法把锯齿换掉） TAA（Temporal AA）时间的抗锯齿（利用之前帧） 超分辨率/超采样 解决样本不足 DLSS（Deep Learning Super Sampling) " }, { "title": "PAT-Count PAT's & Quick Sort", "url": "/posts/PAT-Count-PAT's-&-Quick-Sort/", "categories": "算法刷题, PAT", "tags": "递推", "date": "2022-08-04 14:26:00 +0000", "snippet": "A1093 Count PAT’s#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 100010;const int MOD = 1000000007;int main(){ string str; cin &gt;...", "content": "A1093 Count PAT’s#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 100010;const int MOD = 1000000007;int main(){ string str; cin &gt;&gt; str; vector&lt;int&gt;leftP(maxn,0), rightT(maxn, 0);//分别记录每个下标左侧的P个数和下标右侧的T个数 if (str[0] == 'P') leftP[0] = 1; if (str[str.size() - 1] == 'T') rightT[str.size() - 1] = 1; for (int i = 1; i &lt; str.size(); i++)//从左到右遍历，统计P个数 { if (str[i] == 'P') { leftP[i] = leftP[i - 1] + 1; } else { leftP[i] = leftP[i - 1]; } } int ans = 0; //从右往前遍历，统计T个数，并顺便计算最终结果 for (int i = str.size() - 2; i &gt;= 0; i--) { if (str[i] == 'T')//如果当前下标是T { rightT[i] = rightT[i + 1] + 1;//那么当前下标右侧的T个数+1 } else//不是T { rightT[i] = rightT[i + 1];//那么当前下标右侧的T个数 if (str[i] == 'A')//如果当前下标是A，那么要算ans { ans += leftP[i] * rightT[i]; ans %= MOD; } } } cout &lt;&lt; ans;}    这道题其实我想到这个方法了，但我担心复杂度会不会太高了，但忘记可以先把数据存起来了，空间换时间啊。A1101 Quick Sort#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 100010;int main(){ int N;//数字个数 cin &gt;&gt; N; vector&lt;int&gt; num(maxn), leftMax(maxn, 0), rightMin(maxn, 0); int max = 0; int min = 1e9 + 1; int ansCnt = 0; vector&lt;int&gt; ans; for (int i = 0; i &lt; N; i++)//从前往后遍历，记录每个下标左侧的最大值 { cin &gt;&gt; num[i]; if (num[i] &gt; max)//如果当前下标的数大于左边最大的 { max = num[i];//更新max } leftMax[i] = max;//记录当前下标左侧最大值（包括当前下标） } for (int i = N - 1; i &gt;= 0; i--)//从后往前遍历，记录每个下标右侧的最小值，并判断是否为pivot { if (num[i] &lt; min)//如果当前下标的数小于右边最小的 { min = num[i];//更新min } rightMin[i] = min;//记录当前下标右侧最小值（包括当前下标） if (rightMin[i] == leftMax[i])//如果当前下标最大值和最小值一样（也就是本身） { ansCnt++; ans.emplace_back(rightMin[i]); } } cout &lt;&lt; ansCnt &lt;&lt; endl; for (int i = ans.size() - 1; i &gt;= 0; i--) { if (i != ans.size() - 1)//如果不是第一个，那就输出前置空格 { cout &lt;&lt;' ' &lt;&lt; ans[i]; } else cout &lt;&lt; ans[i]; } cout&lt;&lt;endl;}    这道题和上面那道的做法类似，开始有一个测试点会显示格式错误，在最后加个换行就行了，因为当pivot主元数字个数为0时，下面一行需要一个换行，不能什么都没有。" }, { "title": "基于Unreal5和TrueSkill的游戏匹配系统-多人在线功能技术文档", "url": "/posts/%E5%9F%BA%E4%BA%8EUnreal5%E5%92%8CTrueSkill%E7%9A%84%E6%B8%B8%E6%88%8F%E5%8C%B9%E9%85%8D%E7%B3%BB%E7%BB%9F-%E5%A4%9A%E4%BA%BA%E5%9C%A8%E7%BA%BF%E5%8A%9F%E8%83%BD%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/", "categories": "Unreal5, 多人在线游戏匹配系统", "tags": "多人在线, OnlineSubsystem", "date": "2022-08-03 03:45:00 +0000", "snippet": "一、Creating a Multiplayer Plugin1. Multiplayer Concepts Peer-to-peer连接 client-server模式： listen-server：玩家中一台机器做服务器 dedicated-server：专门的一台服务器 ...", "content": "一、Creating a Multiplayer Plugin1. Multiplayer Concepts Peer-to-peer连接 client-server模式： listen-server：玩家中一台机器做服务器 dedicated-server：专门的一台服务器 unreal engine multiplayer: authoritative client - server 模式： 可以根据配置来选择用哪种模式（监听服务器还是专用服务器模式） 2. Testing Multiplayer2.1 Testing in editor play按钮右侧的三个点中，可以改变number of player Net Mode： play standalone 单机模式 play as listen server，编辑器作为监听服务器 play as client 会创建一个专用服务器 2.2 setting up lan connection局域网 创建一个新的level：lobby（大厅），让其他玩家通过局域网连接进入（file-&gt;new level, save current level） 进入Third Person Character蓝图，创建蓝图，按1键打开新level，option填listen，作为监听服务器，2键执行command命令，输入Open 172.22.26.21 获取自己电脑的ip，打开cmd，输入ipconfig得到ipv4地址：IPv4 地址 . . . . . . . . . . . . : 172.22.26.21 打包出package project，放到新建的Build文件夹中 使用两台机器测试，连接同一个网络 3. LAN Connection3.1 C++创建局域网连接 Source -&gt; MultiplyShooter -&gt; MultiplyShooter.h（打错了，不过没关系，这个项目是用来测试多人玩家的）创建几个函数 //可以在蓝图中创建节点 UFUNCTION(BlueprintCallable) void OpenLobby(); UFUNCTION(BlueprintCallable) void CallOpenLevel(const FString&amp; Address); UFUNCTION(BlueprintCallable) void CallClientTravel(const FString&amp; Address); 在cpp文件实现 在官方文档查openlevel函数，加入官方文档中提到的头文件#include \"Kismet/GameplayStatics.h\" 这里面的CallOpenLevel()和CallClientTravel()函数的功能是一样的 void AMutiplyShooterCharacter::OpenLobby(){ UWorld* World = GetWorld(); if (World) { //右键level-&gt;get file path : E:/Ue5/MutiplyShooter/Content/ThirdPerson/Maps/Lobby.umap World-&gt;ServerTravel(\"/Game/ThirdPerson/Maps/Lobby?listen\"); }} void AMutiplyShooterCharacter::CallOpenLevel(const FString&amp; Address){ //Address是FString类型，加*就成了C风格的字符串，这个可以隐式地创建FName对象 UGameplayStatics::OpenLevel(this, *Address);}//让角色传送到ip地址为address的房间去void AMutiplyShooterCharacter::CallClientTravel(const FString&amp; Address){ //获取本地角色控制器 APlayerController* PlayerController = GetGameInstance()-&gt;GetFirstLocalPlayerController(); if (PlayerController) { PlayerController-&gt;ClientTravel(Address, ETravelType::TRAVEL_Absolute); }} 记得build后再回到编辑器（在vs里如果编译不成功，比如报错Unable to build while Live Coding is active. Exit the editor and game, or press Ctrl+Alt+F11 if iterating on code in the editor or game MutiplyShooter ，就在编辑器里按CTRL+ALT+F11来手动编译，可以编译成功）（或者在Edit -&gt; editor preference中搜索live coding，关掉，就能在vs编译了，而且这样就能打包了，不然用live coding没发打包） 进入角色控制器蓝图 打包测试（测试失败可能是ip地址错误的问题） 4. Online Subsystem    为了不输入对方的IP地址就同世界各地的人们一起游戏，需要使用一个服务器服务，比如steam，又为了避免使用不同服务器代码库不同带来的影响，虚幻引擎抽象了一层Online Subsystem，以至于只用写一遍代码，打包成一个插件就可以在配置后连接各种类型服务器的服务，因为虚幻引擎的在线子系统处理了其中的细节。5. Online Sessions5.1 online subsystem在线子系统    在线子系统提供了一种访问在线平台服务功能的方式。在线平台，是指像Steam和Xbox Lives等这样的东西。这些平台中的每一个都有自己的一套服务支持，如朋友、成就。设置匹配会话，等等。在线子系统包含一组接口，旨在处理每个平台的这些不同服务。因此无论我们选择哪种服务，都可以用在线子系统来处理我们对这些接口的使用。我们所要做的就是为一个特定的平台配置我们的项目。5.2 session interface会话接口    会话接口处理创建、管理和销毁游戏会话。它还处理搜索会话和其他匹配功能。一个会话可以被认为是游戏的一个实例，在服务器上运行，有一系列的属性，并且一个会话可以被公布，以便其他玩家可以找到这个会话并加入进来或者是私人的，所以只有被邀请的人才能加入游戏。    一个典型的游戏会话的基本寿命是这样的。 首先，你用一组所需的设置来创建会话。 然后你等待其他玩家的加入，并在他们进来的时候注册每个人。 一旦有足够的玩家加入，你就开始会话。 然后每个玩家都在同一个会话中玩游戏。 一旦比赛结束，你就可以结束会话并取消玩家的注册。 然后你可以更新会话，改变比赛的设置。    会话接口函数：CreateSession(), FindSession(), JoinSession(), StartSession(), DestroySession()5.3 game plan    我们的目标是能够在我们游戏的菜单上点击一个按钮。现在，我们先假设我们有两个菜单按钮，Host和Join。    当点击host时，我们的代码将配置会话设置，然后调用会话接口函数创建会话。一旦完成这些，我们就可以打开大厅关卡，等待其他玩家加入。    然后当别人开始游戏并点击加入，我们将配置一些搜索设置。组属性将有助于过滤掉我们没有兴趣加入的任何游戏会话。然后我们将调用接口函数查找会话。这将返回一些搜索结果，我们将遍历这些结果并挑选一个有效的会话。一旦我们完成了这一工作，我们就能得到适当的P地址，我们可以用ClientTravel()函数来使用。好了，然后用这个函数去旅行到其他玩家那里，收听服务器，并与他们一起加入大厅关卡。    现在要把所有这些功能放到它自己的整洁的小类中，用来处理这些会话相关的功能。但我们还不想因为创建所有这些新的类而被淹没。现在，我们将简单地从角色类中访问在线子系统。并在那里调用这些函数，只是为了看看一切是如何运作的。一旦找们对如何便用在线子系统以及它的会话接口功能有了了解。然后创建我们自己的类来处理这些事情，我们将把它设计成可以用于任何我们希望使用它的游戏中。6. Configure For Steam6.1 creating a new project 创建Third Person项目（C++，starter content），MenuSystem 配置steam edit -&gt; plugins, 搜索online subsystem steam，勾选enable，然后restart 实际启用steam模块，进入vs，Source -&gt; MenuSystem -&gt; MenuSystem.Build.cs，在PublicDependencyModuleNames中添加OnlineSubsystemSteam和OnlineSubsystem PublicDependencyModuleNames.AddRange(new string[] { \"Core\", \"CoreUObject\", \"Engine\", \"InputCore\", \"HeadMountedDisplay\", \"OnlineSubsystemSteam\", \"OnlineSubsystem\" }); 6.2 configure the project for steam 打开项目文件夹-&gt;config-&gt;defalutEngine.ini，添加内容 去文档中找到 Online Subsystem Steam，里面有需要粘贴的内容 [/Script/Engine.GameEngine]+NetDriverDefinitions=(DefName=\"GameNetDriver\",DriverClassName=\"OnlineSubsystemSteam.SteamNetDriver\",DriverClassNameFallback=\"OnlineSubsystemUtils.IpNetDriver\") [OnlineSubsystem]DefaultPlatformService=Steam [OnlineSubsystemSteam]bEnabled=trueSteamDevAppId=480 ; If using Sessions; bInitServerOnClient=true [/Script/OnlineSubsystemSteam.SteamNetDriver]NetConnectionClassName=\"OnlineSubsystemSteam.SteamNetConnection\" 关闭vs和项目，到项目文件夹，删除Saved、Intermediate和Binaries文件夹 右键MenuSystem.uproject，generate visual studio project files 双击MenuSystem.uproject，会提示丢失文件，点击yes就会重新生成 接下来回到项目即可 7. Accessing the Online Subsystem 进入MenuSystemCharacter.h，在末尾添加关于会话的public部分 public: // 在线对话接口的指针 // IOnlineSessionPtr OnlineSessionInterface; // IOnlineSessionPtr是TSharedPtr&lt;class IOnlineSession, ESPMode::ThreadSafe&gt;的别名 TSharedPtr&lt;class IOnlineSession, ESPMode::ThreadSafe&gt; OnlineSessionInterface; 进入MenuSystemCharacter.cpp，到构造函数的底部，添加代码访问在线子系统 IOnlineSubsystem* OnlineSubsystem = IOnlineSubsystem::Get(); if (OnlineSubsystem) { //获取在线会话的接口 OnlineSessionInterface = OnlineSubsystem-&gt;GetSessionInterface(); //检测是否找到在线子系统 if (GEngine) { GEngine-&gt;AddOnScreenDebugMessage( -1,//不会清除掉之前打印的内容 15.f,//持续15s FColor::Blue, FString::Printf(TEXT(\"Found subsystem %s\"), *OnlineSubsystem-&gt;GetSubsystemName().ToString())//GetSubsystemName()得到FName，ToString得到FString，再加个*得到c风格字符串 ); } } 前往文档中的IOnlineSubsystem，去找到需要添加的头文件，并加在cpp文件中#include \"OnlineSubsystem.h\" 到文档中搜索 IOnlineSession，将需要的头文件添加在cpp文件中#include \"Interfaces/OnlineSessionInterface.h\" 如果收到报错Unable to delete hot-reload file（但我直接编译成功了，没报错），需要关闭vs和引擎， 删除Saved、Intermediate和Binaries文件夹 右键MenuSystem.uproject，generate visual studio project files 双击MenuSystem.uproject，会提示丢失文件，点击yes就会重新生成 登录steam 在编辑器运行会连接不上，打包后运行就可以连接上 8. Creating a Session8.1 Delegate and callback 在MenuSystemCharacter.h中添加函数（protected） protected: UFUNCTION(BlueprintCallable) void CreateGameSession(); 在MenuSystemCharacter.h中创建一个委托变量(private) private: FOnCreateSessionCompleteDelegate CreateSessionCompleteDelegate; 此时会报错：“CreateSessionCompleteDelegate”: 未知重写说明符 MenuSystem 因为FOnCreateSessionCompleteDelegate是一个typedef的名字，这时可以像之前IOnlineSessionPtr一样写它的原本名字，也可以直接把cpp文件中的#include \"Interfaces/OnlineSessionInterface.h\"剪切到头文件去。要注意：这个头文件要放在#include \"MenuSystemCharacter.generated.h\"的上方，这时也可以把TSharedPtr&lt;class IOnlineSession, ESPMode::ThreadSafe&gt;换回IOnlineSessionPtr了 在MenuSystemCharacter.h的protected下创建回调函数来和刚才创建的委托变量绑定 void OnCreateSessionComplete(FName SessionName, bool bWasSuccessful); 薛定谔的编译，刚才编译报错，只是往#include \"Interfaces/OnlineSessionInterface.h\"头文件下加了一个回车，就编译成功了。 8.2 Bind the callback 在构造函数处为委托变量初始化AMenuSystemCharacter::AMenuSystemCharacter(): CreateSessionCompleteDelegate(FOnCreateSessionCompleteDelegate::CreateUObject(this, &amp;ThisClass::OnCreateSessionComplete))    其中，ThisClass就是这个类名的typedef8.3 Create a game session 去cpp文件中构建CreateGameSession函数 void AMenuSystemCharacter::CreateGameSession(){ //当按1时执行回调 if (!OnlineSessionInterface.IsValid()) { return; } //检测当前是否有对话 auto ExitingSession = OnlineSessionInterface-&gt;GetNamedSession(NAME_GameSession); //如果已经有会话 if (ExitingSession != nullptr) { OnlineSessionInterface-&gt;DestroySession(NAME_GameSession); } //将委托加入委托列表 OnlineSessionInterface-&gt;AddOnCreateSessionCompleteDelegate_Handle(CreateSessionCompleteDelegate); //使用MakeShareable将指针创建为Tshared类型的指针 TSharedPtr&lt;FOnlineSessionSettings&gt; SessionSettings = MakeShareable(new FOnlineSessionSettings()); //设置会话设置 SessionSettings-&gt;bIsLANMatch = false;//不是lan连接 SessionSettings-&gt;NumPublicConnections = 4;//可以连接的最大人数 SessionSettings-&gt;bAllowJoinInProgress = true;//允许中途加入 SessionSettings-&gt;bAllowJoinViaPresence = true;//允许不同地区的人加入 SessionSettings-&gt;bShouldAdvertise = true;//steam会显示房间供玩家加入 SessionSettings-&gt;bUsesPresence = true;//显示地区 //获取角色控制器的指针 const ULocalPlayer* LocalPlayer = GetWorld()-&gt;GetFirstLocalPlayerFromController(); OnlineSessionInterface-&gt;CreateSession(*LocalPlayer-&gt;GetPreferredUniqueNetId(), NAME_GameSession, *SessionSettings); } 去文档查找FOnlineSessionSettings函数的头文件，并加入cpp文件中。 8.4 Print the session name 去构建回调函数OnCreateSessionComplete() void AMenuSystemCharacter::OnCreateSessionComplete(FName SessionName, bool bWasSuccessful){ if (bWasSuccessful)//如果成功创建会话 { if (GEngine) { GEngine-&gt;AddOnScreenDebugMessage( -1,//不清除之前的debug 15.f, FColor::Blue, FString::Printf(TEXT(\"Created ssesion : %s\"), *SessionName.ToString()) ); } } else//如果没有成功创建会话 { if (GEngine) { GEngine-&gt;AddOnScreenDebugMessage( -1,//不清除之前的debug 15.f, FColor::Red, FString::Printf(TEXT(\"Failed to create session!\")) ); } }} 前往角色蓝图，按1键执行create game session节点 falied create原因：UE5.0.2有些许不同，需要把配置文件中的部分改一下： [OnlineSubsystemSteam] bEnabled=true SteamDevAppId=480 ; If using Sessions ; bInitServerOnClient=true 改为： [OnlineSubsystemSteam]bEnabled=trueSteamDevAppId=480bInitServerOnClient=true 9. Setup for Joining Game Sessions9.1 JoinGameSession() 在MenuSystem.h文件中protected下创建一个蓝图节点函数 UFUNCTION(BlueprintCallable) void JoinGameSession(); 去cpp文件中实现函数（会在之后实现） 9.2 Delegate and callback 接下来会像创建会话时一样创建委托和回调，在MenuSystem.h文件中的private下创建join会话的委托变量。 FOnFindSessionsCompleteDelegate FindSessionsCompleteDelagate; 在protected下创建回调函数 void OnFindSessionsComplete(bool bWasSuccessful); 去cpp文件实现回调 9.3 Binding the callback 在cpp的构造函数处为委托绑定回调 FindSessionsCompleteDelegate(FOnFindSessionsCompleteDelegate::CreateUObject(this, &amp;ThisClass::OnFindSessionsComplete)) 9.4 Session search settings 实现JoinGameSession函数，（其中SessionSearch在头文件中的private下创建变量TSharedPtr&lt;FOnlineSessionSearch&gt; SessionSearch,因为要在回调函数中使用这个变量来获取会话结果数组） void AMenuSystemCharacter::JoinGameSession(){ //寻找会话 //先判断在线会话接口的有效性 if (!OnlineSessionInterface.IsValid()) { return; } //将委托变量加入委托列表 OnlineSessionInterface-&gt;AddOnFindSessionsCompleteDelegate_Handle(FindSessionsCompleteDelegate); //创建会话设置的智能指针,将类的指针makesharable SessionSearch = MakeShareable(new FOnlineSessionSearch()); SessionSearch-&gt;MaxSearchResults = 1000;//最大搜索个数 SessionSearch-&gt;bIsLanQuery = false;//禁止局域网的搜索 //获取角色控制器 const ULocalPlayer* LocalPlayer = GetWorld()-&gt;GetFirstLocalPlayerFromController(); //执行在线会话接口的寻找会话的函数 OnlineSessionInterface-&gt;FindSessions(*LocalPlayer-&gt;GetPreferredUniqueNetId(), SessionSearch.ToSharedRef());//将ptr转为ref } 实现回调函数 void AMenuSystemCharacter::OnFindSessionsComplete(bool bWasSuccessful){ //遍历寻找到的会话数组 for (auto Result : SessionSearch-&gt;SearchResults) { FString Id = Result.GetSessionIdStr();//会话Id FString User = Result.Session.OwningUserName;//会话创建者的名字 //打印出来 if (GEngine) { GEngine-&gt;AddOnScreenDebugMessage( -1, 15.f, FColor::Cyan, FString::Printf(TEXT(\"Id : %s, User : %s\"), *Id, *User) ); } } } 到JoinGameSession函数中，在找之前添加一个SessionSearch的设置 //确保搜索的 会话询问 设置为 现在存在 SessionSearch-&gt;QuerySettings.Set(SEARCH_PRESENCE, true, EOnlineComparisonOp::Equals); 去蓝图中添加节点，按2时执行JoinGameSession 由于5.0.2版本问题导致出错，需要在CreateSession函数中添加一条SessionSettings：SessionSettings-&gt;bUseLobbiesIfAvailable = true;而且要regenerate（可能就是没有重新生成，所以失败了） 打包，用两台机器测试 在joingamesession的函数里，MakeShareable(new FOnlineSessionSearch());这处代码的new FOnlineSessionSearch的后面一开始没有加()，也没报错，不知道是不是这里的原因导致找不到会话 10. Steam Regions    之前一直搜索不到人，一直以为是代码哪里出问题了，原来不是代码出问题了，是steam区域的问题，这个搜索只能搜索到同一区域的人，要到steamm的设置中去更改11. Joining the Session11.1 Create a lobby level 在Maps文件夹中file-&gt;new level，将地板scale放大点，保存为Lobby 在OnCreateSessionComplete函数中添加跳转代码： if (bWasSuccessful)//如果成功创建会话 { if (GEngine) { GEngine-&gt;AddOnScreenDebugMessage( -1,//不清除之前的debug 15.f, FColor::Blue, FString::Printf(TEXT(\"Created ssesion : %s\"), *SessionName.ToString()) ); } UWorld* World = GetWorld(); if (World) { //E:/Ue5/MenuSystem/Content/ThirdPerson/Maps/Lobby.umap World-&gt;ServerTravel(FString(\"/Game/ThirdPerson/Maps/Lobby?listen\"));//作为监听服务器 } } 11.2 Specify a “match type”    在CreateGameSession()函数中添加一条设置//设置游戏模式 SessionSettings-&gt;Set(FName(\"MatchType\"), FString(\"FreeForAll\"), EOnlineDataAdvertisementType::ViaOnlineServiceAndPing);11.3 Check the match type    在OnFindSessionsComplete函数的遍历中，获取matchtype，并检查for (auto Result : SessionSearch-&gt;SearchResults) { FString Id = Result.GetSessionIdStr();//会话Id FString User = Result.Session.OwningUserName;//会话创建者的名字 FString MatchType;//比赛类型 Result.Session.SessionSettings.Get(FName(\"MatchType\"), MatchType); //打印出来 if (GEngine) { GEngine-&gt;AddOnScreenDebugMessage( -1, 15.f, FColor::Cyan, FString::Printf(TEXT(\"Id : %s, User : %s\"), *Id, *User) ); } if (MatchType == FString(\"FreeForAll\")) { if (GEngine) { GEngine-&gt;AddOnScreenDebugMessage( -1, 15.f, FColor::Cyan, FString::Printf(TEXT(\"Joing Match Type : %s\"), *MatchType) ); } } }11.4 get the ip address 在头文件的private下，创建加入会话完成的委托FOnJoinSessionCompleteDelegate JoinSessionCompleteDelegate;//加入会话完成的委托 在头文件的protected下，加入会话完成创建回调函数void OnJoinSessionComplete(FName SessionName, EOnJoinSessionCompleteResult::Type Result);//加入会话完成的回调函数 绑定委托JoinSessionCompleteDelegate(FOnJoinSessionCompleteDelegate::CreateUObject(this, &amp;ThisClass::OnJoinSessionComplete)) 修改OnFindSessionsComplete函数，现在开头加上 if (!OnlineSessionInterface.IsValid()) { return; } 在模式对的情况下，为接口加入委托，并执行join //加到委托列表中去OnlineSessionInterface-&gt;AddOnJoinSessionCompleteDelegate_Handle(JoinSessionCompleteDelegate);//获取角色控制器const ULocalPlayer* LocalPlayer = GetWorld()-&gt;GetFirstLocalPlayerFromController();//加入会话OnlineSessionInterface-&gt;JoinSession(*LocalPlayer-&gt;GetPreferredUniqueNetId(), NAME_GameSession, Result); 5. 实现join的回调函数```cppvoid AMenuSystemCharacter::OnJoinSessionComplete(FName SessionName, EOnJoinSessionCompleteResult::Type Result){ if (!OnlineSessionInterface.IsValid()) { return; } FString Address; if (OnlineSessionInterface-&gt;GetResolvedConnectString(NAME_GameSession, Address)) { if (GEngine) { GEngine-&gt;AddOnScreenDebugMessage( -1, 15.f, FColor::Yellow, FString::Printf(TEXT(\"Connect String : %s\"), *Address) ); } }}11.5 join the session    在join的回调函数中添加跳转场景void AMenuSystemCharacter::OnJoinSessionComplete(FName SessionName, EOnJoinSessionCompleteResult::Type Result){ if (!OnlineSessionInterface.IsValid()) { return; } FString Address; if (OnlineSessionInterface-&gt;GetResolvedConnectString(NAME_GameSession, Address)) { if (GEngine) { GEngine-&gt;AddOnScreenDebugMessage( -1, 15.f, FColor::Yellow, FString::Printf(TEXT(\"Connect String : %s\"), *Address) ); } //获得角色控制器指针 APlayerController* PlayerController = GetGameInstance()-&gt;GetFirstLocalPlayerController(); //跳转场景 if (PlayerController) { PlayerController-&gt;ClientTravel(Address, ETravelType::TRAVEL_Absolute); } }}12. Creating a Plugin plugins插件和modules模块 我们的项目文件uproject其实就是一个module 依赖关系，下层只能依赖同层和上层，比game module能依赖engine module，因为先有engine module才有game module 12.1 Create our plugin Edit-&gt;Plugins，点击add，选择blank命名MultiplayerSessions，填写descriptor data:A plugin for handling online mutiplayer sessions，最后创建插件 如果不显示插件，可以点content drawer的settings勾选显示插件 编译文件 12.2 Add dependency 找到刚创建的MultiplayerSessions.uplugin文件，添加依赖： \"Plugins\": [ { \"Name\": \"OnlineSubsystem\", \"Enabled\": true }, { \"Name\": \"OnlineSubsystemSteam\", \"Enabled\": true } ] 打开MultiplayerSession.Build.cs，添加public依赖模块： PublicDependencyModuleNames.AddRange( new string[] { \"Core\", \"OnlineSubsystem\", \"OnlineSubsystemSteam\" // ... add other public dependencies that you statically link with here ... } ); 编译文件 13. Creating our Own Subsystem 父类的选择：Game instance 13.1 Create our own subsystem 创建一个新的c++类，选择ugameinstancesubsystem，选择multiplayerSessions 模块，命名MultiplayerSessionsSubsystem 如果有红色波浪线报错的话，就重新generate一下uproject，要记得将plugins中MultiPlayerSessions文件夹中的二进制文件夹和intermediate文件夹删掉 在MultiplayerSubsystem.h中添加一些头文件和构造函数声明、变量声明 #pragma once #include \"CoreMinimal.h\"#include \"Subsystems/GameInstanceSubsystem.h\"#include \"Interfaces/OnlineSessionInterface.h\" #include \"MultiplayerSubsystem.generated.h\" /*** */UCLASS()class MULTIPLAYERSESSIONS_API UMultiplayerSubsystem : public UGameInstanceSubsystem{ GENERATED_BODY()public: UMutiplayerSubsystem(); protected: private: IOnlineSessionPtr SessionInterface;}; 在MultiplayerSubsystem.cpp中实现构造函数 #include \"MultiplayerSubsystem.h\"#include \"OnlineSubsystem.h\"UMultiplayerSubsystem::UMultiplayerSubsystem(){ IOnlineSubsystem* Subsystem = IOnlineSubsystem::Get(); if (Subsystem) { SessionInterface = Subsystem-&gt;GetSessionInterface(); }} 14. Session Interface Delegates 需要实现的方法： delegate handle：当委托完成后，clear掉 14.1 Functions 在头文件声明函数 public: UMultiplayerSubsystem(); // //处理会话功能，菜单类将会调用 // void CreateSession(int32 NumPublicConnections, FString MatchType); void FindSessions(int32 MaxSearchResults); void JoinSession(const FOnlineSessionSearchResult&amp; SessionResult); void DestroySession(); void StartSession(); 14.2 Delegates 在头文件添加委托变量 private: IOnlineSessionPtr SessionInterface; // //要添加在线会话接口的委托列表中的委托 //将绑定MultiplayerSubsystem内部回调函数到这些委托 // FOnCreateSessionCompleteDelegate CreateSessionCompleteDelegate; FOnFindSessionsCompleteDelegate FindSessionsCompleteDelegate; FOnJoinSessionCompleteDelegate JoinSessionCompleteDelegate; FOnDestroySessionCompleteDelegate DestroySessionCompleteDelegate; FOnStartSessionCompleteDelegate StartSessionCompleteDelegate; 14.3 Callbacks 在头文件中声明回调函数（protected） protected: // //将要添加在 在线会话接口委托列表中委托的 内部回调函数 //因为不需要在这个类外调用，所以写在protected里 void OnCreateSessionComplete(FName SessionName, bool bWasSuccessful); void OnFindSessionsComplete(bool bWasSuccessful); void OnJoinSessionComplete(FName SessionName, EOnJoinSessionCompleteResult::Type Result); void OnDestroySessionComplete(FName SessionName, bool bWasSuccessful); void OnStartSessionComplete(FName SessionName, bool bWasSuccessful);ssful); 14.4 Bind the callbacks 在cpp文件的构造函数下初始化，绑定委托和回调函数 UMultiplayerSubsystem::UMultiplayerSubsystem():CreateSessionCompleteDelegate(FOnCreateSessionCompleteDelegate::CreateUObject(this, &amp;ThisClass::OnCreateSessionComplete)),FindSessionsCompleteDelegate(FOnFindSessionsCompleteDelegate::CreateUObject(this, &amp;ThisClass::OnFindSessionsComplete)),JoinSessionCompleteDelegate(FOnJoinSessionCompleteDelegate::CreateUObject(this, &amp;ThisClass::OnJoinSessionComplete)),DestroySessionCompleteDelegate(FOnDestroySessionCompleteDelegate::CreateUObject(this, &amp;ThisClass::OnDestroySessionComplete)),StartSessionCompleteDelegate(FOnStartSessionCompleteDelegate::CreateUObject(this, &amp;ThisClass::OnStartSessionComplete)) 14.5 Dekegate handles 在头文件中为每一个委托创建delegate handle FOnCreateSessionCompleteDelegate CreateSessionCompleteDelegate; FDelegateHandle CreateSessionCompleteDelegateHandle; FOnFindSessionsCompleteDelegate FindSessionsCompleteDelegate; FDelegateHandle FindSessionsCompleteDelegateHandle; FOnJoinSessionCompleteDelegate JoinSessionCompleteDelegate; FDelegateHandle JoinSessionCompleteDelegateHandle; FOnDestroySessionCompleteDelegate DestroySessionCompleteDelegate; FDelegateHandle DestroySessionCompleteDelegateHandle; FOnStartSessionCompleteDelegate StartSessionCompleteDelegate; FDelegateHandle StartSessionCompleteDelegateHandle; 编译文件 15. The Menu Class15.1 Create a menu class 在MultiplayerSessionsC++Class-&gt;MultiplySessions-&gt;Public文件夹中创建新的c++类，搜索uuserwidget，选择UserWidget，下一步选择MultiplayerSessions，命名Menu 此时重新加载后，编译无法通过，尝试重新generate(千万不要！！！会打不开项目) 打开MultiplayerSessions.Build.cs文件，在PublicDependencyModuleNames.AddRange中添加引用依赖，解决了报错，再编译一下，就能打开项目了 PublicDependencyModuleNames.AddRange( new string[] { \"Core\", \"OnlineSubsystem\", \"OnlineSubsystemSteam\", \"UMG\", \"Slate\", \"SlateCore\" // ... add other public dependencies that you statically link with here ... } ); 在Menu .h添加函数声明 public: UFUNCTION(BlueprintCallable) void MenuSetup(); 在cpp中实现 void UMenu::MenuSetup(){ AddToViewport();//添加到窗口 SetVisibility(ESlateVisibility::Visible);//设置为可见 bIsFocusable = true; UWorld* World = GetWorld(); if (World) { APlayerController* PlayerController = World-&gt;GetFirstPlayerController(); if (PlayerController) { //设置input的模式为UI模式，并设置其中的属性 FInputModeUIOnly InputModeData; InputModeData.SetWidgetToFocus(TakeWidget());//聚焦这个界面 InputModeData.SetLockMouseToViewportBehavior(EMouseLockMode::DoNotLock);//设置鼠标不锁定模式 PlayerController-&gt;SetInputMode(InputModeData);//设置输入模式 PlayerController-&gt;SetShowMouseCursor(true);//鼠标光标可见 } }} 15.2 Create a menu widget 在MultiplayerSessions Content文件夹中创建user interface-&gt;widget，命名UBP_Menu 进入UBP_Menu的设计模式，创建两个按钮，一个HostButton，一个JoinButton，将锚点设置成底部中心，调整按钮位置和大小 进入蓝图模式，点击class settings，将parent class设置为Menu 进入level blueprint，创建beginPlay节点，指向create widget节点，选择UBP_Menu，指向MenuSetup节点，return value连接target（如果没有menu set节点的话就尝试重启项目） 16. Accessing our Subsystem16.1 Button callbacks 到Menu.h文件中为按钮创建变量 private: UPROPERTY(meta = (BindWidget))//要和界面的按钮控件绑定，就要加这个，而且变量名要和界面中创建的一致 class UButton* HostButton; UPROPERTY(meta = (BindWidget)) UButton* JoinButton; UFUNCTION()//因为要使用引擎的click事件或者委托，所以加上这个 void HostButtonClicked(); UFUNCTION() void JoinButtonClicked(); 实现按钮事件（其实就是debug一下先） void UMenu::HostButtonClicked(){ if (GEngine) { GEngine-&gt;AddOnScreenDebugMessage( -1, 15.f, FColor::Yellow, FString(TEXT(\"Host Button clicked\")) ); }} void UMenu::JoinButtonClicked(){ if (GEngine) { GEngine-&gt;AddOnScreenDebugMessage( -1, 15.f, FColor::Yellow, FString(TEXT(\"Join Button clicked\")) ); }} 接下来将事件绑定到按钮上，要先在头文件重写一下初始化函数 protected: virtual bool Initialize() override; 在cpp文件中添加头文件#include \"Components/Button.h\" 实现initialize函数 bool UMenu::Initialize(){ if (!Super::Initialize()) { return false; } if (HostButton) { HostButton-&gt;OnClicked.AddDynamic(this, &amp;ThisClass::HostButtonClicked); } if (JoinButton) { JoinButton-&gt;OnClicked.AddDynamic(this, &amp;ThisClass::JoinButtonClicked); } return true;} 编译并测试(如果没反应，可以尝试下重启项目，再不行就重新generate一下) 16.2 Access our subsystem 在menu.h的private中声明变量，我的类名叫UMultiplayerSubsyste，是因为创建类的时候少打了session，删除类也有点麻烦，所以也就没改名了 //管理所有在线会话的功能 class UMultiplayerSubsystem* MultiplayerSessionsSubsystem; 在cpp文件中，丰富menusetup函数，并添加MutiplayerSubsystem的头文件 UGameInstance* GameInstance = GetGameInstance(); if (GameInstance) { //为之前创建的变量赋值 MultiplayerSessionsSubsystem = GameInstance-&gt;GetSubsystem&lt;UMultiplayerSubsystem&gt;(); } 修改button的响应函数(具体实现在下一节) void UMenu::HostButtonClicked(){ if (GEngine) { GEngine-&gt;AddOnScreenDebugMessage( -1, 15.f, FColor::Yellow, FString(TEXT(\"Host Button clicked\")) ); } if (MultiplayerSessionsSubsystem) { MultiplayerSessionsSubsystem-&gt;CreateSession(4, FString(\"FreeForAll\")); }} 17. Create Session17.1 Implement CreateSession() 实现MultiplayerSubsystem.cpp的CreateSession函数 void UMultiplayerSubsystem::CreateSession(int32 NumPublicConnections, FString MatchType){ if (!SessionInterface.IsValid()) { return; } //判断是否存在NAME_GameSession的会话 auto ExistingSession = SessionInterface-&gt;GetNamedSession(NAME_GameSession); if (ExistingSession != nullptr) { SessionInterface-&gt;DestroySession(NAME_GameSession); } //将委托加入委托列表，并保存至handle中以便之后消除 CreateSessionCompleteDelegateHandle = SessionInterface-&gt;AddOnCreateSessionCompleteDelegate_Handle(CreateSessionCompleteDelegate); LastSessionSettings = MakeShareable(new FOnlineSessionSettings()); //如果没连接steam那就是局域网连接，否则不是 LastSessionSettings-&gt;bIsLANMatch = IOnlineSubsystem::Get()-&gt;GetSubsystemName() == \"NULL\" ? true : false; LastSessionSettings-&gt;NumPublicConnections = NumPublicConnections; LastSessionSettings-&gt;bAllowJoinInProgress = true; LastSessionSettings-&gt;bAllowJoinViaPresence = true; LastSessionSettings-&gt;bShouldAdvertise = true; LastSessionSettings-&gt;bUsesPresence = true; LastSessionSettings-&gt;Set(FName(\"MatchType\"), MatchType, EOnlineDataAdvertisementType::ViaOnlineServiceAndPing);//这个应该是指显示出在线服务和ping值 const ULocalPlayer* LocalPlayer = GetWorld()-&gt;GetFirstLocalPlayerFromController(); //如果创建会话失败，那么就消除委托列表中的创建委托 if (!SessionInterface-&gt;CreateSession(*LocalPlayer-&gt;GetPreferredUniqueNetId(), NAME_GameSession, *LastSessionSettings)) { SessionInterface-&gt;ClearOnCreateSessionCompleteDelegate_Handle(CreateSessionCompleteDelegateHandle); } } 在头文件创建私有变量：TSharedPtr&lt;FOnlineSessionSettings&gt; LastSessionSettings; 在cpp文件包含头文件：#include \"OnlineSessionSettings.h\" 17.2 Travel to the lobby 在menu.cpp文件中丰富HostButtonClicked() if (MultiplayerSessionsSubsystem) { MultiplayerSessionsSubsystem-&gt;CreateSession(4, FString(\"FreeForAll\")); UWorld* World = GetWorld(); if (World) { World-&gt;ServerTravel(\"/Game/ThirdPerson/Maps/Lobby?listen\"); } } 编译并测试，不需要打包的测试方法：右键uproject-&gt;lauch game 测试失败，没有跳转场景，查了下，发现是ServerTravel里路径参数写错了，还得是去copy path最保险 在menu.h中声明一个私有函数MenuTearDown，用来解除inputmodeUI void UMenu::MenuTearDown(){ RemoveFromParent(); UWorld* World = GetWorld(); if (World) { APlayerController* PlayerController = World-&gt;GetFirstPlayerController(); if (PlayerController) { FInputModeGameOnly InputModeData; PlayerController-&gt;SetInputMode(InputModeData); PlayerController-&gt;SetShowMouseCursor(false); } }} 重写Menu类的虚函数OnLevelRemovedFromWorld() (protected) void UMenu::OnLevelRemovedFromWorld(ULevel* InLevel, UWorld* InWorld){ MenuTearDown(); //调用父级的函数 Super::OnLevelRemovedFromWorld(InLevel, InWorld);} 17.3 Add Input to MenuSetup 在头文件中添加私有变量并初始化 int32 NumPublicConnection{ 4 };FString MatchType{ TEXT(\"FreeForAll\") }; 修改menuSetup函数（参数也要修改,头文件中要设置默认值），主要就是给变量赋初值 void MenuSetup(int32 NumberOfPublicConnections = 4 , FString TypeOfMatch = FString(TEXT(\"FreeForAll\"))); void UMenu::MenuSetup(int32 NumberOfPublicConnections , FString TypeOfMatch ){ NumPublicConnection = NumberOfPublicConnections; MatchType = TypeOfMatch; 修改HostButtonClicked()函数中，createSession的参数，改成变量 MultiplayerSessionsSubsystem-&gt;CreateSession(NumPublicConnection, MatchType); 此时打开level bliprint可能会看到menu setup节点没有添加变量，重启下项目即可 18. Callbacks to our Subsystem Functions    使用自定义的委托，在执行完会话创建的委托回调函数后，创建自定义委托来执行menu类的回调函数，以此来使multiplayer session subsystem可以与menu类实现互通18.1 Declare new delegate 在MultiplayerSubsystem.h中声明自定义委托（动态多播委托：多个类的回调函数都可以绑定这个委托，DYNAMIC意味着被序列化，而且可以在蓝图中加载和保存），并创建public变量，声明在类外(可能会报错有红色波浪线，没关系，做完这一节，最后重启项目和vs再编译一遍即可) DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FMultiplayerOnCreateSessionComplete, bool, bWasSuccessful); // //自定义委托变量（用于和menu类的回调函数绑定） // FMultiplayerOnCreateSessionComplete MultiplayerOnCreateSessionComplete; 18.2 Create callbacks on the menu 在menu.h中声明回调函数（protected） // //回调函数（用于MultiplayerSystem的自定义委托） // void OnCreateSession(bool bWasSuccessful); 18.3 Bind the callbacks 在MenuSetup函数的底部添加代码 if (MultiplayerSessionsSubsystem) { MultiplayerSessionsSubsystem-&gt;MultiplayerOnCreateSessionComplete.AddDynamic(this, &amp;ThisClass::OnCreateSession); } 在MultiplayerSubsystem.cpp中的createsession函数中，如果创建函数失败了，那么就广播这个自定义委托（false） if (MultiplayerSessionsSubsystem) { MultiplayerSessionsSubsystem-&gt;MultiplayerOnCreateSessionComplete.AddDynamic(this, &amp;ThisClass::OnCreateSession); } 在执行CreateSessionCompleteDelegate委托的回调函数时，自定义委托广播true void UMultiplayerSubsystem::OnCreateSessionComplete(FName SessionName, bool bWasSuccessful){ if (SessionInterface) { SessionInterface-&gt;ClearOnCreateSessionCompleteDelegate_Handle(CreateSessionCompleteDelegateHandle); } MultiplayerOnCreateSessionComplete.Broadcast(bWasSuccessful);} 去实现自定义委托的回调函数 void UMenu::OnCreateSession(bool bWasSuccessful){ if (bWasSuccessful) { if (GEngine) { GEngine-&gt;AddOnScreenDebugMessage( -1, 15.f, FColor::Yellow, FString(TEXT(\"Session created successfully!\")) ); } }} 此时运行可能没反应，是因为要将menu中的那个回调函数设置成UFUNCTION,才能绑定成功（因为用的时dynamic委托）: // //回调函数（用于MultiplayerSystem的自定义委托） // UFUNCTION() void OnCreateSession(bool bWasSuccessful); 将之前的跳转代码从按钮事件剪切到自定义委托的回调函数内 void UMenu::OnCreateSession(bool bWasSuccessful){ if (bWasSuccessful) { if (GEngine) { GEngine-&gt;AddOnScreenDebugMessage( -1, 15.f, FColor::Yellow, FString(TEXT(\"Session created successfully!\")) ); } //成功创建后跳转场景 UWorld* World = GetWorld(); if (World) { //E:/Ue5/MenuSystem/Content/ThirdPerson/Maps/Lobby.umap World-&gt;ServerTravel(\"/Game/ThirdPerson/Maps/Lobby?listen\"); } } else { if (GEngine) { GEngine-&gt;AddOnScreenDebugMessage( -1, 15.f, FColor::Red, FString(TEXT(\"Failed to create a session!\")) ); } }} 编译测试 19. More Subsystem Delegates19.1 More delegates MultiplayerSubsystem.h文件中声明委托，其中有dynamic的意味着可以使用蓝图节点，没有的就不能使用（更深层次的原理不太清除） DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FMultiplayerOnCreateSessionComplete, bool, bWasSuccessful);DECLARE_MULTICAST_DELEGATE_TwoParam(FMultiplayerOnFindSessionsComplete, const TArray&lt;FOnlineSessionSearchResult&gt;&amp; SessionResult, bool bWasSuccessful);DECLARE_MULTICAST_DELEGATE_OneParam(FMultiplayerOnJoinSessionComplete, EOnJoinSessionCompleteResult::Type Result);DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FMultiplayerOnDestroySessionComplete, bool, bWasSuccessful);DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FMultiplayerOnStartSessionComplete, bool, bWasSuccessful); 创建委托变量 // //自定义委托变量（用于和menu类的回调函数绑定） // FMultiplayerOnCreateSessionComplete MultiplayerOnCreateSessionComplete; FMultiplayerOnFindSessionsComplete MultiplayerOnFindSessionsComplete; FMultiplayerOnJoinSessionComplete MultiplayerOnJoinSessionComplete; FMultiplayerOnDestroySessionComplete MultiplayerOnDestroySessionComplete; FMultiplayerOnStartSessionComplete MultiplayerOnStartSessionComplete; 19.2 Menu callbacks 在menu.h声明回调函数 // //回调函数（用于MultiplayerSystem的自定义委托） // UFUNCTION() void OnCreateSession(bool bWasSuccessful); void OnFindSessions(const TArray&lt;FOnlineSessionSearchResult&gt;&amp; SessionResult, bool bWasSuccessful); void OnJoinSession(EOnJoinSessionCompleteResult::Type Result); UFUNCTION() void OnDestroySession(bool bWasSuccessful); UFUNCTION() void OnStartSession(bool bWasSuccessful); 在menu.cpp中menuSetup函数底部绑定回调 if (MultiplayerSessionsSubsystem) { MultiplayerSessionsSubsystem-&gt;MultiplayerOnCreateSessionComplete.AddDynamic(this, &amp;ThisClass::OnCreateSession); MultiplayerSessionsSubsystem-&gt;MultiplayerOnFindSessionsComplete.AddUObject(this, &amp;ThisClass::OnFindSessions); MultiplayerSessionsSubsystem-&gt;MultiplayerOnJoinSessionComplete.AddUObject(this, &amp;ThisClass::OnJoinSession); MultiplayerSessionsSubsystem-&gt;MultiplayerOnDestroySessionComplete.AddDynamic(this, &amp;ThisClass::OnDestroySession); MultiplayerSessionsSubsystem-&gt;MultiplayerOnStartSessionComplete.AddDynamic(this, &amp;ThisClass::OnStartSession); } OnJoinSession函数会报错，是因为缺少头文件，在头文件文件中添加#include \"Interfaces/OnlineSessionInterface.h\"\" 在cpp文件添加头文件#include \"OnlineSessionSettings.h\" 之后如果突然出现了一些不明不白的红色波浪线，那么重启下项目和vs即可解决 20. Join sessions from the menu20.1 Join session 修改menu.cpp的joinButtonClicked void UMenu::JoinButtonClicked(){ if(MultiplayerSessionsSubsystem) { MultiplayerSessionsSubsystem-&gt;FindSessions(10000); } } 实现multiplayerSubsystem的findsession函数，在头文件创建私有变量`` void UMultiplayerSubsystem::FindSessions(int32 MaxSearchResults){ if (!SessionInterface.IsValid()) { return; } //将委托变量加入委托列表 FindSessionsCompleteDelegateHandle = SessionInterface-&gt;AddOnFindSessionsCompleteDelegate_Handle(FindSessionsCompleteDelegate); //创建会话设置的智能指针,将类的指针makesharable LastSessionSearch = MakeShareable(new FOnlineSessionSearch()); LastSessionSearch-&gt;MaxSearchResults = MaxSearchResults;//最大搜索个数 LastSessionSearch-&gt;bIsLanQuery = IOnlineSubsystem::Get()-&gt;GetSubsystemName() == \"NULL\" ? true : false; //确保搜索的 会话询问 设置为 现在存在的 LastSessionSearch-&gt;QuerySettings.Set(SEARCH_PRESENCE, true, EOnlineComparisonOp::Equals); //获取角色控制器 const ULocalPlayer* LocalPlayer = GetWorld()-&gt;GetFirstLocalPlayerFromController(); //执行在线会话接口的寻找会话的函数 if (!SessionInterface-&gt;FindSessions(*LocalPlayer-&gt;GetPreferredUniqueNetId(), LastSessionSearch.ToSharedRef()))//将ptr转为ref { SessionInterface-&gt;ClearOnCancelFindSessionsCompleteDelegate_Handle(FindSessionsCompleteDelegateHandle); //搜索失败，那么广播时传的参数就是空的TArray MultiplayerOnFindSessionsComplete.Broadcast(TArray&lt;FOnlineSessionSearchResult&gt;(), false)'' }} 实现回调OnFindSessionsComplete(bool bWasSuccessful) void UMultiplayerSubsystem::OnFindSessionsComplete(bool bWasSuccessful){ if (SessionInterface) { SessionInterface-&gt;ClearOnCreateSessionCompleteDelegate_Handle(FindSessionsCompleteDelegateHandle); } if (LastSessionSearch-&gt;SearchResults.Num() &lt;= 0)//没有找到会话，也广播false给menu { MultiplayerOnFindSessionsComplete.Broadcast(TArray&lt;FOnlineSessionSearchResult&gt;(), false); return; } MultiplayerOnFindSessionsComplete.Broadcast(LastSessionSearch-&gt;SearchResults , bWasSuccessful);} 20.2 Joing a session 实现menu的回调函数OnJoinSession void UMenu::OnFindSessions(const TArray&lt;FOnlineSessionSearchResult&gt;&amp; SessionResult, bool bWasSuccessful){ //遍历搜索到的所有会话 for (auto Result : SessionResult) { FString SettingsValue; Result.Session.SessionSettings.Get(FName(\"MatchType\"), SettingsValue);//将会话中设置的比赛类型存到SettingsVale中 if (SettingsValue == MatchType)//如果搜索到的，和我menu设置的menuType一致 { MultiplayerSessionsSubsystem-&gt;JoinSession(Result); return; } }} 去实现MultiplayerSubsystem的JoinSession函数 void UMultiplayerSubsystem::JoinSession(const FOnlineSessionSearchResult&amp; SessionResult){ if (!SessionInterface.IsValid()) { MultiplayerOnCreateSessionComplete.Broadcast(EOnJoinSessionCompleteResult::UnknownError); return; } JoinSessionCompleteDelegateHandle = SessionInterface-&gt;AddOnJoinSessionCompleteDelegate_Handle(JoinSessionCompleteDelegate); //获取角色控制器 const ULocalPlayer* LocalPlayer = GetWorld()-&gt;GetFirstLocalPlayerFromController(); if (!SessionInterface-&gt;JoinSession(*LocalPlayer-&gt;GetPreferredUniqueNetId(), NAME_GameSession, SessionResult)) { SessionInterface-&gt;ClearOnJoinSessionCompleteDelegate_Handle(JoinSessionCompleteDelegateHandle); MultiplayerOnJoinSessionComplete.Broadcast(EOnJoinSessionCompleteResult::UnknownError); }} 实现回调函数 void UMultiplayerSubsystem::OnJoinSessionComplete(FName SessionName, EOnJoinSessionCompleteResult::Type Result){ if (SessionInterface) { SessionInterface-&gt;ClearOnJoinSessionCompleteDelegate_Handle(JoinSessionCompleteDelegateHandle); } MultiplayerOnJoinSessionComplete.Broadcast(Result);} 在menu.cpp实现join的回调,并添加头文件#include \"OnlineSubsystem.h\" void UMenu::OnJoinSession(EOnJoinSessionCompleteResult::Type Result){ IOnlineSubsystem* Subsystem = IOnlineSubsystem::Get(); if (Subsystem) { IOnlineSessionPtr SessionInterface = Subsystem-&gt;GetSessionInterface(); if (SessionInterface.IsValid()) { FString Address;//保存要join的地址 SessionInterface-&gt;GetResolvedConnectString(NAME_GameSession, Address); //获得角色控制器指针 APlayerController* PlayerController = GetGameInstance()-&gt;GetFirstLocalPlayerController(); //跳转场景 if (PlayerController) { PlayerController-&gt;ClientTravel(Address, ETravelType::TRAVEL_Absolute); } } }} 由于找不到Session，应该是在createSession函数里忘了加LastSessionSettings-&gt;bUseLobbiesIfAvailable = true;这个了 21. Tracking Incoming Players    游戏模式：设定规则，处理角色进入游戏、离开游戏。    游戏状态：每一个客户端都会监视游戏状态信息，游戏状态是一个类，保存着每个玩家的数据数组21.1 Create a game mode 把game mode创建在MenuSystem文件夹，而不是放在插件里，新建C++类，选择GAME MODE BASE,命名LobbyGameMode21.2 Track incoming players 在头文件的public下重写函数声明 public: virtual void PostLogin(APlayerController* NewPlayer) override; virtual void Logout(ACpntroller* Exiting) override; 实现两个函数，添加头文件#include \"GameFrameWork/GameStateBase.h\"不然会报错 void ALobbyGameMode::PostLogin(APlayerController* NewPlayer){ //执行父类的函数 Super::PostLogin(NewPlayer); if (GameState) { int32 NumberOfPlayers = GameState.Get()-&gt;PlayerArray.Num(); if (GEngine) { //打印玩家数量 GEngine-&gt;AddOnScreenDebugMessage( 1, 60.f, FColor::Yellow, FString::Printf(TEXT(\"Players in game: %d\"), NumberOfPlayers) ); //打印进入游戏的玩家名字 APlayerState* PlayerState = NewPlayer-&gt;GetPlayerState&lt;APlayerState&gt;(); if (PlayerState) { FString PlayerName = PlayerState-&gt;GetPlayerName();//保存玩家名字 GEngine-&gt;AddOnScreenDebugMessage( -1, 60.f, FColor::Cyan, FString::Printf(TEXT(\"%s has joined the game!\"), *PlayerName) ); } } }} void ALobbyGameMode::Logout(AController* Exiting){ Super::Logout(Exiting); //打印进入游戏的玩家名字 APlayerState* PlayerState = Exiting-&gt;GetPlayerState&lt;APlayerState&gt;(); if (PlayerState) { int32 NumberOfPlayers = GameState.Get()-&gt;PlayerArray.Num(); //打印玩家数量 GEngine-&gt;AddOnScreenDebugMessage( 1, 60.f, FColor::Yellow, FString::Printf(TEXT(\"Players in game: %d\"), NumberOfPlayers - 1) ); //打印退出的玩家名字 FString PlayerName = PlayerState-&gt;GetPlayerName();//保存玩家名字 GEngine-&gt;AddOnScreenDebugMessage( -1, 60.f, FColor::Cyan, FString::Printf(TEXT(\"%s has exited the game!\"), *PlayerName) ); }} 在multiplayerSubsystem类的createSession()中添加一行设置 LastSessionSettings-&gt;BuildUniqueId = 1;//如果不设置的话，就搜索不到其他人创建的房间了 设置项目最大人数，打开config文件夹中的DefaultGame.ini，添加： [/Script/Engine.GameSession]MaxPlayers=100 在ThirdPerson文件夹创建一个蓝图，搜索LobbyGameMode，命名BP_LobbyGameMode 打开蓝图，将Default Pawn Class改为BP_ThirdPersonCharacter,编译并保存 进入Lobby场景，将World Settings的GameMode Override改为BP_LobbyGameMode，Default Pawn Class改为BP_ThirdPersonCharacter，只有这样玩家在场景中移动才能传到服务器 22. Start Session23. Path to Lobby 在menu头文件创建私有变量FString PathToLpbby{ TEXT(\"\") }; 给setup函数添加一个形参void MenuSetup(int32 NumberOfPublicConnections = 4 , FString TypeOfMatch = FString(TEXT(\"FreeForAll\")), FString LobbyPath = FString(TEXT(\"/Game/ThirdPerson/Maps/Lobby\"))); 在setup函数顶部添加代码： //给PathToLobby赋值 PathToLobby = FString::Printf(TEXT(\"%s?listen\"), *LobbyPath); 修改createsession函数 World-&gt;ServerTravel(PathToLobby); 进入初始房间level blueprint，可以修改节点的参数了 24. Polishing the Menu Subsystem24.1 Create Session on destroy    当加入他人会话的玩家退回到主界面时，点击host会显示创建失败，但再次点击就会成功，是因为第一次点击destroy了上一个会话就立马create，但实际上还没来得及destroy完，所以需要重新设计下这个删除功能 在MultiplayerSubsystem.h中声明一些私有变量 bool bCreateSessionOnDestroy{ false }; int32 LastNumPublicConnection; FString LastMatchType;e; 修改createSession中销毁会话部分代码 //如果有会话存在，那么保存此次创建会话的信息，并在之后创建 if (ExistingSession != nullptr) { bCreateSessionOnDestroy = true; LastNumPublicConnection = NumPublicConnections; LastMatchType = MatchType; DestroySession(); } 实现Destroy void UMultiplayerSubsystem::DestroySession(){ if (!SessionInterface.IsValid()) { //给menu的回调发送false MultiplayerOnDestroySessionComplete.Broadcast(false); return; } DestroySessionCompleteDelegateHandle = SessionInterface-&gt;AddOnDestroySessionCompleteDelegate_Handle(DestroySessionCompleteDelegate); if (!SessionInterface-&gt;DestroySession(NAME_GameSession))//如果销毁失败 { SessionInterface-&gt;ClearOnDestroySessionCompleteDelegate_Handle(DestroySessionCompleteDelegateHandle);//清除句柄 MultiplayerOnDestroySessionComplete.Broadcast(false); }} 实现destroy的回调函数 void UMultiplayerSubsystem::OnDestroySessionComplete(FName SessionName, bool bWasSuccessful){ if (SessionInterface) { SessionInterface-&gt;ClearOnDestroySessionCompleteDelegate_Handle(DestroySessionCompleteDelegateHandle);//清除句柄 } if (bWasSuccessful &amp;&amp; bCreateSessionOnDestroy)//如果接口的destroy成功且是通过删除再创建新会话 { bCreateSessionOnDestroy = false;//重置标记 CreateSession(LastNumPublicConnection, LastMatchType);//创建会话，这样其实会多创一次，但这样保证了一定会创建成功一个 } MultiplayerOnDestroySessionComplete.Broadcast(bWasSuccessful);//广播道菜单去} 24.2 Quit Game button    在右上角创建QuitButton即可，直接给按钮添加点击事件退出游戏即可24.3 Disable menu button 修改menu.cpp的按钮事件即可，加上这行：HostButton-&gt;SetIsEnabled(false); 如果创建加入会话失败，那么只需要在回调函数中添加HostButton-&gt;SetIsEnabled(true); 在find回调中添加： if (SessionResult.Num() == 0 || !bWasSuccessful) { if (GEngine) { GEngine-&gt;AddOnScreenDebugMessage( -1, 15.f, FColor::Red, FString(TEXT(\"Sessions Num : 0! or find error!\")) ); } JoinButton-&gt;SetIsEnabled(true); return; } 在join回调底部，如果join失败也JoinButton-&gt;SetIsEnabled(true); " }, { "title": "基于Unreal5和TrueSkill的游戏匹配系统-设计文档", "url": "/posts/%E5%9F%BA%E4%BA%8EUnreal5%E5%92%8CTrueSkill%E7%9A%84%E6%B8%B8%E6%88%8F%E5%8C%B9%E9%85%8D%E7%B3%BB-%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/", "categories": "Unreal5, 多人在线游戏匹配系统", "tags": "多人在线, TrueSkill", "date": "2022-08-03 03:26:00 +0000", "snippet": "摘 要    在竞技游戏对局中，往往势均力敌的对决才能带来精彩的比赛。游戏内的匹配系统就是根据玩家既往的战绩，对玩家的竞技水平进行评估，将水平接近的玩家匹配到同一房间内进行游戏比赛。本项目使用Unreal5的Subsystem与Steam服务器搭建多人在线系统，并使用TrueSkill算法中的部分算法对正在匹配的玩家进行分组，组成4V4对战，由于时间的限制与TrueSkill算法的难度，仅利...", "content": "摘 要    在竞技游戏对局中，往往势均力敌的对决才能带来精彩的比赛。游戏内的匹配系统就是根据玩家既往的战绩，对玩家的竞技水平进行评估，将水平接近的玩家匹配到同一房间内进行游戏比赛。本项目使用Unreal5的Subsystem与Steam服务器搭建多人在线系统，并使用TrueSkill算法中的部分算法对正在匹配的玩家进行分组，组成4V4对战，由于时间的限制与TrueSkill算法的难度，仅利用游戏质量公式实现了匹配功能，并未实现排位功能。    关键词：匹配系统；Unreal5；TrueSkill；SubSystem；Steam。Abstract    In a competitive game match, it is often a close match that brings about a wonderful game. The matching system in the game is to evaluate the player’s competitive level based on the player’s previous record, and match the players with similar levels to the same room for game competition. This project uses the Subsystem of Unreal5 and the Steam server to build a multiplayer online system, and uses part of the TrueSkill algorithm to group the players being matched to form a 4V4 battle. Due to time constraints and the difficulty of the TrueSkill algorithm, only the game quality formula is used. The matching function is implemented, but the ranking function is not implemented.    Keywords: matchmaker; Unreal5; TrueSkill; SubSystem; Steam.第1章 绪论    基于Unreal5和TrueSkill的游戏匹配系统的完成经历了多个阶段，接下来的设计文档将从评分系统调研、实现过程以及结论展望方面介绍该系统。1.1 引言    评分系统计算选手竞技水平的评分并排名，在竞技项目中有着重要的应用，例如体育和游戏.首先它对选手竞技水平的提升和下降有统一的度量，帮助评估选手实力和激发选手动力；其次排名能为赛事组织者安排种子选手提供依据，使得比赛安排更加合理；最后，体育爱好者通过排名直观了解选手，增强比赛的观赏性.目前，广泛应用的评分系统有等级分制、Elo评分和TrueSkill评分系统等[1]。    竞技游戏和体育项目中的技能评分系统具有三个主要功能。第一，它们允许玩家与其他技能水平相似的玩家进行匹配，从而产生有趣、平衡的比赛；第二，可以将评分提供给玩家和感兴趣的观众，从而激发兴趣；第三，评分可以作为比赛资格的标准。随着在线游戏的出现，评分系统的热度急剧增加，因为每天数百万玩家的在线体验质量都会受到评分系统的影响[2]。    本系统采用的算法源自TrueSkill，完整的TrueSkill包含了排名系统，这一部分涉及到的数学公式数量较多，在短时间内无法完全掌握并实现，因此，此系统仅仅基于TrueSkill算法的部分原理，实现了匹配系统，利用均值和标准差来描述玩家的技能水平，通过计算玩家与房主的比赛质量系数来判断是否加入比赛，在这一步已经完成了初步的匹配，匹配到的都是与房主水平相近的玩家，当房间人数达到8人时，利用随机取样算法，分出两组进行对战，也许这并不是期望平局率最高的方案，但这也许是个能让比赛有趣的方案。第2章 评分系统2.1 ELO评分系统    Elo评分是根据选手过去成绩来计算选手目前相对水平的一种评分系统。Elo评分系统 由美国物理学教授ArpadElo于1959年提出，最初是用于计算国际象棋比赛中的棋手的相对水平。El0评分系统假设棋手赢得比赛的期望结果是选手当前评分差距的函数，选手的Elo评分的更新与实际结果和期望结果的偏差成比例[1]。    选手战胜选手的概率 ，即预期结果为:\\[E_A = \\frac{\\gamma_A}{\\gamma_A+\\gamma_B}=\\frac{10^{R_A/100}}{10^{R_A/100}+10^{R_B/100}}=\\frac{1}{1+10^{-(R_A-R_B)/400}}\\tag1\\]\\[E_B=1-E_A\\tag2\\]    式中：RA、RB分别为棋手A和B的Elo评分.当RA=RB时，EA=EB=O.5,即比赛的期望结果为平局.当棋手A领先B的Elo等级分越多时，A战胜B的概率越大，反之亦然。    比赛结束后，棋手A的Eo评分应更新为:\\[R_A^\\prime=R_A+K(S_A-E_A)\\tag3\\]    其中$S_A$为比赛的实际结果，在双人游戏中，$S_A$规定如下：    当棋手A赢B时，$S_A$ =1；当比赛平局，$S_A$=0.5；其他情况$S_A$ =0。    K为调节参数，控制评分更新的幅度.通常，对于新选手采用较高的K值，随比赛增加而逐渐减小K[1]。2.2 Glicko评分系统    Elo系统的问题在于无法确定选手评分的可信度，而Glicko系统正是针对此进行改进。因此Glicko系统扩展了Elo，将不再是仅计算选手评分（可以视为选手实力的“最佳猜测”），还加入了“评分误差”（RD，ratings deviation），从统计术语的概念来说，RD用于衡量一个评分的不确定度（RD值越高，评分越不可信）。高RD值意味着选手并不频繁地进行对战，或者该选手仅进行了很少次数的对战，而低RD值说明选手会很经常地进行对抗比赛[3]。2.3 TrueSkill评分系统    Elo评价系统计算简单易用，但主要用于1对1型的对抗结果。如果对战形式是多人多队，或者更复杂的对战形式，Elo评价系统就显得非常局限。另一方面，Elo评价系统涉及多个随机变量（个人能力由某个分布描述和随机对战结果），而随机变量见又存在着明显的依赖关系。显然，这非常适合以贝叶斯概率图模型的观点进行组织建模，在给定了对战结果后给出评价对象能力的后验推断，TrueSkill就提供这样一种解决方案。相较Elo评价系统，TrueSkill的优势在于： 适用于复杂的组队形式，更具一般性。 置于更完善的建模体系，容易扩展。 继承了贝叶斯建模的好的特点，如模型选择等[4]。     本系统采用了TrueSkill算法中的MatchQuality算法来计算比赛质量（平局系数），范围为(0,1)，系数越接近1，比赛的质量越高，以下是公式：\\[q_{draw}(\\beta^2,\\mu_i,\\mu_j,\\sigma_i,\\sigma_j):=\\sqrt{\\frac{2\\beta^2}{2\\beta^2+\\sigma_i^2+\\sigma_j^2}}\\cdot exp\\left(-\\frac{(\\mu_i-\\mu_j)^2}{2(2\\beta^2+\\sigma_i^2+\\sigma_j^2)}\\right)\\tag4\\]第3章 系统实现过程3.1 多人在线系统3.1.1 client-server 模式    client-server模式有两种模式，分别是listen-server和dedicated-server模式，在本系统中，使用了listen-server模式，让参与游戏的一名玩家作为监听服务器，其他7名参与的玩家为客户端。3.1.2 虚幻引擎的Online Subsystem 在线子系统    为了不输入对方的IP地址就同世界各地的人们一起游戏，需要使用一个服务器服务，比如steam，又为了避免使用不同服务器代码库不同带来的影响，虚幻引擎抽象了一层Online Subsystem，以至于只用写一遍代码，打包成一个插件就可以在配置后连接各种类型服务器的服务，因为虚幻引擎的在线子系统处理了其中的细节。    在线子系统提供了一种访问在线平台服务功能的方式。在线平台，是指像Steam和Xbox Lives等这样的东西。这些平台中的每一个都有自己的一套服务支持，如朋友、成就。设置匹配会话，等等。在线子系统包含一组接口，旨在处理每个平台的这些不同服务。因此无论我们选择哪种服务，都可以用在线子系统来处理我们对这些接口的使用。我们所要做的就是为一个特定的平台配置我们的项目。3.1.3 session interface 会话接口    会话接口处理创建、管理和销毁游戏会话。它还处理搜索会话和其他匹配功能。一个会话可以被认为是游戏的一个实例，在服务器上运行，有一系列的属性，并且一个会话可以被公布，以便其他玩家可以找到这个会话并加入进来或者是私人的，所以只有被邀请的人才能加入游戏。    一个典型的游戏会话的基本寿命是这样的。 首先，用一组所需的设置来创建会话。 然后你等待其他玩家的加入，并在他们进来的时候注册每个人。 一旦有足够的玩家加入，就开始会话。 然后每个玩家都在同一个会话中玩游戏。 一旦比赛结束，就可以结束会话并取消玩家的注册。 然后可以更新会话，改变比赛的设置。    会话接口函数：CreateSession(), FindSession(), JoinSession(), StartSession(), DestroySession()3.1.4 session interface functions 会话接口函数    通过使用接口提供的方法，创建委托并绑定回调函数来实现多人联机。    构造委托： FOnCreateSessionCompleteDelegate CreateSessionCompleteDelegate;创建回调函数：void OnCreateSessionComplete(FName SessionName, bool bWasSuccessful);    绑定委托与回调函数：CreateSessionCompleteDelegate(FOnCreateSessionCompleteDelegate::CreateUObject(this, &amp;ThisClass::OnCreateSessionComplete))    将委托加入委托列表：CreateSessionCompleteDelegateHandle = SessionInterface-&gt;AddOnCreateSessionCompleteDelegate_Handle(CreateSessionCompleteDelegate);    从委托列表中清除使用后的委托：SessionInterface-&gt;ClearOnCreateSessionCompleteDelegate_Handle(CreateSessionCompleteDelegateHandle);3.1.5 custom delegate 自定义委托    使用自定义的委托，在执行完会话创建的委托回调函数后，创建自定义委托来执行menu类的回调函数，以此来使multiplayer session subsystem可以与menu类实现互通。3.2 匹配系统3.2.1 根据比赛质量算法进行匹配    公式中有两个变量$\\mu$、$\\sigma$和一个常量$\\beta$参与运算。    $\\mu$代表着均值，也是分布的期望值。$\\mu$代表着玩家的技能水平高低。    $\\sigma$代表概率分布的标准差，意味着样本分散距离。$\\sigma$代表玩家的不稳定性，$\\sigma$越高，玩家的水平就越不稳定。    $\\beta$代表着技能等级间距，也就是当玩家A的$\\mu$大于玩家B的$\\mu$一个$\\beta$的值时，玩家A就有近似80%的胜率，也就意味着玩家A比玩家B高一个等级。    代码实现：double UMenu::CheckQuality(double Mu1, double Sigma1, double Mu2, double Sigma2){ double BETA = 25 / 6; double c = 2 * std::pow(BETA, 2) + std::pow(Sigma1, 2) + std::pow(Sigma2, 2); double d = 2 * std::pow(BETA, 2) / c; double e = -1 * std::pow(Mu1 - Mu2, 2) / (2 * c); return exp(e) * sqrt(d);}3.2.2 随机取样算法分组    每当有一个玩家进入大厅房间后，便将玩家加入数组中，当玩家数量到达8时，通过随机取样算法来从8人中随机抽取4人组成TeamA，其余组成TeamB，组完队后传送到游戏房间。    随机取样算法代码实现：int m = NumberOfPlayers / 2;srand((unsigned int)time(0));for (int i = 0; i &lt; NumberOfPlayers; i++){ if (rand() % (NumberOfPlayers - i) &lt; m)//rand()%(n-i)的取值范围是[0, n-i) { GEngine-&gt;AddOnScreenDebugMessage( -1, 60.f, FColor::Blue, FString::Printf(TEXT(\"%s in TeamA\"), *PlayersName[i]) ); m--; } else { GEngine-&gt;AddOnScreenDebugMessage( -1, 60.f, FColor::Red, FString::Printf(TEXT(\"%s in TeamB\"), *PlayersName[i]) ); }}第4章 系统界面4.1 初始关卡    初始关卡，两个TextBox可以通过键盘输入来修改玩家的$\\mu$和$\\sigma$用于测试，点击OK即可更新玩家的$\\mu$和$\\sigma$。点击Host按钮，玩家会作为监听服务器创建一个会话，并跳转到大厅关卡。其他玩家点击Join按钮，便会开始匹配，将搜索到的结果遍历，当自己与房主的比赛质量系数大于预设时，便加入会话并跳转到大厅关卡。4.2 大厅关卡    此时当有玩家进入大厅时，会在屏幕左侧显示，当玩家数量到达8时，便会通过随机取样算法分组，并跳转到游戏关卡。4.3 游戏关卡    当玩家为8人时，开启游戏，跳转到游戏关卡，左侧日志中打印了8人分别所属的队伍。第5章 总结与展望5.1 总结    在实现本系统的过程中了解了很多未知领域的知识，过去一年里只做过单机游戏，这次夏令营第一次接触了网络游戏的实现，并且是首次使用Unreal5的C++实现游戏，比Unity和GameMaker Studio2都要更难一些，但Unreal的蓝图对新手来讲还是十分友好的。    通过这次夏令营，也开阔了视野，TrueSkill算法出乎意料得富有挑战性，并且也很有趣，想要实现完整的排位系统对目前的我来讲还是有一定难度的，但对于明年的我来讲，也许不会再是个令我费解的难题。5.2不足之处及未来展望    这个系统不足之处实在是太多了，不只是时间短的缘故，Unreal引擎是从五月底才开始接触的，还不算熟悉，这也是进度不快的原因之一。在匹配系统的制作上，仅仅使用了质量系数，没有使用更多的数据来使得匹配更有说服性。    对匹配系统的未来展望：    能够充分利用选手的数据，不仅仅是TrueSkill算法中使用的均值与标准差，还应有对局信息，甚至所使用英雄、枪支的数据信息。    在分组的过程中，使用了随机采样算法，并不能保证最高的平局系数，在对战人数少的情况下还可以考虑暴力遍历，但当人数上升后，可以考虑使用群智能算法来分组，比如遗传算法、免疫算法等。    尝试解决炸鱼问题、高手匹配问题等。    将改良版的匹配系统应用到毕业设计中。参考文献[1]吴霖,陈磊,邓超,袁梅宇,江虹.基于TrueSkill模型的围棋棋手排名方法及评估[J].昆明理工大学学报(自然科学版),2013,38(03):47-55.[2]Herbrich R,Minka T,Graepel T.TrueSkill(TM):A Bayesian skill rating system[C]//In Advances in Neural Information Pro-cessing Systems 20.Scholkopf B,Platt J,Hoffman T.Cambridge:MIT Press,2007:569-576.[3]GLICKMAN M E.The Glicko system[EB/OL].http://www.glicko.net/glicko.html.[4]谢白羽. 游戏思考系列03：游戏匹配机制(MMR、ELO、trueskill2、皇家战争、Glicko等，详细讲ELO，其他的简略)[EB/OL].2021[2022-7-12]. https://blog.csdn.net/weixin_43679037/article/details/121855591.[5]Jeff Moser. Computing Your Skill[EB/OL]. 2010[2022-7-12]. http://www.moserware.com/2010/03/computing-your-skill.html.[6]白婷. TrueSkill 原理及实现[EB/OL]. 2016[2022-7-12]. https://www.cnblogs.com/baiting/p/5591614.html." }, { "title": "PAT-Recover the Smallest Number & Perfect Sequence & Insert or Merge & 二分查找函数upper_bound()", "url": "/posts/PAT-Recover-the-Smallest-Number-&-Perfect-Sequence-&-Insert-or-Merge-&-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%87%BD%E6%95%B0upper_bound()/", "categories": "算法刷题, PAT", "tags": "贪心, 二分", "date": "2022-08-02 14:26:00 +0000", "snippet": "A1038 Recover the Smallest Number#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;bool comp(string&amp; s1, string&amp; s2){ /* ...", "content": "A1038 Recover the Smallest Number#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;bool comp(string&amp; s1, string&amp; s2){ /* int len = s1.size() &gt; s2.size() ? s1.size() : s2.size();//取长度最长的来比较 //短的string到头了就要从头接着比 for (int j = 0; j &lt; len; j++) { if (s1[j % s1.size()] == s2[j % s2.size()])//如果相同位相同 { continue; } else//如果不同，小的在前面 { return s1[j % s1.size()] &lt; s2[j % s2.size()]; } } //如果遍历到最后都相等，其实怎么排都无所谓了 return true;*/ return s1 + s2 &lt; s2 + s1;//如果s1 + s2小，就把s1排前面}int main(){ int N; cin &gt;&gt; N;//数字片段个数 vector&lt;string&gt; segs; for (int i = 0; i &lt; N; i++) { string _num; cin &gt;&gt; _num; segs.emplace_back(_num); } //排序 sort(segs.begin(), segs.end(), comp); //输出：记得去掉先导0 bool zero; if (segs[0][0] == '0')zero = true;//说明有先导0 else zero = false; for (int i = 0; i &lt; segs.size(); i++) { if (zero)//如果当前还有先导0 { for (int j = 0; j &lt; segs[i].size(); j++)//遍历当前字符串的每个字符 { if (segs[i][j] != '0')//如果已经不是0了，那就把剩下的输出 { zero = false; cout &lt;&lt; segs[i].substr(j); break; } } } else//当前已经没有先导0 { cout &lt;&lt; segs[i]; } } if (zero)//如果到最后了都是0 { cout &lt;&lt; 0; }}    这道题按我的程序做完后，有两个测试点（一共6分）过不去，其中一个是特判，如果号码全是0，那么要输出0，还有一处，其实是我comp函数写的不对（注释里的是我写的），我已经想到了两个长度不同的字符串顺序不同大小不同这一点，但我进行判断的方法很复杂，还不能保证一定对，因为我是按长串的长度来一一比对，短串到头了再重新比，如果都相同就return false（此时我觉得，return什么都行），但实际上不应该是这样，比如123和1231，按我的方法，这两个串就是相等了，谁放在前面都行，但1231123是小于1231231的，像我写的return false的话，123会放在1321的前面，这样答案就不对了，改成true可以通过这一个样例，但实际上还是不对的，如果样例多一点，肯定还是不行的。    直接两串相加对比，既简单，又正确 。A1085 Perfect Sequence#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;int main(){ LL N, p; cin &gt;&gt; N &gt;&gt; p;//序列中元素个数N，参数p vector&lt;LL&gt; sequence; //读取每个数 for(int i = 0; i &lt; N; i++) { LL _num; cin &gt;&gt; _num; sequence.emplace_back(_num); } sort(sequence.begin(), sequence.end()); LL goal; int ans = 0; //从最小的开始遍历，二分查找右侧第一个大于m*p并返回它的位置 for (int i = 0; i &lt; N; i++) { goal = sequence[i] * p; //pos为第一个大于m*p的位置，pos-i处的位置正好是等于序列长 auto pos = upper_bound(sequence.begin(), sequence.end(), goal); int len = pos - (sequence.begin() + i); if (len &gt; ans) { ans = len; } } cout &lt;&lt; ans;}    这道题目其实从某种意义上来讲是暴力算法，只是用二分把复杂度从$O(n^2)$降到了$O(nlog(n))$，其中upper_bound()函数就是二分查找，非常方便，记录下upper_bound() &amp; lower_bound() upper_bound(I first, S last, const T&amp; value) 指向首个大于 value 的元素的迭代器，或若找不到这种元素则为 last 。 lower_bound( ForwardIt first, ForwardIt last, const T&amp; value ); 指向首个不小于 value 的元素的迭代器，或若找不到这种元素则为 last 。A1089 Insert or Merge#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;bool isSame(vector&lt;int&gt;&amp; tmp, vector&lt;int&gt;&amp; partial){ for (int i = 0; i &lt; tmp.size(); i++) { if (tmp[i] != partial[i]) return false; } return true;}bool insertSort(vector&lt;int&gt;&amp; origin, vector&lt;int&gt;&amp; partial){ bool flag = false;//标记是否和部分排序的数组一样了 for (int i = 1; i &lt; origin.size(); i++)//进行size()-1次排序 { //先判断是否和部分排序的数组一样了 if (i != 1 &amp;&amp; isSame(origin, partial))//初始数组不进行判断 { flag = true; } //插入排序 int tmp = origin[i];//储存当前要插入的元素 int j = i; while (j &gt; 0 &amp;&amp; origin[j - 1] &gt; tmp)//如果前面一个元素大于要插入的元素 { origin[j] = origin[j - 1]; j--; } origin[j] = tmp; //判断是否可以退出了 if (flag)//此时说明是插入排序，而且下一步也做好了 { return true; } } return false;//排完了还不相等}void mergeSort(vector&lt;int&gt;&amp; origin, vector&lt;int&gt;&amp; partial){ bool flag = false; //以2为步长，每次翻倍 for (int step = 2; step / 2 &lt; origin.size(); step *= 2) { //先判断是否和部分排序数组一致 if (isSame(origin, partial)) { flag = true; } //归并排序 for (int i = 0; i &lt; origin.size(); i += step) { sort(origin.begin() + i, min(origin.begin() + i + step, origin.end())); } //如果一致了 if (flag) { return; } }}void showArray(vector&lt;int&gt; &amp;array){ for (int i = 0; i &lt; array.size(); i++) { if (i != 0) { cout &lt;&lt; ' ' &lt;&lt; array[i]; } else { cout &lt;&lt; array[i]; } }}int main(){ int N;//序列数字个数 cin &gt;&gt; N; vector&lt;int&gt; origin(N); vector&lt;int&gt; partial(N); for (int i = 0; i &lt; N; i++) { cin &gt;&gt; origin[i]; } for (int i = 0; i &lt; N; i++) { cin &gt;&gt; partial[i]; } vector&lt;int&gt; tmp(origin); if (insertSort(tmp, partial)) { cout &lt;&lt; \"Insertion Sort\" &lt;&lt; endl; showArray(tmp); } else { mergeSort(origin, partial); cout &lt;&lt; \"Merge Sort\" &lt;&lt; endl; showArray(origin); }}    这道题对我来说稍有难度，涉及到插入排序和归并排序的具体书写，其中归并排序的迭代写法通过每次迭代step的方式来循环。插入排序中，插入时，从数组排好序的尾部开始比对，直到比对到0或者小于要插入元素时才停止。" }, { "title": "PAT-Be Unique & String Subtraction & Find Coins & Mooncake & Magic Coupon & Sort with Swap(0, i)", "url": "/posts/PAT-Be-Unique-&-String-Subtraction-&-Find-Coins-&-Mooncake-&-Magic-Coupon-&-Sort-with-Swap(0,-i)/", "categories": "算法刷题, PAT", "tags": "哈希表, 贪心", "date": "2022-08-01 13:56:00 +0000", "snippet": "A1041 Be Unique#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;unordered_map&gt;using namespace std;int main(){ unordered_map&lt;int, int&gt; map; int N;//数字个数 cin &gt;&gt; N; ...", "content": "A1041 Be Unique#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;unordered_map&gt;using namespace std;int main(){ unordered_map&lt;int, int&gt; map; int N;//数字个数 cin &gt;&gt; N; vector&lt;int&gt; nums;//按顺序储存所有的数字 for (int i = 0; i &lt; N; i++) { int num; cin &gt;&gt; num; if (!map.count(num))//如果之前没遇到过num { nums.emplace_back(num); } map[num]++; } for (int n : nums) { if (map[n] == 1) { cout &lt;&lt; n; return 0; } } cout &lt;&lt; \"None\"; return 0;}    简单题，不多解释。A1050 String Subtraction#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;unordered_map&gt;using namespace std;int main(){ unordered_map&lt;char, int&gt; map; string s1, s2; getline(cin, s1); getline(cin, s2); for (char c : s2) { map[c]++; } for (char c : s1) { if (!map.count(c)) { cout &lt;&lt; c; } }}    简单的哈希表A1048 Find Coins#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;unordered_map&gt;#include&lt;set&gt;using namespace std;int main(){ int N, M;//硬币数、金额 cin &gt;&gt; N &gt;&gt; M; unordered_map&lt;int, int&gt; coinMap; set&lt;int&gt; coinKind; for (int i = 0; i &lt; N; i++) { int _coin; cin &gt;&gt; _coin; coinKind.insert(_coin); coinMap[_coin]++; } for (auto c : coinKind) { if (2 * c &gt; M) break;//如果c大于M的一半，直接退出循环 else if (2 * c == M)//如果c是M的一半 { if (coinMap[c] &gt;= 2) { cout &lt;&lt; c &lt;&lt; ' ' &lt;&lt; M - c; return 0; } } else if (coinMap.count(M - c)) { cout &lt;&lt; c &lt;&lt; ' ' &lt;&lt; M - c; return 0; } } cout &lt;&lt; \"No Solution\"; return 0;}    这道题有个小陷阱，就是使用的硬币V1得&lt;=V2，其中如果等于的话，得看map里有没有两个等面值的硬币。A1070 Mooncake#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;struct mooncake{ double inventory;//库存 double totalPrice;//总价 double price;//单价 mooncake(double _inventory) :inventory(_inventory) {}};bool comp(mooncake&amp; c1, mooncake&amp; c2){ return c1.price &gt; c2.price;}int main(){ int N, D;//月饼种类、超商需求 cin &gt;&gt; N &gt;&gt; D; double demand = (double)D; vector&lt;mooncake&gt; cakes; //读取每种月饼的库存 for (int i = 0; i &lt; N; i++) { double _inventory; cin &gt;&gt; _inventory; cakes.emplace_back(mooncake(_inventory)); } for (int i = 0; i &lt; N; i++) { double _price; cin &gt;&gt; _price; cakes[i].totalPrice = _price; cakes[i].price = _price / cakes[i].inventory; } //按价位排序 sort(cakes.begin(), cakes.end(), comp); double profit = 0.0; for (auto c : cakes) { if (c.inventory &lt; demand)//如果当前种类月饼的库存小于需求，那么全买 { profit += c.totalPrice; demand -= c.inventory; } else if (c.inventory == demand)//如果当前种类月饼的库存等于需求，也全买并且退出 { profit += c.totalPrice; break; } else//如果当前种类月饼的库存大于需求，只买一部分并且退出 { profit += ((double)demand / (double)c.inventory * c.totalPrice); break; } } printf(\"%.2lf\", profit);}    这道题，外表看似简单，其实隐藏了一个惊天大陷阱。注意input Specification中是这么讲的：the first line contains 2 positive integers；Then the second line gives the positive inventory amounts，这后面的库存其实只是正数，没说不能是小数，所以如果都按整型来算，是会有一个测试点过不去的，岂可休！A1037 Magic Coupon#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;bool comp1(int a, int b)//从大到小排序{ return a &gt; b;}int main(){ int nC, nP;//优惠券数量，产品数量 vector&lt;int&gt; couponPostive, couponNegtive;//分别储存正、负优惠券 vector&lt;int&gt; productPostive, productNegtive;//分别储存正、负产品 cin &gt;&gt; nC; while (nC--) { int c; cin &gt;&gt; c; //只考虑正负，不考虑0 if (c &gt; 0) couponPostive.emplace_back(c); else if (c &lt; 0) couponNegtive.emplace_back(c); } cin &gt;&gt; nP; while (nP--) { int p; cin &gt;&gt; p; if (p &gt; 0) productPostive.emplace_back(p); else if (p &lt; 0) productNegtive.emplace_back(p); } //给正数数组按从大到小排序 sort(couponPostive.begin(), couponPostive.end(), comp1); sort(productPostive.begin(), productPostive.end(), comp1); //给负数数组按从小到大排序 sort(couponNegtive.begin(), couponNegtive.end()); sort(productNegtive.begin(), productNegtive.end()); int maximum = 0; //计算正数中的最大收益 //取二者小的 int len = couponPostive.size() &lt; productPostive.size() ? couponPostive.size() : productPostive.size(); for (int i = 0; i &lt; len; i++) { maximum += (couponPostive[i] * productPostive[i]); } //同样取二者小的 len = couponNegtive.size() &lt; productNegtive.size() ? couponNegtive.size() : productNegtive.size(); for (int i = 0; i &lt; len; i++) { maximum += (couponNegtive[i] * productNegtive[i]); } cout &lt;&lt; maximum;}    简单的贪心算法。A1067 Sort with Swap(0, i)#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;int main(){ int N;//序列长度 cin &gt;&gt; N; vector&lt;int&gt; pos(N); //记录每个数字的位置 int mismatch = 0;//不在本位个数（除了0） for (int i = 0; i &lt; N; i++) { int _num; cin &gt;&gt; _num; pos[_num] = i; if (pos[_num] != _num &amp;&amp; _num != 0)//统计有多少个数（除了0）不在本位 { mismatch++; } } //贪心算法，硬贪，先判断0在不在0位上，不在的话就直接交换， //在的话就跟第一个不在本位的数字交换后再换 int ans = 0; int k = 1;//记录不在本位数字的最小下标/位置 while (mismatch &gt; 0)//还有数字不在本位 { //如果0在位置0 if (pos[0] == 0) { //那么去找一个不在本位的数字，和它交换位置 while (k &lt; N &amp;&amp; pos[k] == k) { k++; } swap(pos[0], pos[k]);//0和k的位置互换 ans++; } while (pos[0] != 0)//如果0不在位置0 { //正常交换 swap(pos[0], pos[pos[0]]); ans++; mismatch--; } } cout &lt;&lt; ans;}    这道题，说实话，有点小难，虽然我想到了这个策略，但我觉得并不一定真的是最优的策略，就止步不前了，没想到还就是这么个策略，看来贪心算法真是要有胆量去做。    直接默认如果0到了0位却还没有都归位，那就让0和最邻近的一个没归位的数交换位置。" }, { "title": "PAT-Graduate Admission & Cars on Campus & To Buy or Not to Buy", "url": "/posts/PAT-Graduate-Admission-&-Cars-on-Campus/", "categories": "算法刷题, PAT", "tags": "排序, 哈希表", "date": "2022-07-31 08:59:00 +0000", "snippet": "A1080 Graduate Admission#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;set&gt;using namespace std;struct stuInfo{ int id;//学生编号 int G...", "content": "A1080 Graduate Admission#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;set&gt;using namespace std;struct stuInfo{ int id;//学生编号 int G_E, G_I;//统考分数和面试分数 int total;//学生总分 int school = -1;//录取学校 vector&lt;int&gt; prefer;//目标院校 stuInfo(int _id, int _Ge, int _Gi) :id(_id), G_E(_Ge), G_I(_Gi), total(_Ge + _Gi) {}};bool comp(stuInfo&amp; s1, stuInfo&amp; s2){ if (s1.total != s2.total) return s1.total &gt; s2.total; else return s1.G_E &gt; s2.G_E;}int main(){ int N, M, K;//考生数目，学校数，志愿数 cin &gt;&gt; N &gt;&gt; M &gt;&gt; K; vector&lt;int&gt; quota;//学校配额 for (int i = 0; i &lt; M; i++) { int _quota; cin &gt;&gt; _quota; quota.emplace_back(_quota); } //读取学生信息 vector&lt;stuInfo&gt; stu; for (int i = 0; i &lt; N; i++) { int _Ge, _Gi; cin &gt;&gt; _Ge &gt;&gt; _Gi; //存id、成绩 stu.emplace_back(stuInfo(i, _Ge, _Gi)); //存志愿 for (int j = 0; j &lt; K; j++) { int _prefer; cin &gt;&gt; _prefer; stu[i].prefer.emplace_back(_prefer); } } //排序：按总分排，总分一样，按统考分 sort(stu.begin(), stu.end(), comp); //学校录取的人 vector&lt;set&lt;int&gt; &gt; schoolAdmit(M); int index = 0;//记录相同排名的学生的第一个下标 //开始遍历学生，投递学校 for (int i = 0; i &lt; N; i++) { //判断当前学生跟上一名学生的名次是否相同，相同的话，index不变，如果不相同，index更新 if(i &gt; 0 &amp;&amp; stu[i].total == stu[i - 1].total &amp;&amp; stu[i].G_E == stu[i - 1].G_E) { } else//不同的话 { index = i;//更新下标 } //开始遍历学生的志愿，如果有配额就入， //遇到配额不足的，就查相同名次的学生，看其是否在这所学校，如果在，那就也入 for (int j = 0; j &lt; K; j++) { int _prefer = stu[i].prefer[j];//学生当前志愿学校 if (quota[_prefer] &gt; 0)//如果有配额 { stu[i].school = _prefer; schoolAdmit[_prefer].insert(stu[i].id);//当前学校录取当前学生 quota[_prefer]--;//配额减1 break;//有学上了，就不再看下一个志愿了 } else//如果没有配额 { bool admitted = false;//判断是否录取 //检查相同名次学生的录取院校是否是当前院校 for (int k = index; k &lt; i; k++) { if (stu[k].school == _prefer)//如果相同名次的学生已经入学 { //该生也要入学 stu[i].school = _prefer; schoolAdmit[_prefer].insert(stu[i].id);//当前学校录取当前学生，记录编号 quota[_prefer]--;//配额减1 admitted = true; break; } }//循环完都没有这种情况，那就看下一个志愿 if (admitted) break;//有学上就不再看下一个志愿了 } } } //打印结果 for (int i = 0; i &lt; M; i++) { if (schoolAdmit[i].size() == 0)//如果这所学校没有录取到学生 { cout &lt;&lt; endl; } else { for (auto j = schoolAdmit[i].begin(); j != schoolAdmit[i].end(); j++)//打印每个学生的id { if (j != schoolAdmit[i].begin())//如果不是第一个，就前面输出空格 { cout &lt;&lt; ' ' &lt;&lt; *j; } else cout &lt;&lt; *j;//是第一个前面就不输出空格 } cout &lt;&lt; endl; } }}    这道题目看起来代码多，其实也就逻辑复杂点，并不算难，写完后有两个错，一个是段错误，这是因为在遍历学生时，取了&lt;=N，但学生是从0开始算的，所以不用=。第二个错是学校存的id有误，这是因为要插入的是学生的编号，不是排名。A1095 Cars on Campus#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;map&gt;using namespace std;struct carRecord{ string plate; int time;//转换成s string state;//记录车的状态 carRecord(string _plate, int _time, string _state) :plate(_plate), time(_time), state(_state) {}};bool comp(carRecord&amp; r1, carRecord&amp; r2){ if (r1.plate != r2.plate) return r1.plate &lt; r2.plate; else return r1.time &lt; r2.time;}bool comp2(carRecord&amp; r1, carRecord&amp; r2){ return r1.time &lt; r2.time;}int main(){ int N, K;//N个记录，K个询问 cin &gt;&gt; N &gt;&gt; K; vector&lt;carRecord&gt; record; //读取记录 while (N--) { string _plate, _state; int hh, mm, ss; //scanf读取string的方法： _plate.resize(8); _state.resize(4); scanf(\"%s %d:%d:%d %s\", &amp;_plate[0], &amp;hh, &amp;mm, &amp;ss, &amp;_state[0]); record.emplace_back(carRecord(_plate, hh * 3600 + mm * 60 + ss, _state)); } //排序 sort(record.begin(), record.end(), comp); //提取有效数据 vector&lt;carRecord&gt; valid; map&lt;string, int&gt; totalTime;//记录每辆车的总时间 int maxTime = 0; string in = \"in\"; string out = \"out\"; in.resize(4); out.resize(4); for (int i = 0; i &lt; record.size() - 1; i++) { //检查相邻两个是不是能够配对 if (record[i].plate == record[i + 1].plate)//如果相邻两个记录车牌号一样 { //检查是否一进一出 string r1 = record[i].state; string r2 = record[i + 1].state; if (r1 == in &amp;&amp; r2 == out) { valid.emplace_back(record[i]); valid.emplace_back(record[i + 1]); totalTime[record[i].plate] += (record[i + 1].time - record[i].time); if (totalTime[record[i].plate] &gt; maxTime) maxTime = totalTime[record[i].plate];//记录最久时间 } } } //把valid按时间排序 sort(valid.begin(), valid.end(), comp2); //开始处理询问 int now = 0, numCar = 0;//now指当前询问的车辆序号 for (int i = 0; i &lt; K; i++) { int hh, mm, ss; scanf(\"%d:%d:%d\", &amp;hh, &amp;mm, &amp;ss); int curTime = hh * 3600 + mm * 60 + ss; while (now &lt; valid.size() &amp;&amp; valid[now].time &lt;= curTime) { if (valid[now].state == in)numCar++; else numCar--; now++; } printf(\"%d\\n\", numCar); } /*int curNum = 0;//记录当前停的车 int curIndex = 0;//记录遍历到的valid下标 while (K--) { int hh, mm, ss; scanf(\"%d:%d:%d\", &amp;hh, &amp;mm, &amp;ss); int curTime = hh * 3600 + mm * 60 + ss;//当前时间 //遍历记录 for (int i = curIndex; i &lt; valid.size(); i++) { //如果当前询问时间早于或等于这辆车的时间，那么就要输出询问 if (curTime &lt; valid[i].time) { curIndex = i;//下标不变 printf(\"%d\\n\", curNum); break;//输出完当前询问的结果后跳出这个循环，去执行下个询问 } else//如果i车还没到点，统计当前停的车的数量 { if (valid[i].state == in) curNum++; else curNum--;//车要出去 } } }*/ //输出停车时间最长的车 for (auto c : totalTime) { if (c.second == maxTime)//打印最久车 { printf(\"%s \", c.first.c_str()); } } printf(\"%02d:%02d:%02d\", maxTime / 3600, maxTime / 60 % 60, maxTime % 60);}    这道题问题太多了，甚至现在虽然拿到满分了，但依旧有问题。先说说注意事项吧。 关于string的比对，如何判断两个string相等，其实用==就行，但我的程序在开始时，并不能正常判断，这是因为我为了能够使用scanf来接收string，把string给resize()了一下，这一下久导致了无法正确判断，因为resize后，其余位用/0补完了，所以在进行相等判断时，state == “in”，此时state为”in/0/0”，而in其实是”in/0”这就导致判断两个字符串不相等了，所以我修复的办法就是把”in”存到string里，也给resize一下，out的方法一样 其他还有很多小问题，比如漏写break（尽管现在的代码已经没break了），导致统计车数出错 还有就是打印问题，用printf打印不出东西来，后来我把前面所有的cout都改成printf就好了 最后一个问题，也是我到现在也不太清楚的问题：就是当前车辆数目计算的方法，我自己写的方法和算法笔记的方法含义一样，只不过我用的for循环，他用的while，但我的代码，测试点1、2就是过不去，他的代码能过去，这一点挺匪夷所思的，我的代码写在注释里了，但我不懂为啥不行。不知道未来能否解决这个问题。只能说以后如果遇到类似的问题，还是得精准控制想要使用的变量，尽量别交给for循环去++，当然，不出错的话就直接for循环没关系。 A1092 To Buy or Not to Buy#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;unordered_map&gt;using namespace std;int main(){ string shop, Eva;//商店的珠子和eva想要的珠子 cin &gt;&gt; shop &gt;&gt; Eva; bool answer = true; //将商店的珠子存入哈希表 unordered_map&lt;char, int&gt; mapShop; for (int i = 0; i &lt; shop.size(); i++) { mapShop[shop[i]]++; } //去查是否能买够 int lesscnt = 0;//缺的珠子数 for (int i = 0; i &lt; Eva.size(); i++) { if (!mapShop.count(Eva[i]) || mapShop[Eva[i]] &lt;= 0)//如果想要的珠子没有 { answer = false; lesscnt++; } else { mapShop[Eva[i]]--; } } if (answer) { cout &lt;&lt; \"Yes\" &lt;&lt; ' ' &lt;&lt; shop.size() - Eva.size(); } else { cout &lt;&lt; \"No\" &lt;&lt; ' ' &lt;&lt; lesscnt; }}    简单的哈希表，第一次提交竟然没全对，忘了减商店的珠子了 ……" }, { "title": "PAT-The World's Richest & PAT Judge & List Grades", "url": "/posts/PAT-The-World's-Richest-&-PAT-Judge-&-List-Grades/", "categories": "算法刷题, PAT", "tags": "排序", "date": "2022-07-30 14:56:00 +0000", "snippet": "A1055 The World’s Richest#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 100001;//最大人数int Age[201] = {0};//某个年龄的人数s...", "content": "A1055 The World’s Richest#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 100001;//最大人数int Age[201] = {0};//某个年龄的人数struct personInfo{ string name; int age; int netWorth; personInfo(){} personInfo(string _name, int _age, int _netWorth): name(_name), age(_age), netWorth(_netWorth){}}people[maxn];bool comp(personInfo &amp;p1, personInfo &amp;p2){ if(p1.netWorth != p2.netWorth) { return p1.netWorth &gt; p2.netWorth; } else if(p1.age != p2.age) { return p1.age &lt; p2.age; } else { return p1.name &lt; p2.name; }}int main(){ //读入数据 int N,K;//总人数、询问数 cin&gt;&gt;N&gt;&gt;K; for(int i = 0; i &lt; N; i++) { string _name; int _age, _netWorth; cin&gt;&gt;_name&gt;&gt;_age&gt;&gt;_netWorth; people[i] = personInfo(_name, _age, _netWorth); } //先排序 sort(people, people + N, comp); //从排序好的所有人中，再进行筛选，每个年龄的人数最多为100个 vector&lt;personInfo&gt; valid; for(int i = 0; i &lt; N; i++) { if(Age[people[i].age] &lt; 100)//如果当前年龄的人数小于100 { valid.emplace_back(people[i]); Age[people[i].age]++; } } //处理询问 for(int j = 1; j &lt;= K; j++) { int M, Amin, Amax; cin&gt;&gt;M&gt;&gt;Amin&gt;&gt;Amax; vector&lt;personInfo&gt; output; for(int i = 0; i &lt; valid.size(); i++) { //在年龄区间的话就加入output中 if(valid[i].age &gt;= Amin &amp;&amp; valid[i].age &lt;= Amax) { output.emplace_back(valid[i]); } //够数了就退出循环，否则找到底 if(output.size() == M) break; } //输出： cout&lt;&lt;\"Case #\"&lt;&lt;j&lt;&lt;\":\"&lt;&lt;endl; if(output.size() == 0)//没有符合要求的人 { cout&lt;&lt;\"None\"&lt;&lt;endl; } else { for(auto p : output) { cout&lt;&lt;p.name&lt;&lt;' '&lt;&lt;p.age&lt;&lt;' '&lt;&lt;p.netWorth&lt;&lt;endl; } } }}    这道题其实不难，但我开始的思路是不对的，我本来是想在每次的询问中排序搜索，但这样是不行的，会超时，所以要提前排好序，再按顺序去查，但即使这样，也会超时，所以就要再进行一次筛选，把每个年龄的人数控制在100以内，这样就又剩下很多时间，多亏算法笔记，不然不知道又要在这耗费多少时间。    还有一处小问题就是，构造函数初始化，要以variable(value)这样的形式来赋值，不能用=不然会报错。A1075 PAT Judge#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;using namespace std;const int maxn = 10001;struct stuInfo{ int id; int point[6] = { -1 , -1, -1 , -1 , -1 , -1 }; int total = 0; int perfectNum = 0; bool show = 0;}stu[maxn];bool comp(stuInfo &amp;s1, stuInfo &amp;s2){ if (s1.total != s2.total) return s1.total &gt; s2.total; else if (s1.perfectNum != s2.perfectNum) return s1.perfectNum &gt; s2.perfectNum; else if (s1.show != s2.show) return s1.show &gt; s2.show;//如果两个人都是0分，那么show的要排在不show的前面 else return s1.id &lt; s2.id;}int main(){ int N, K, M;//总人数、题目数、提交数 cin &gt;&gt; N &gt;&gt; K &gt;&gt; M; int p[6];//每道题的满分 for (int i = 1; i &lt;= K; i++) cin &gt;&gt; p[i]; //读取每个提交信息 while (M--) { int _id, _quest, _point; cin &gt;&gt; _id &gt;&gt; _quest &gt;&gt; _point; stu[_id].id = _id;//刚开始每个人的id就是输入的_id if (_point != -1)//如果提交编译通过了 { //保存更新前的分数 int tmp = stu[_id].point[_quest]; if (_point &lt;= tmp) continue;//如果这次得分小于等于上次(正好如果多次满分也只+一次完美题目数) //如果这次分高，就更新 stu[_id].point[_quest] = _point &gt; tmp ? _point : tmp; stu[_id].show = 1;//需要显示 if (_point == p[_quest]) stu[_id].perfectNum++;//这道题目满分 if (tmp == -1)//说明之前这道题没提交成功过，这次提交成功了 { stu[_id].total += _point;//更新总分 } else//以前有分数，那就更新为最高分数 { //当前分数-上次分数 stu[_id].total += (stu[_id].point[_quest] - tmp); } } else//提交了但没通过 { //虽然不显示，但-1要变成0(如果之前有分数，那自然不用改) if(stu[_id].point[_quest] == -1) stu[_id].point[_quest] = 0; } } //排序 sort(stu + 1, stu + N + 1, comp); //打印 int rank = 0;//从0开始,但有个判断会先+1 for (int i = 1; i &lt;= N; i++) { if (stu[i].show)//首先得显示 { //如果当前人的分数和上一个一样，那排名不变 if (i &gt; 1 &amp;&amp; stu[i].total == stu[i - 1].total) { } else { rank = i ; } printf(\"%d %05d %d \", rank, stu[i].id, stu[i].total); //打印每个题目的分数 for (int j = 1; j &lt;= K; j++) { if (j != 1) cout &lt;&lt; \" \"; if (stu[i].point[j] == -1)//说明没提交成功 { cout &lt;&lt; \"-\"; } else cout &lt;&lt; stu[i].point[j]; } cout &lt;&lt; endl; } }}    这道题，坑挺多的，我还都踩了一遍…… 首先最最基础的问题就是，下标问题，输入的下标都是从1开始的，我也是按1算的，但循环我都从0开始了，所以一开始导致出了很多顺序错乱的问题，同时，既然下标从1开始，那么申请数组的时候也要多申请一个 第二个问题，数组初始化为-1时，不能简单地int a[5] = { -1 }，这样的话，只有第一个元素会被赋值成-1，后面的都是0，好在我的point数组只有6个，可以直接6个-1，不然的话就用memset(point, -1, sizeof(point))。 还有问题就是，如果一个人多次提交满分，但完美解决问题数不能多加，这个只需要加上if (_point &lt;= tmp) continue;即可解决 最后的问题，就是如果一个人提交了，但没通过，那么输出时，就不能是负号，应该是0，我在加了判断后，确实可以表示0了，但有个问题，就是如果一个人他已经有分数了，然后又提交时没有通过，这时候不能用0覆盖掉原有的分数，加个判断即可：if(stu[_id].point[_quest] == -1) stu[_id].point[_quest] = 0; A1083 List Grades#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;struct stuInfo{ string name; string id; int grade; stuInfo(string _name, string _id, int _grade) : name(_name), id(_id), grade(_grade) {}};bool comp(stuInfo&amp; s1, stuInfo&amp; s2){ return s1.grade &gt; s2.grade;}int main(){ int N;//学生数 cin &gt;&gt; N; vector&lt;stuInfo&gt; stu; //读取数据 while (N--) { string _name, _id; int _grade; cin &gt;&gt; _name &gt;&gt; _id &gt;&gt; _grade; stu.emplace_back(stuInfo(_name, _id, _grade)); } //排序 sort(stu.begin(), stu.end(), comp); //筛选 int grade1, grade2; int cnt = 0; cin &gt;&gt; grade1 &gt;&gt; grade2; for (auto s : stu) { if (s.grade &gt;= grade1 &amp;&amp; s.grade &lt;= grade2) { cout &lt;&lt; s.name &lt;&lt; ' ' &lt;&lt; s.id &lt;&lt; endl; cnt++; } } if (cnt == 0) cout &lt;&lt; \"NONE\";}    这道题so ez，但即使so ez也没一遍过，先是报错，忘记读取N了，接着是多打印了成绩，只用打印人的姓名和id即可。" }, { "title": "GAMES101-Lecture 05 Rasterization 1 (Triangles) & 作业1", "url": "/posts/GAMES101-Lecture-05-Rasterization-1-(Triangles)-&-%E4%BD%9C%E4%B8%9A1/", "categories": "Computer Graphics, GAMES101", "tags": "图形学, 学习笔记", "date": "2022-07-29 13:46:00 +0000", "snippet": "Transformation这一节其实是沿着上一节的viewing讲剩下的一小部分，然后开了个光栅化的头Perspective Projection aspect ratio = width/height宽高比(r就是right，t就是top)\\[aspect=\\frac{r}{t}\\] field-of-view(fovY)垂直可视角度(t就是top，n就是near...", "content": "Transformation这一节其实是沿着上一节的viewing讲剩下的一小部分，然后开了个光栅化的头Perspective Projection aspect ratio = width/height宽高比(r就是right，t就是top)\\[aspect=\\frac{r}{t}\\] field-of-view(fovY)垂直可视角度(t就是top，n就是near，因为朝-z方向，所以取个绝对值)\\[\\tan\\frac{fovY}{2} = \\frac{t}{\\lvert n \\rvert}\\] mvp变换 Canonical Cube to Screen 屏幕 像素的二维数组 数组的大小就是分辨率 典型的光栅显示 变换xy平面：$[-1,1]^2到[0,width]\\times[0,height]$ 视口变换：先缩放（因为l到r是-1到1，所以缩放需要缩成$(-\\frac{width}{2},\\frac{width}{2})$），再把中心从原点移到$(\\frac{width}{2},\\frac{height}{2})$，这样，原点就在左下角了\\[M_{viewport}=\\left(\\begin{matrix}\\frac{width}{2} &amp; 0 &amp; 0 &amp; \\frac{width}{2}\\\\0 &amp; \\frac{height}{2} &amp; 0 &amp; \\frac{height}{2}\\\\0 &amp; 0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1\\end{matrix}\\right)\\] Frame Buffer: Memory for a Raster Display 图像会存在显存中的不同区域中，告诉显示器显示哪一副图LCD(Liquid Crystal Display) Pixel(液晶显示)LED Array Display 发光二极管Triangles-Fundamental Shape Primitives 三角形： 最基础的多边形 其他多边形可以拆成三角形 独特的性质： 一定是平面 三角形内外定义清晰 便于渐变 Sampling 判断像素的中心是否在三角形内 for(int x = 0; x &lt; xmax; ++x) for(int y = 0; y &lt; ymax; ++y) image[x][y] = inside(tri, x+0.5, y+0.5); 已知Q点和三角形$P_0P_1P_2$，分成三个向量：$\\vec{P_0P_1}$、$\\vec{P_1P_2}$、$\\vec{P_2P_0}$，分别和$\\vec{P_0Q}$、$\\vec{P_1Q}$、$\\vec{P_2Q}$做叉积，如果得到的向量方向一致，说明点Q在三条边的同侧（如都在边的左侧），那么就在三角形内，否则（一旦出现叉积结果方向不一致），就说明在三角形外。 边界情况：要么不做处理，要么特殊处理。 使用包围盒检测三角形附近的点，也就是三个点x的最大最小，y的最大最小 使用每一行的最小最大值进行检测，适合细长且倾斜的三角形 Aliasing走样：Jaggies锯齿 作业1 任务描述：本次作业的任务是填写一个旋转矩阵和一个透视投影矩阵。给定三维下三个 点 v0(2.0, 0.0, −2.0), v1(0.0, 2.0, −2.0), v2(−2.0, 0.0, −2.0), 你需要将这三个点的坐 标变换为屏幕坐标并在屏幕上绘制出对应的线框三角形 (在代码框架中，我们已 经提供了 draw_triangle 函数，所以你只需要去构建变换矩阵即可)。 环境构建，其实就是添加Eigen库和Opencv的库 配置库查看这个博客：手把手教你games101环境搭建（图文并茂）——Visual Studio安装，Eigen库，Opencv配置_亭墨的博客-CSDN博客 还有就是为了避免每次做新的作业就要配一遍库，创建一个项目属性表：(vs2019+opencv环境配置，不用每次都设置属性目录_vs 每次都要配置包含目录_小明今天学习了吗的博客-CSDN博客 其实不难，就是写下模型矩阵（旋转矩阵）和透视投影矩阵，但我遇到了很多很多问题，最后不得已去搜索了，查出很多错，实在惭愧，先贴代码吧，之后写下注意事项 get_model_matrix函数： 这个函数其实就是绕Z轴旋转的矩阵，需要注意的是cos里面的参数是弧度值，要把度数转换成弧度值才行 Eigen::Matrix4f get_model_matrix(float rotation_angle){ Eigen::Matrix4f model = Eigen::Matrix4f::Identity(); // TODO: Implement this function // Create the model matrix for rotating the triangle around the Z axis. // Then return it. Eigen::Matrix4f translate; translate &lt;&lt; std::cos(rotation_angle / 180.0 * MY_PI), -std::sin(rotation_angle / 180.0 * MY_PI), 0.0, 0.0, std::sin(rotation_angle / 180.0 * MY_PI), std::cos(rotation_angle / 180.0 * MY_PI), 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0; model = translate * model; return model;} get_projection_matrix函数： 我在写这个函数的时候，漏洞百出。 首先，最最要命的错误就是矩阵公式不对，我记的笔记中，M1矩阵和M2矩阵的1记错位置了，这种问题真要我自己找根本找不到，这种错误太致命了。 其次是哪里出错呢，就是一些小地方，注释也都提到了，数行和列数错了，这种错误让我梦回中学时代。 还有就是，明明前面算cos的时候还记得弧度值，到后面算tan的时候就忘了。 Eigen::Matrix4f get_projection_matrix(float eye_fov, float aspect_ratio, float zNear, float zFar){ // Students will implement this function Eigen::Matrix4f projection = Eigen::Matrix4f::Identity(); // TODO: Implement this function // Create the projection matrix for the given parameters. // Then return it. Eigen::Matrix4f orthographicM1 = Eigen::Matrix4f::Zero(); Eigen::Matrix4f orthographicM2 = Eigen::Matrix4f::Identity(); Eigen::Matrix4f orthographic; Eigen::Matrix4f persp2ortho = Eigen::Matrix4f::Zero(); float t = std::abs(zNear) * tan(eye_fov / 2 / 180 * MY_PI);//没有转换成弧度值 float r = aspect_ratio * t; //M1: orthographicM1(0, 0) = 1 / r; //2 / r - l; orthographicM1(1, 1) = 1 / t; orthographicM1(2, 2) = 2 / std::abs(zNear - zFar);//一开始写成了1/... orthographicM1(3, 3) = 1.0;//这里一开始写成了3，2 //M2: //orthographicM2.topLeftCorner(3, 3).setIdentity();//这里一开始写成了setZero //orthographicM2(3, 3) = 1.0;//这里一开始写成了3，2 orthographicM2(2, 3) = -(zNear + zFar) / 2;//一开始写成了0，3 //persp2ortho: persp2ortho(0, 0) = zNear; persp2ortho(1, 1) = zNear; persp2ortho(3, 2) = 1.0;//一开始写成了2，3 persp2ortho(2, 2) = zNear + zFar; persp2ortho(2, 3) = -zNear * zFar; orthographic = orthographicM1 * orthographicM2; projection = orthographic * persp2ortho; return projection;} 结果： 有一个问题就是，在main函数中r.set_projection(get_projection_matrix(45, 1, -0.1, -50));，函数传入的zNear和zFar要改成-的，不然会显示反着。 有个问题我还是不太懂，就是view矩阵，他其实就是做了个平移，相当于是z减少了5。问题就是相机的初始位置到底在哪里呢？很奇怪，是（0,0）吗，相机的注视方向呢？是沿着Z轴吗？相机的头顶方向呢？其实只要矩阵写对了，就能看到三角形，也许这道作业就是为了让我们了解下model变换和透视投影变换吧，其他的问题可能会在后面解决吧。 作业1重做版 20023.5.14 先说总结，这次跟上次有相似的地方也有不同的地方，但总的来说比上次更加理解了，没想到时隔数月还是又回来学games101了 其实代码大差不差，上代码。model矩阵就是用来旋转模型，其实就是控制三角形旋转的矩阵啦，记得要将度数转成弧度，这边记得，下边的tan又又又忘了转换，不过问题不大，没转的话只是相当于eye_fov数字变大了，三角形看起来变小了一点 Eigen::Matrix4f get_model_matrix(float rotation_angle){ Eigen::Matrix4f model = Eigen::Matrix4f::Identity(); model(0, 0) = cos(rotation_angle/180.f* MY_PI); model(0, 1) = -sin(rotation_angle / 180.f * MY_PI); model(1, 0) = sin(rotation_angle / 180.f * MY_PI); model(1, 1) = cos(rotation_angle / 180.f * MY_PI); return model;} Eigen::Matrix4f get_projection_matrix(float eye_fov, float aspect_ratio, float zNear, float zFar){ //aspect_ratio = r / t; //tan(eye_fov)/2 = t/|n|; Eigen::Matrix4f projection = Eigen::Matrix4f::Identity(); float t = tan(eye_fov / 2 /180.f *MY_PI) * abs(zNear); float b = -t; float r = aspect_ratio * t; float l = -r; Eigen::Matrix4f m1 = Eigen::Matrix4f::Identity();//缩放矩阵 Eigen::Matrix4f m2 = Eigen::Matrix4f::Identity();//平移矩阵 m1(0, 0) = 2.f / (r - l); m1(1, 1) = 2.f / (t - b); m1(2, 2) = 2.f / (zNear - zFar); m2(0, 3) = -(r + l) / 2.f; m2(1, 3) = -(t + b) / 2.f; m2(2, 3) = -(zNear + zFar) / 2.f; Eigen::Matrix4f Mortho = m1 * m2;//正交矩阵 //平截头体压缩至长方体矩阵 Eigen::Matrix4f Mpersp2ortho; Mpersp2ortho &lt;&lt; zNear, 0.f, 0.f, 0.f, 0.f, zNear, 0.f, 0.f, 0.f, 0.f, zNear + zFar, -zNear * zFar, 0.f, 0.f, 1.f, 0.f; projection = Mortho * Mpersp2ortho; return projection;} 下面放两种tan的对比图 在main中设置zNear和zFar是正数（r.set_projection(get_projection_matrix(45, 1, 0.1, 50));），所以是倒三角，因为在projection矩阵中的m1矩阵（缩放矩阵）的第三行第三列也就是m1(2, 2)，因为zNear和zFar是正数且前者更小，所以总的结果是负数也就是说缩放的时候直接翻转了，只要把main函数中的设置投影矩阵函数的参数改为负数即可：r.set_projection(get_projection_matrix(45, 1, -0.1, -50)); 详细说一下反转，在看了《GAMES101》作业框架问题详解 - 知乎 (zhihu.com)这篇博客后我有了点自己的理解，为什么z轴反转了三角形就倒过来了，我猜测是z轴翻转后，为了遵循坐标系的原则，导致x和y轴也转了一下。 如果三角形落在了摄像机后面也相当于z轴翻转了一下，跟上面一样 总之这个东西怪怪的，我觉得不用再深究了，后面遇到问题再处理，我认为我的猜想目前来看还是站得住脚的 接下来是提高部分，直接套课上讲的Rodrigues’ Rotation Formula公式即可，需要注意的是矩阵是4*4的，因为需要齐次坐标，代码如下： Eigen::Matrix4f get_rotation(Eigen::Vector4f axis, float angle){ Eigen::Matrix4f RotationMatrix; Eigen::Matrix4f IdentityMarix = Eigen::Matrix4f::Identity(); Eigen::Matrix4f ProductMatrix; ProductMatrix &lt;&lt; 0.f, -axis[2], axis[1], 0.f, axis[2], 0.f, -axis[0], 0.f, -axis[1], axis[0], 0.f, 0.f, 0.f, 0.f, 0.f, 1.f; RotationMatrix = cos(angle / 180 * MY_PI) * IdentityMarix + (1 - cos(angle / 180 * MY_PI)) * axis * axis.transpose() + sin(angle / 180 * MY_PI) * ProductMatrix; return RotationMatrix;} 那么如何调用呢？首先在main函数开头声明旋转轴和角度： float angle2 = 0; Eigen::Vector4f RotationAxis(1.f,0.f,0.f,0.f);//x轴 接着是修改while循环中的r.set_model函数，为什么修改这个呢，因为set_model就是设置模型的位置矩阵（旋转平移），那么只要将我们的旋转矩阵相乘这个矩阵就相当于设置了模型的矩阵。修改后的函数为：r.set_model(get_rotation(RotationAxis, angle2)*get_model_matrix(angle)); 下面是旋转的情况(绕x轴，因为三角形的z坐标是-2，所以转的时候不是沿着三角形的最下面一条边转的)：" }, { "title": "PAT-Are They Equal & A+B in Hogwarts", "url": "/posts/PAT-Are-They-Equal-&-A+B-in-Hogwarts/", "categories": "算法刷题, PAT", "tags": "数学", "date": "2022-07-27 15:11:00 +0000", "snippet": "A1060 Are They Equal//考虑前导0，整数部分、小数部分#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;//将输入的数字转换成科学计数法的数字void format(string &amp;num, int N){ int e = 0;//记录指数 //首先判断先导0，并删除先导...", "content": "A1060 Are They Equal//考虑前导0，整数部分、小数部分#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;//将输入的数字转换成科学计数法的数字void format(string &amp;num, int N){ int e = 0;//记录指数 //首先判断先导0，并删除先导0 while(num.size() &gt; 0 &amp;&amp; num[0] == '0') { num.erase(num.cbegin());//删掉第一位0 } //删完先导0后，分为有小数点和没小数点的数 if(num.find('.') == string::npos)//如果没有小数点 { e = num.size(); } else//有小数点，要么是123.456这样的数，要么是.123456 { int pos = num.find('.'); if(pos &gt; 0)//如果小数点左边有数，就像第一种情况 { e = pos; num.erase(num.cbegin() + pos);//删除小数点 } else//如果小数点左边啥也没有 { num.erase(num.cbegin());//删掉小数点 //统计先导0，删除并记录更新e while(num.size() &gt; 0 &amp;&amp; num[0] == '0') { num.erase(num.cbegin());//删掉0 e--; } //如果num给删空了，说明是.000000这样的数 if(num.size() == 0) e = 0; } } //以上已经把num的有效位抽出来了，把先导0、小数点已经删除了 //接下来就是取前N位，不够的补0 if(num.size() &gt; N)//说明当前有效位够了，取子串即可 { num = num.substr(0, N); } else//需要补0 { //需要补N - num.size()个0 int add0 = N - num.size(); for(int i = 0; i &lt; add0; i++) { num.push_back('0'); } } //更新为转换后的字符串 num = \"0.\" + num + \"*10^\" + to_string(e);}int main(){ //读入数据 int N; string A, B; cin&gt;&gt;N&gt;&gt;A&gt;&gt;B; //转换成科学记数法 format(A, N); format(B, N); if(A == B) { cout&lt;&lt;\"YES \"&lt;&lt;A; } else { cout&lt;&lt;\"NO \"&lt;&lt;A&lt;&lt;' '&lt;&lt;B; }}    这道题有一定的难度，需要考虑的情况比较多，整体思路就是将读入的数字转换成科学计数法的数字，再做比较，转换过程中直接对原字符串进行修改。    开始有一半的错，是因为打印”NO”，我写成了”No”，改过来后，只有最后一个点没过，原因是补0的问题，在测5 0 00.0这个数据时，发现打印的是0.000，少打了2个0，这才锁定了问题的位置，然后发现，一开始我的补0是这么写的： //需要补N - num.size()个0 for(int i = 0; i N - num.size(); i++) { num.push_back('0'); }    这就是问题所在，每次补0后，num.size()是会变大的，所以才会少0！这个问题其实以前也出过，没想到现在还会犯这种错误，真是不应该。所以以后要注意循环时的界。A1058 A+B in Hogwarts#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int main(){ long long ag,as,ak,bg,bs,bk; scanf(\"%lld.%lld.%lld %lld.%lld.%lld\", &amp;ag, &amp;as, &amp;ak, &amp;bg, &amp;bs, &amp;bk); long long sum = (ag + bg) * (29 * 17) + (as + bs) * 29 + (ak + bk); printf(\"%lld.%lld.%lld\", sum / (29 * 17), sum % (29 * 17) / 29, sum % 29);}    这道题目其实挺简单的，但被我给弄复杂了。    首先，用scanf读取会更方便；    其次，要使用long long 不然会有测试点溢出。" }, { "title": "GAMES101-Lecture 04 Transformation Cont. & 作业0", "url": "/posts/GAMES101-Lecture-04-Transformation-Cont/", "categories": "Computer Graphics, GAMES101", "tags": "图形学, 学习笔记", "date": "2022-07-25 14:09:00 +0000", "snippet": "这一节其实是一部分变换的内容和观测(Viewing)的内容，按理说变换应该放到上一章，所有的观测放在一章3D Transforms 再一次使用齐次坐标 3D point =$ (x,y,z,1)^T$ 3D vector =$ (x,y,z,0)^T$ 使用4×4的矩阵表示仿射变换 \\[\\left(\\begin{matrix}x\\prim...", "content": "这一节其实是一部分变换的内容和观测(Viewing)的内容，按理说变换应该放到上一章，所有的观测放在一章3D Transforms 再一次使用齐次坐标 3D point =$ (x,y,z,1)^T$ 3D vector =$ (x,y,z,0)^T$ 使用4×4的矩阵表示仿射变换 \\[\\left(\\begin{matrix}x\\prime\\\\y\\prime\\\\z\\prime\\\\1\\end{matrix}\\right)=\\left(\\begin{matrix}a &amp; b &amp; c &amp; t_x\\\\d &amp; e &amp; f &amp; t_y\\\\g &amp; h &amp; i &amp; t_z\\\\0 &amp; 0 &amp; 0 &amp; 1\\end{matrix}\\right)\\cdot\\left(\\begin{matrix}x\\\\y\\\\z\\\\1\\end{matrix}\\right)\\] 是先做的旋转再做的平移3D Transformations Rotation: 绕x轴旋转，x坐标是不变的\\[R_x(\\alpha)=\\left(\\begin{matrix}1 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; \\cos\\alpha &amp; -\\sin\\alpha &amp; 0\\\\0 &amp; \\sin\\alpha &amp; \\cos\\alpha &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1\\end{matrix}\\right)\\] 绕y轴旋转，y轴有所不同，是因为$z\\times x$得到Y轴，而不是$x\\times z$得到Y轴，如果是$x\\times z$得到Y轴，那么矩阵内元素应该和其他一样，不会反。\\[R_x(\\alpha)=\\left(\\begin{matrix}\\cos\\alpha &amp; 0 &amp; \\sin\\alpha &amp; 0\\\\0 &amp; 1 &amp; 0 &amp; 0\\\\-\\sin\\alpha &amp; 0 &amp; \\cos\\alpha &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1\\end{matrix}\\right)\\] 绕z轴旋转\\[R_x(\\alpha)=\\left(\\begin{matrix}\\cos\\alpha &amp; -\\sin\\alpha &amp; 0 &amp; 0\\\\\\sin\\alpha &amp; \\cos\\alpha &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1\\end{matrix}\\right)\\] 3D Rotation 将旋转分解为三个轴方向的旋转，这三个角称为欧拉角\\[R_{xyz}(\\alpha,\\beta,\\gamma)=R_x(\\alpha)R_y(\\beta)R_z(\\gamma)\\] Rodrigues’ Rotation Formula(这个公式并没有讲推导，应该是直接用):默认n向量是过原点的，沿着n向量旋转α角度，后面那个矩阵是指：通过矩阵的方式计算叉乘。想绕任意n向量，就需要借助平移来实现。\\[R(\\pmb{n},\\alpha) = cos(\\alpha)\\pmb{I}+(1-\\cos(\\alpha))\\pmb{nn^T}+\\sin(\\alpha)\\left(\\begin{matrix}0 &amp; -n_z &amp; n_y\\\\n_z &amp; 0 &amp; -n_x\\\\-n_y &amp; n_x &amp; 0\\end{matrix}\\right)\\] 由于矩阵难以插值，提出了四元数来解决（具体没讲） Viewing transformation(观测变换) 模型变换-&gt;视图变换-&gt;投影变换（简称MVP变换） 先摆好模型的位置方向，再摆好摄像机的位置和方向，最后把摄像机和模型同时移动，将相机放在原点，注视方向是-z，向上方向为y，进行投影变换（后续还有一个视口变换）View/ Camera Transformation 定义相机： 位置:$\\vec{e}$ 注视方向:$\\hat{g}$ 向上方向:$\\hat{t}$ 重要的观测： 将相机放在原点，注视方向是-z，向上方向为y 先平移，再旋转$M_{view}=R_{view}T_{view}$ 平移矩阵比较简单就不写了，旋转矩阵不直接旋转相机，而是先求世界坐标系旋转到相机的旋转矩阵，然后再求一个逆。也就是将X轴旋转到（g×t），Y轴旋转到t，Z轴旋转到-g。 下面矩阵里的元素是相机坐标系的基向量\\[R_{view}^{-1}=\\left[\\begin{matrix}x_{\\hat{g}\\times\\hat{t}} &amp; x_t &amp; x_{-g} &amp; 0\\\\y_{\\hat{g}\\times\\hat{t}} &amp; y_t &amp; y_{-g} &amp; 0\\\\z_{\\hat{g}\\times\\hat{t}} &amp; z_t &amp; z_{-g} &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1\\end{matrix}\\right]\\RightarrowR_{view}=\\left[\\begin{matrix}x_{\\hat{g}\\times\\hat{t}} &amp; y_{\\hat{g}\\times\\hat{t}} &amp; z_{\\hat{g}\\times\\hat{t}} &amp; 0\\\\x_t &amp; y_t &amp; z_t &amp; 0\\\\x_{-g} &amp; y_{-g} &amp; z_{-g} &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1\\end{matrix}\\right]\\] 那么怎么理解呢，可以假设旋转矩阵乘以一个列向量$(1,0,0)^T$，也就是x轴的单位向量，结果是$(x{\\hat{g}\\times\\hat{t}},y_{\\hat{g}\\times\\hat{t}},z_{\\hat{g}\\times\\hat{t}})^T$ Projection transformation 正交投影和透视投影Orthographic Projection 因为是看向-z方向，所以f小于n 将长方体$[l,r]\\times[b,t]\\times[\\pmb{f,n}]$平移到原点，再缩放成canonical标准正方体$[-1,1]^3$缩放长宽高至2（因为是-1到1），下面是平移和缩放的矩阵：\\[M_{ortho}=\\left[\\begin{matrix}\\frac{2}{r-l} &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; \\frac{2}{t-b} &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; \\frac{2}{n-f} &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1\\end{matrix}\\right]\\left[\\begin{matrix}1 &amp; 0 &amp; 0 &amp; -\\frac{r+l}{2}\\\\0 &amp; 1 &amp; 0 &amp; -\\frac{t+b}{2}\\\\0 &amp; 0 &amp; 1 &amp; -\\frac{n+f}{2}\\\\0 &amp; 0 &amp; 0 &amp; 1\\end{matrix}\\right]\\] 这次变换确实会引起原来物体的拉伸但最后还有一个视口变换会再次拉伸 Perspective Projection 先把平截头体（frustum）挤成长方体，然后再做一次正交投影 规定：1. 近平面永远不变2. 近平面和远平面z不会变化3. 远平面的中心点不变 $y\\prime=\\frac{n}{z}y$ ，$x\\prime=\\frac{n}{z}x$（$x\\prime,y\\prime指远平面变换后的坐标$） 其实z是一个变量，不同的z代表不同远近的点，z也可以等于n，这样的话变换后的坐标还是原来的那个坐标 那么现在就是说需要一个矩阵乘以坐标后能够成为：\\[M_{persp\\rightarrow ortho}^{(4\\times 4)}\\left(\\begin{matrix}x\\\\y\\\\z\\\\1\\end{matrix}\\right)\\Rightarrow\\left(\\begin{matrix}\\frac{nx}{z}\\\\\\frac{ny}{z}\\\\unknown\\\\1\\end{matrix}\\right)==\\left(\\begin{matrix}nx\\\\ny\\\\still unknown\\\\z\\end{matrix}\\right)\\] 然后可以推导出部分矩阵\\[M_{persp\\rightarrow ortho}^{(4\\times 4)}=\\left[\\begin{matrix}n &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; n &amp; 0 &amp; 0\\\\? &amp; ? &amp; ? &amp; ?\\\\0 &amp; 0 &amp; 1 &amp; 0\\end{matrix}\\right]\\] 观察： 近平面任何点都不变，也就是说$(x,y,n)$经过$M_{persp\\rightarrow ortho}^{(4\\times 4)}$变换后，还是$(x,y,n)$这个点 远平面z都不变，也就是说远平面中心点$(0,0,f)$经过$M_{persp\\rightarrow ortho}^{(4\\times 4)}$变换后也不变 把近平面的点代到公式中，即让z=n，那么\\[\\left(\\begin{matrix}x\\\\y\\\\n\\\\1\\end{matrix}\\right)==\\left(\\begin{matrix}nx\\\\ny\\\\n^2\\\\n\\end{matrix}\\right)\\] 所以$M_{persp\\rightarrow ortho}^{(4\\times 4)}$的第三行(0 0 A B) \\[\\left( \\begin{matrix} 0 &amp; 0 &amp; A &amp; B \\end{matrix} \\right)\\left( \\begin{matrix} x\\\\ y\\\\ n\\\\ 1 \\end{matrix} \\right) = n^2\\] 取远平面的中心点(0,0,f)，代到公式中\\[\\left(\\begin{matrix}0\\\\0\\\\f\\\\1\\end{matrix}\\right)==\\left(\\begin{matrix}0\\\\0\\\\f^2\\\\f\\end{matrix}\\right)\\] 那么得到两个式子：\\[An + B = n^2\\\\Af + B = f^2\\] 解出\\[A=n+f\\\\B=-nf\\] 最后，终于解出了矩阵$M_{persp\\rightarrow ortho}^{(4\\times 4)}$ \\[M_{persp\\rightarrow ortho}^{(4\\times 4)}=\\left[\\begin{matrix}n &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; n &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; n+f &amp; -nf\\\\0 &amp; 0 &amp; 1 &amp; 0\\end{matrix}\\right]\\] 那么，透视投影矩阵：\\[M_{persp}=M_{ortho}M_{persp\\rightarrow ortho}\\] 作业0 作业描述：给定一个点 P=(2,1), 将该点绕原点先逆时针旋转 45◦，再平移 (1,2), 计算出 变换后点的坐标（要求用齐次坐标进行计算）。 先配置环境，我没有按照文档里的使用虚拟机，直接给我vs2022安装Eigen库了，很简单，参考博客：Eigen库下载安装并配置到VS_勤勉的一只洋的博客-CSDN博客_eigen库下载 配置完后，可以先读读Eigen的官方文档:Eigen: Matrix and vector arithmetic 然后可以把框架里没有的代码试着补全（和、乘、点积、叉积等）： #include&lt;cmath&gt;#include&lt;Eigen/Core&gt;#include&lt;Eigen/Dense&gt;#include&lt;iostream&gt; int main(){ // Basic Example of cpp std::cout &lt;&lt; \"Example of cpp \\n\"; float a = 1.0, b = 2.0; std::cout &lt;&lt; a &lt;&lt; std::endl; std::cout &lt;&lt; a / b &lt;&lt; std::endl; std::cout &lt;&lt; std::sqrt(b) &lt;&lt; std::endl; std::cout &lt;&lt; std::acos(-1) &lt;&lt; std::endl; std::cout &lt;&lt; std::sin(30.0 / 180.0 * acos(-1)) &lt;&lt; std::endl; // Example of vector std::cout &lt;&lt; \"Example of vector \\n\"; // vector definition Eigen::Vector3f v(1.0f, 2.0f, 3.0f); Eigen::Vector3f w(1.0f, 0.0f, 0.0f); // vector output std::cout &lt;&lt; \"Example of output \\n\"; std::cout &lt;&lt; v &lt;&lt; std::endl; // vector add std::cout &lt;&lt; \"Example of add \\n\"; std::cout &lt;&lt; v + w &lt;&lt; std::endl; // vector scalar multiply std::cout &lt;&lt; \"Example of scalar multiply \\n\"; std::cout &lt;&lt; v * 3.0f &lt;&lt; std::endl; std::cout &lt;&lt; 2.0f * v &lt;&lt; std::endl; // Example of matrix std::cout &lt;&lt; \"Example of matrix \\n\"; // matrix definition Eigen::Matrix3f i, j; i &lt;&lt; 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0; j &lt;&lt; 2.0, 3.0, 1.0, 4.0, 6.0, 5.0, 9.0, 7.0, 8.0; // matrix output std::cout &lt;&lt; \"Example of output \\n\"; std::cout &lt;&lt; i &lt;&lt; std::endl; // matrix add i + j std::cout &lt;&lt; i + j &lt;&lt; std::endl; // matrix scalar multiply i * 2.0 std::cout &lt;&lt; i * 2.0 &lt;&lt; std::endl; // matrix multiply i * j std::cout &lt;&lt; i * j &lt;&lt; std::endl; // matrix multiply vector i * v std::cout &lt;&lt; i * v &lt;&lt; std::endl; //dot product std::cout &lt;&lt; v.dot(w) &lt;&lt; std::endl; //cross product std::cout &lt;&lt; v.cross(w) &lt;&lt; std::endl; } 在最后实现了题目： //P点 Eigen::Vector3f P(2.0, 1.0, 1.0); //变换矩阵 Eigen::Matrix3f transform; //可以直接写一个矩阵，因为先旋转再平移 transform &lt;&lt; std::cos(45.0 / 180.0 * acos(-1)), -std::sin(45.0 / 180.0 * acos(-1)), 1.0, std::sin(45.0 / 180.0 * acos(-1)), std::cos(45.0 / 180.0 * acos(-1)), 2.0, 0.0, 0.0, 1.0; //变换后的点： Eigen::Vector3f Pprime; Pprime = transform * P; std::cout &lt;&lt; Pprime; 答案：\\[P\\prime=\\left(\\begin{matrix}1.70711\\\\4.12132\\\\1\\end{matrix}\\right)\\] " }, { "title": "PAT-The Black Hole of Numbers & Finding Average & C++字符串转换为数值", "url": "/posts/PAT-The-Black-Hole-of-Numbers-&-Finding-Average-&-C++%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B0%E5%80%BC/", "categories": "算法刷题, PAT", "tags": "数学", "date": "2022-07-24 06:52:00 +0000", "snippet": "A1069 The Black Hole of Numbers#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;bool cmp(char &amp;a, char &amp...", "content": "A1069 The Black Hole of Numbers#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;bool cmp(char &amp;a, char &amp;b){ return a &gt; b;}int main(){ string curNum;//记录当前数字 cin&gt;&gt;curNum; while(1) { while(curNum.size() &lt; 4) { curNum = \"0\" + curNum; } //开始做减法 sort(curNum.begin(), curNum.end(), cmp); int a = stoi(curNum); sort(curNum.begin(), curNum.end());//升序 int b = stoi(curNum); int c = a - b;//算差 if(c == 0) { printf(\"%04d - %04d = 0000\\n\", stoi(curNum), stoi(curNum)); break; } else { printf(\"%04d - %04d = %04d\\n\", a, b, c); } //判断是不是=6174 if(c == 6174) break; curNum = to_string(c);//更新当前数字 }}    这道题虽然是个数学，但也是个模拟，也就是说，题目说是四位数，那么在运算，也就是排序的时候也要按四位数来，不满四位就补0，不然排序后的数是不对的。C++字符串转换为数值A1108 Finding Average#include&lt;iostream&gt;#include&lt;sstream&gt;using namespace std;bool isValid(string &amp;str){ //如果输入的字符串中，包含英文、包含多个小数点、精度大于2，都是非法的 int i = 0; //如果第一位是-号 if(str[0] == '-') i++; //如果除去-号，第一位还是符号而且不是.，那么返回false if(!isdigit(str[i]) &amp;&amp; str[i] != '.')return false; //先遍历整数部分 for(; i &lt; str.size(); i++) { if(str[i] == '.') { i++; break;//遇到第一个点就中止 } if(!isdigit(str[i])) return false;//如果遇到的不是点而是其他非数字 } //遍历小数部分 int remainder = str.size() - i;//小数点后面的位数 if(remainder &gt; 2) return false;//如果小数点后面超过两位 for(; i &lt; str.size(); i++) { if(!isdigit(str[i])) return false; } return true;}int main(){ int N; cin&gt;&gt;N; int cnt = 0; double sum = 0; while(N--) { string str; cin&gt;&gt;str; if(isValid(str) &amp;&amp; stod(str) &gt;= -1000 &amp;&amp; stod(str) &lt;= 1000) { sum += stod(str); cnt++; } else { cout&lt;&lt;\"ERROR: \"&lt;&lt;str&lt;&lt;\" is not a legal number\"&lt;&lt;endl; } } if(cnt == 0) { cout&lt;&lt;\"The average of 0 numbers is Undefined\"; } else if(cnt == 1) { printf(\"The average of 1 number is %.2lf\", sum); } else { printf(\"The average of %d numbers is %.2lf\", cnt, sum/cnt); }}    这道题太搞人了哈哈哈哈，刚开始有半测试点过不去，是因为考虑的情况太少，只考虑了的字符串中，包含英文、包含多个小数点的情况，其他情况没考虑到，后面又改了改isValid的函数，但始终有一个点过不去，我去查了查，才知道，当只有一个number的时候，不能打印1 numbers，不然会报错，好家伙，这真的只是考验代码水平的吗233333。    还有一个要注意的是，在算精度超过2位的情况时，5给我判断成超过两位了，debug了之后发现if(str.size() - i &gt; 2) return false;这么写竟然会返回false，明明str.size() - i = -1，后来单独先赋给一个变量，再用变量去做比较，就比较对了，很怪。    我又去debug了一下，发现了，因为str.size()的数据类型是unsigned long long，str.size() - i默认的数据类型是无符号longlong型，所以-1其实是18446744073709551615，怪不得会误判。" }, { "title": "GAMES101-Lecture 03 Transformation", "url": "/posts/GAMES101-Lecture-03-Transformation/", "categories": "Computer Graphics, GAMES101", "tags": "图形学, 学习笔记", "date": "2022-07-23 14:20:00 +0000", "snippet": "TransformationScale\\[\\left[\\begin{matrix}x\\prime\\\\y\\prime\\end{matrix}\\right]=\\left[\\begin{matrix}s_x &amp; 0\\\\0 &amp; s_y\\end{matrix}\\right]\\left[\\begin{matrix}x\\\\y\\end{matrix}\\right]\\]Reflection M...", "content": "TransformationScale\\[\\left[\\begin{matrix}x\\prime\\\\y\\prime\\end{matrix}\\right]=\\left[\\begin{matrix}s_x &amp; 0\\\\0 &amp; s_y\\end{matrix}\\right]\\left[\\begin{matrix}x\\\\y\\end{matrix}\\right]\\]Reflection Matrix 沿y轴翻转\\[\\left[\\begin{matrix}x\\prime\\\\y\\prime\\end{matrix}\\right]=\\left[\\begin{matrix}-1 &amp; 0\\\\0 &amp; 1\\end{matrix}\\right]\\left[\\begin{matrix}x\\\\y\\end{matrix}\\right]\\]Shear Matrix 水平剪切，水平方向上都移动了a×y\\[\\left[\\begin{matrix}x\\prime\\\\y\\prime\\end{matrix}\\right]=\\left[\\begin{matrix}1 &amp; a\\\\0 &amp; 1\\end{matrix}\\right]\\left[\\begin{matrix}x\\\\y\\end{matrix}\\right]\\]Rotate(about (0,0)，CCW by default) 绕原点旋转 默认逆时针旋转，可由特殊点推导出\\[R_\\theta=\\left[\\begin{matrix}\\cos\\theta &amp; -\\sin\\theta\\\\\\sin\\theta &amp; \\cos\\theta\\end{matrix}\\right]\\] 用一个正方形的两个点来算就能很快算出这个旋转矩阵（1，0）和（0，1）Linear Transforms = Matrices(same dimension) 变换都可以写成线性变换\\[\\left[\\begin{matrix}x\\prime\\\\y\\prime\\end{matrix}\\right]=\\left[\\begin{matrix}a &amp; b\\\\c &amp; d\\end{matrix}\\right]\\left[\\begin{matrix}x\\\\y\\end{matrix}\\right]\\]\\[x\\prime=Mx\\]Transiation 平移变换不是线性变换，但我们不希望把平移变换当成一个特殊的变换 引入齐次坐标Homogenous Coordinates\\[\\left(\\begin{matrix}x\\prime\\\\y\\prime\\\\w\\prime\\end{matrix}\\right)=\\left(\\begin{matrix}1 &amp; 0 &amp; t_x\\\\0 &amp; 1 &amp; t_y\\\\0 &amp; 0 &amp; 1\\end{matrix}\\right)\\cdot\\left(\\begin{matrix}x\\\\y\\\\1\\end{matrix}\\right)=\\left(\\begin{matrix}x + t_x\\\\y + t_y\\\\1\\end{matrix}\\right)\\] 添加第三位坐标(向量是0，因为向量具有平移不变性) 2D point = $(x,y,1)^T$ 2D vector = $(x,y,0)^T$ 如果w坐标是1或者0，点和向量的运算也是有效的 vector + vector = vector（z还是0） point - point = vector（z = 1 - 1 = 0） point + vector = point（一个点沿着一个向量走，最后还是一个点） point + point = 这两个点的中点(因为第三位数1+1=2，最后的结果想转换成第三位是1需要x和y同时除以2)\\[\\left(\\begin{matrix}x\\\\y\\\\w\\end{matrix}\\right)就是2D点\\left(\\begin{matrix}\\frac{x}{w}\\\\\\frac{y}{w}\\\\1\\end{matrix}\\right),w\\neq0\\] Affine Transformations仿射变换 Affine map = linear map + translation（线性变化+平移） 仿射变换都可以转换为齐次坐标的形式 在表示二维情况下的仿射变换时，齐次坐标对应的最后一行才是(0,0,1)，其他情况下有其他的意义 Inverse Transform\\[M^-1\\]Composite Transform(复合变换) 矩阵没有交换律但有结合律 从右到左逐个应用矩阵Decomposing Complex Transforms 绕C点旋转：先平移，使C移到原点，旋转后，再移回去（C点可以是边缘的也可以是中心点） $T(c)\\cdot R(\\alpha)\\cdot T(-c)$ 3D Transforms 再一次使用齐次坐标 $3D point = (x,y,z,1)^T$ $3D vector = (x,y,z,0)^T$ 使用4×4的矩阵表示仿射变换 \\[\\left(\\begin{matrix}x\\prime\\\\y\\prime\\\\z\\prime\\\\1\\end{matrix}\\right)=\\left(\\begin{matrix}a &amp; b &amp; c &amp; t_x\\\\d &amp; e &amp; f &amp; t_y\\\\g &amp; h &amp; i &amp; t_z\\\\0 &amp; 0 &amp; 0 &amp; 1\\end{matrix}\\right)\\cdot\\left(\\begin{matrix}x\\\\y\\\\z\\\\1\\end{matrix}\\right)\\] 是先做的旋转再做的平移补充\\[R_\\theta=\\left(\\begin{matrix}\\cos\\theta &amp; -\\sin\\theta\\\\\\sin\\theta &amp; \\cos\\theta\\end{matrix}\\right)\\\\\\]\\[R_{-\\theta}=\\left(\\begin{matrix}\\cos\\theta &amp; \\sin\\theta\\\\-\\sin\\theta &amp; \\cos\\theta\\end{matrix}\\right)=R_\\theta^T\\\\\\]\\[R_\\theta^T=R_\\theta^{-1}\\] 旋转矩阵从定义的角度来看，旋转矩阵的逆矩阵（也就是旋转-$\\theta$角）与旋转矩阵的转置是相等的" }, { "title": "GAMES101-Lecture 02 Review of Linear Algebra", "url": "/posts/GAMES101-Lecture-02-Review-of-Linear-Algebra/", "categories": "Computer Graphics, GAMES101", "tags": "图形学, 学习笔记", "date": "2022-07-23 05:53:00 +0000", "snippet": "阅读材料：第 2 章（Miscellaneous Math）；第 5 章（Linear Algebra）1. Graphics’ Dependencies 基础数学：线代、微积分、统计 基础物理：光学、力学 其它：信号处理、数值分析 2. This Course More dependent on linear algebra ...", "content": "阅读材料：第 2 章（Miscellaneous Math）；第 5 章（Linear Algebra）1. Graphics’ Dependencies 基础数学：线代、微积分、统计 基础物理：光学、力学 其它：信号处理、数值分析 2. This Course More dependent on linear algebra 向量、矩阵 3. Vector 写作$\\vec{a}$或者a 表示方向和长度 没有绝对的开始位置 4. Vector Normalization 向量的模（长度）$\\lVert{\\vec{a}}\\rVert$ 单位向量：$\\hat{a}=\\frac{\\vec{a}}{\\lVert{\\vec{a}}\\rVert}$ 5. Vector Addion 平行四边形法则、三角形法则6. Cartesian Coordinates 向量默认是列向量 $A=\\left(\\begin{matrix}x\\y\\end{matrix}\\right)$7. Vector Multiplication 点乘 计算两个向量间距远近 分解向量 决定向量的前后 投影 投影可以用来计算一个向量平行与另一个向量和垂直于另一个向量的分向量 通过点成结果的正负来判断向量的前后，判断两个向量是不是相反的 叉乘 $\\vec{a}\\times \\vec{a}=\\vec{0}$ 右手坐标系：$\\vec{x}\\times\\vec{y}=+\\vec{z}$ 左手坐标系：$\\vec{x}\\times\\vec{y}=-\\vec{z}$(一些图形API用的左手系) 叉乘运算： 判定左右：假设向量a和b在xy平面上，向量a叉乘b，结果向量是正的（也就是说与Z轴同向），说明b在a的左侧 判定内外：有一个三角形ABC，和一个点P，判断P是否在ABC内，如果$\\vec{AB}\\times\\vec{AP}$和$\\vec{BC}\\times\\vec{BP}$和$\\vec{CA}\\times\\vec{CP}$的结果都是+或者-，那么就在三角形内。也可以说P点在三条边的左边或者右边 正交基和坐标系 8. Matrices 矩阵-矩阵相乘 两个矩阵A、B相乘得到C，如果要算C的某个元素，比如第二行第三列，那么就找A的第二行和B的第三列，做一个点积，就是该元素的结果 没有交换律但有结合律 矩阵-向量相乘 矩阵转置 $(AB)^T=B^TA^T$ 单位矩阵 定义了矩阵的逆 对角矩阵、逆矩阵 以矩阵形式的向量乘积 点积：$\\vec{a}\\cdot\\vec{b}=\\vec{a}^T\\vec{b}$ 叉积：$\\vec{a}\\times\\vec{b}=A^*b$(A是一个矩阵) " }, { "title": "PAT-First Contact & Cut Integer", "url": "/posts/PAT-First-Contact-&-Cut-Integer/", "categories": "算法刷题, PAT", "tags": "模拟, 数学", "date": "2022-07-21 06:52:00 +0000", "snippet": "A1139 First Contact#include&lt;iostream&gt;#include&lt;set&gt;#include&lt;utility&gt;#include&lt;unordered_map&gt;#include&lt;vector&gt;using namespace std;struct personInfo{ int gender;//1为男，0为...", "content": "A1139 First Contact#include&lt;iostream&gt;#include&lt;set&gt;#include&lt;utility&gt;#include&lt;unordered_map&gt;#include&lt;vector&gt;using namespace std;struct personInfo{ int gender;//1为男，0为女 string name; set&lt;string&gt; maleFri;//男性朋友 set&lt;string&gt; femaleFri;//女性朋友 //构造函数 personInfo(int _gender, string _name) : gender(_gender), name(_name) { }};int main(){ //读入数据 int N, M;//N个人，M行关系 cin &gt;&gt; N &gt;&gt; M; //通过名字映射结构体地址 unordered_map&lt;string, personInfo*&gt; name2Info; //读取关系 while (M--) { string p1, p2; cin &gt;&gt; p1 &gt;&gt; p2; if (!name2Info.count(p1))//如果没p1这个人 { name2Info[p1] = new personInfo(p1[0] == '-' ? 0 : 1, p1); } if (!name2Info.count(p2))//如果没p2这个人 { name2Info[p2] = new personInfo(p2[0] == '-' ? 0 : 1, p2); } //将对方加入自己的朋友中 if (p2[0] == '-')//p2是个妹子 { (name2Info[p1]-&gt;femaleFri).insert(p2); } else//p2是个汉子 { (name2Info[p1]-&gt;maleFri).insert(p2); } if (p1[0] == '-')//p1是个妹子 { (name2Info[p2]-&gt;femaleFri).insert(p1); } else//p1是个汉子 { (name2Info[p2]-&gt;maleFri).insert(p1); } } //处理询问 int K; cin &gt;&gt; K; while (K--) { int cnt = 0; string p1, p2; cin &gt;&gt; p1 &gt;&gt; p2; //如果p1或者p2并不存在于数据库中 if (!name2Info.count(p1) || !name2Info.count(p2)) { //最后一次的不换行 if (K == 0) cout &lt;&lt; 0; else cout &lt;&lt; 0 &lt;&lt; endl; continue; } vector&lt;pair&lt;string, string&gt; &gt; edge;//关系桥数组 edge.clear();//每次询问清空数组 set&lt;string&gt;&amp; p1Fri = name2Info[p1]-&gt;gender == 0 ? name2Info[p1]-&gt;femaleFri : name2Info[p1]-&gt;maleFri; set&lt;string&gt;&amp; p2Fri = name2Info[p2]-&gt;gender == 0 ? name2Info[p2]-&gt;femaleFri : name2Info[p2]-&gt;maleFri; for (auto&amp; _p1Fri : p1Fri)//name2Info[p1]-&gt;gender == 0 ? name2Info[p1]-&gt;femaleFri : name2Info[p1]-&gt;maleFri) { for (auto&amp; _p2Fri : p2Fri)//(name2Info[p2]-&gt;gender == 0 ? name2Info[p2]-&gt;femaleFri : name2Info[p2]-&gt;maleFri)) { //如果p1的朋友的朋友中有p2的这个朋友 if (name2Info[_p1Fri]-&gt;maleFri.count(_p2Fri) || name2Info[_p1Fri]-&gt;femaleFri.count(_p2Fri)) { string _p1FriName = _p1Fri[0] == '-' ? _p1Fri.substr(1) : _p1Fri; string _p2FriName = _p2Fri[0] == '-' ? _p2Fri.substr(1) : _p2Fri; //p1朋友的朋友不能是p1，也不能是表白对象p2(这个其实不用判断，因为p2Fri是p2的朋友，不可能是p2自己) //p1朋友不能是表白对象 if (_p2Fri != p1 &amp;&amp; _p1Fri != p2) { edge.emplace_back(make_pair(_p1FriName, _p2FriName)); cnt++; } } } } //打印所有的朋友桥 //如果最后一个是0，那么不换行 if (cnt == 0 &amp;&amp; K == 0) cout &lt;&lt; 0; else { cout &lt;&lt; cnt &lt;&lt; endl; for (int i = 0; i &lt; cnt; i++) { //如果是最后一个询问，而且是最后一组数据的话，就不换行 if (K == 0 &amp;&amp; i == cnt - 1) cout &lt;&lt; edge[i].first &lt;&lt; ' ' &lt;&lt; edge[i].second; else cout &lt;&lt; edge[i].first &lt;&lt; ' ' &lt;&lt; edge[i].second &lt;&lt; endl; } } }}    一开始运行是有报错的：Access violation reading location，这是因为在询问中的名字可能之前从来就没出现过，却依然去哈希表中去寻找了，那么自然就会说是访问违规阅读地点。    这道题开始只拿了24分，最后三个测试点没过去，还好有昵称五个字大佬的博客，他提到了注意事项：朋友的朋友不能是自己或者表白目标，朋友也不能是目标，这恰恰是最后三个测试点的特殊情况。还有就是我直接用了string来存名字，规避掉了他还提到的0000和-0000是代表不同的性别这个点。A1132 Cut Integer#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main(){ int N;//储存个数 cin&gt;&gt;N; while(N--) { string num; cin&gt;&gt;num; int len = num.size(); string numA = num.substr(0, len / 2); string numB = num.substr(len / 2); int Num = stoi(num); int NumA = stoi(numA); int NumB = stoi(numB); if(NumB == 0) { cout&lt;&lt;\"No\"; } else { if(Num % (NumA * NumB) == 0) { cout&lt;&lt;\"Yes\"; } else { cout&lt;&lt;\"No\"; } } if(N != 0) cout&lt;&lt;endl; }}    这道题很简单，但一开始也出错了。 首先是没考虑到拆分成两个数字后，第二个可能是0的情况，不过提交后，会提示浮点错误，所以还好解决 第二个错误是，我开始担心A*B会超过int的范围，所以就先num/A后再取余B，这样的操作对于一个num本身就可以被（A*B）整除的的来说无伤大雅，但可能会把不能被整除的给误判成Yes，因为int的取整机制。 " }, { "title": "GAMES101-Lecture 01 Overview of Computer Graphics", "url": "/posts/GAMES101-Lecture-01-Overview-of-Computer-Graphics/", "categories": "Computer Graphics, GAMES101", "tags": "图形学, 学习笔记", "date": "2022-07-20 03:40:00 +0000", "snippet": "1. What is Computer Graphics?    涉及到的领域： Video Game Movies Animations Design Visualization Virtual Reality Augumented Reality Digital Illstrati...", "content": "1. What is Computer Graphics?    涉及到的领域： Video Game Movies Animations Design Visualization Virtual Reality Augumented Reality Digital Illstration Simulation Graphical User Interface Typography 2. Why study Computer Graphics    其实就一个理由，因为炫酷吊炸天3. Course Topics Rasterization 光栅化 其实就是将几何图元转换为像素图元（我的理解） Curves and Meshes 曲线和曲面 Ray Tracing 效果好，但就是慢 Animation/Simulation 动画/模拟仿真 4. GAMES101 is NOT about 不教图形API，教的是原理 不教使用工具和引擎做建模或者游戏 不是计算机视觉（一切需要猜测的才是视觉，不是图形学） " }, { "title": "PAT-Dating & Group Photo & 判断字符是字母还是数字的函数", "url": "/posts/PAT-PAT-Dating-&-Group-Photo-&-%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E6%98%AF%E5%AD%97%E6%AF%8D%E8%BF%98%E6%98%AF%E6%95%B0%E5%AD%97%E7%9A%84%E5%87%BD%E6%95%B0/", "categories": "算法刷题, PAT", "tags": "模拟", "date": "2022-07-19 12:40:00 +0000", "snippet": "A1061 Dating#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;string&gt;using namespace std;string Day[7] = {\"MON\", \"TUE\", \"WED\", \"THU\", \"FRI\", \"SAT\", \"SUN\"};int main(...", "content": "A1061 Dating#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;string&gt;using namespace std;string Day[7] = {\"MON\", \"TUE\", \"WED\", \"THU\", \"FRI\", \"SAT\", \"SUN\"};int main(){ //读取四个字符串 string s1,s2,s3,s4; cin&gt;&gt;s1&gt;&gt;s2&gt;&gt;s3&gt;&gt;s4; //循环次数取两个字符串中短的那个 int loop1 = s1.size() &lt; s2.size() ? s1.size() : s2.size(); int loop2 = s3.size() &lt; s4.size() ? s3.size() : s4.size(); //开始比较： int flag = 1;//1代表还在查DAY，2代表正在查HOUR for(int i = 0; i &lt; loop1; i++) { //如果在对比的过程中发现了相同的字符 if(s1[i] == s2[i]) { //要打印Day if(flag == 1 &amp;&amp; s1[i] &gt;= 'A' &amp;&amp; s1[i] &lt;= 'G') { cout&lt;&lt;Day[s1[i] - 'A']&lt;&lt;' '; flag++; } else if(flag == 2)//打印HOUR { if(s1[i] &gt;= '0' &amp;&amp; s1[i] &lt;= '9') { printf(\"%02d:\", s1[i] - '0'); break; } else if(s1[i] &gt;= 'A' &amp;&amp; s1[i] &lt;= 'N') { cout&lt;&lt;s1[i] - 'A' + 10&lt;&lt;':'; break; } } } } //打印MINUTE for(int j = 0; j &lt; loop2; j++) { if(s3[j] == s4[j] &amp;&amp; isalpha(s3[j])) { printf(\"%02d\", j); } }}    这道题有两个难点： 首先就是题意，第一遍读题完全没看懂解码的原理，因为漏看了common这个单词，我把它译为了普通，但应该是相同，这样解释就合理了，当两个字符相同时，根据字符的情况来打印时间 第二个其实就是细节，要注意打印时间时都是打印两位，后面的分钟打印两位不容易忘记，是因为测试样例就是04，小时如果是10以内的话也要 打印0，不能直接打印字符，不然会有几个点过不去 判断字符是字母还是数字的函数字母（不区分大小写）：isalpha();大写字母：isupper();小写字母：islower();数字：isdigit();字母和数字：isalnum();转化为大写：toupper();转化为小写：tolower();A1109 Group Photo#include&lt;iostream&gt;#include&lt;utility&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;bool comp(pair&lt;string, int&gt;&amp; p1, pair&lt;string, int&gt;&amp; p2){ if (p1.second == p2.second)//如果身高相等，名字小的在前面 { return p1.first &lt; p2.first; } else//身高不一样的话，高的排前面 { return p1.second &gt; p2.second; }}int main(){ int N, K;//N个人，K行 vector&lt; pair&lt;string, int&gt;&gt; people;//每个人的姓名、身高信息 //读入数据 cin &gt;&gt; N &gt;&gt; K; int remainder = N % K;//人数除以行数的余数，代表最后一行要多站的人 int rowNum = N / K;//除了最后一行，每行要站的人数 int nearNum = remainder + rowNum;//最后一行站的人 while (N--) { string name; int height; cin &gt;&gt; name &gt;&gt; height; people.emplace_back(make_pair(name, height)); } //按从高到低排序（身高一样的话，按名字升序） sort(people.begin(), people.end(), comp); //开始排队，从最后一排开始排 vector&lt; pair&lt;string, int&gt;&gt; everyQueue; //先把最高的放进队列 everyQueue.emplace_back(people[0].first, people[0].second); for (int i = 1; i &lt; nearNum; i++) { //单数插在队列左边 if (i % 2 == 1) { everyQueue.insert(everyQueue.begin(), people[i]); } else//双数插在队列右边 { everyQueue.emplace_back(people[i]); } } //打印最后一行的人名 for (int i = 0; i &lt; everyQueue.size(); i++) { if (i == 0)cout &lt;&lt; everyQueue[i].first; else cout &lt;&lt; ' ' &lt;&lt; everyQueue[i].first; } cout &lt;&lt; endl; //处理后面的几行 for (int i = 0; i &lt; K - 1; i++)//遍历每一行 { //先清空队列 everyQueue.clear(); //第一个人插入队列（中间） everyQueue.emplace_back(people[nearNum + i * rowNum]); for (int j = 1; j &lt; rowNum; j++)//后面的人按规则入队 { if (j % 2 == 1)//单数站左边 { everyQueue.insert(everyQueue.begin(), people[nearNum + i * rowNum + j]); } else//双数站右边 { everyQueue.emplace_back(people[nearNum + i * rowNum + j]); } } //打印这一行的人名 for (int i = 0; i &lt; everyQueue.size(); i++) { if (i == 0)cout &lt;&lt; everyQueue[i].first; else cout &lt;&lt; ' ' &lt;&lt; everyQueue[i].first; } //不是第一行人就打印换行 if (i != K - 2) cout &lt;&lt; endl; }}    这道题有两个出错的地方 第一个是报错，数组下标越界Expression:vector subscript out of range。这是为什么呢？这是因为我最初算remainder、rowNum、nearNum的时候，是在读取完人名和身高后算的，这个时候N已经减到0了，所以算出的三个变量是不对的，0%K算的是-1，所以越界了。 第二个是排的顺序，相同身高下是名字小的先去站队，我给搞反了 " }, { "title": "PAT-Speech Patterns & Read Number in Chinese & string的erase()用法", "url": "/posts/PAT-Speech-Patterns-&-Read-Number-in-Chinese-&-string%E7%9A%84erase()%E7%94%A8%E6%B3%95/", "categories": "算法刷题, PAT", "tags": "模拟", "date": "2022-07-02 06:25:00 +0000", "snippet": "A1071. Speech Patterns#include&lt;iostream&gt;#include&lt;unordered_map&gt;#include&lt;string&gt;#include&lt;cctype&gt;using namespace std;int main(){ string s;//用来存储input getline(cin, s); ...", "content": "A1071. Speech Patterns#include&lt;iostream&gt;#include&lt;unordered_map&gt;#include&lt;string&gt;#include&lt;cctype&gt;using namespace std;int main(){ string s;//用来存储input getline(cin, s); unordered_map&lt;string, int&gt; map;//用来记录单词个数 //遍历s string word; for(int i = 0; i &lt; s.size(); i++) { word.clear();//先清空word //如果没越界而且当前字符是字母或者数字 while(i &lt; s.size() &amp;&amp; isalnum(s[i])) { word += tolower(s[i]);//cctype的函数 i++; } //如果不是空string就加1 if(!word.empty()) map[word]++; } //查找次数最多的单词 int maxC = 0;//记录最大次数 string maxS;//记录对应的字符串 for(auto it = map.begin(); it != map.end(); it++) { if(it -&gt; second &gt; maxC)//如果大于最大值，更新 { maxC = it -&gt; second; maxS = it -&gt; first; } } cout&lt;&lt;maxS&lt;&lt;' '&lt;&lt;maxC;}    这道题就是去找句子中出现次数最多的单词是什么，有几个。    先获取整个句子，再挨个遍历字符，其中用到了两个函数，分别是isalnum()和tolower()。 tolower()语法 #include   int tolower( int ch );   int toupper( int ch ); 可以将字符ch转换为小写、大写 isalnum()语法 #include   int isalnum( int ch ); 如果参数是数字或字母字符，函数返回非零值，否则返回零值。A1082. Read Number in Chinese#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;using namespace std;int main(){ string num; cin&gt;&gt;num;//读取input vector&lt;string&gt; ans;//记录最终答案 vector&lt;string&gt; cnNum = {\"ling\", \"yi\", \"er\", \"san\", \"si\", \"wu\", \"liu\", \"qi\", \"ba\", \"jiu\"};//存储中文数字 vector&lt;string&gt; smallUnit = {\"Shi\", \"Bai\", \"Qian\"};//存储中文单位，万和亿单独算 vector&lt;string&gt; biglUnit = {\"Wan\", \"Yi\"}; //如果是负数 if(num[0] == '-') { ans.emplace_back(\"Fu\"); num.erase(0, 1);//删除字符串的第0位 } //处理前导0 while(num.size() &gt; 0 &amp;&amp; num[0] == '0') { num.erase(0, 1);//如果前面有0，则删除掉，直到删完或者不再是前导0 } //全是0的情况 if(num.size() == 0) { cout&lt;&lt;\"ling\"; return 0; } int len = num.size(); //每四个一组来输出,不用担心当len = 8或4的时候，因为这时候，后面的循环是不会执行的，相当于跳过了 for(int group = len / 4; group &gt;= 0; group--) { //两个标记，用来标记前面是否出现过0，和是否输出过数字 bool hasZero = false, hasPrint = false; //j从每一组的第一个数字开始len - group * 4 - 4其实是算下一个组的起始下标 for(int j = max(0, len - group * 4 - 4), k = len - group * 4; j &lt; k; j++) { if(num[j] - '0' == 0)//如果有0 { hasZero = true; } else//当这一位不是0时 { hasPrint = true; if(hasZero)//前面有0 { ans.emplace_back(\"ling\"); hasZero = false; } ans.emplace_back(cnNum[num[j] - '0']);//插入当前位的数字 int dis = k - j;//通过j下标到本组最远位置k的距离来判断输出什么单位 if(dis &gt;= 2)//距离等于2时，是十 { ans.emplace_back(smallUnit[dis - 2]); } } } //如果这一组大于0，而且打印过数字的话 if(group &gt; 0 &amp;&amp; hasPrint) { ans.emplace_back(biglUnit[group - 1]); } } //打印结果 for(int i = 0; i &lt; ans.size(); i++) { if(i == 0)cout&lt;&lt;ans[i]; else cout&lt;&lt;' '&lt;&lt;ans[i]; }}    这道题目究极复杂，自己想半天想不明白，借鉴了别人的方法，要先处理符号和前导0，最后根据标记来插入元素。空格可以最后输出的时候考虑，一开始我想直接就打印了，发现空格确实是个比较难想的东西，但如果放在最后处理的话就很简单了。    字符串的erase函数用法： 语法 iterator erase( iterator pos ); iterator erase( iterator start, iterator end ); basic_string &amp;erase( size_type index = 0, size_type num = npos ); erase()函数可以: 删除pos指向的字符, 返回指向下一个字符的迭代器, 删除从start到end的所有字符, 返回一个迭代器,指向被删除的最后一个字符的下一个位置 删除从index索引开始的num个字符, 返回*this.     上面的程序里，用了第三条语法，就是删掉第一个字符。    还有要注意的就是用vector申请数组时，如果要像这样初始化，那么一开始就不要申请固定的空间，不然会报错。    分组这种方法，一开始还没看懂，一直纠结当长度为8或者4怎么办，看到后面发现，这种情况相当于直接跳过了。    1,0000,5000，用上面的程序，这个数字输出是一亿五千，并没有错，我以为要读一亿零五千。报错传不上github的原因：    大概是因为之前的erase语法那里，我是完全copy的c++的API手册，里面是有内部链接的，但因为是内部链接，所以在这肯定无效，所以上传也出了错" }, { "title": "虚拟场景设计笔记", "url": "/posts/%E8%99%9A%E6%8B%9F%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/", "categories": "Unreal5", "tags": "学习笔记", "date": "2022-06-28 08:39:00 +0000", "snippet": "1. 导入模型与UE5的操作设置 将布局改为Ue5（之前做2d游戏改成UE4的经典布局了），window-&gt;load layout选择即可 先创建一个空的level 加一个定向光源directional light 添加一个天空大气环境，visual effects -&gt; sky atmosphere 再添加一个体...", "content": "1. 导入模型与UE5的操作设置 将布局改为Ue5（之前做2d游戏改成UE4的经典布局了），window-&gt;load layout选择即可 先创建一个空的level 加一个定向光源directional light 添加一个天空大气环境，visual effects -&gt; sky atmosphere 再添加一个体积云visual effects -&gt; volumetic cloud 再添加一个指数级高度雾visual effects -&gt; exponential height fog 再添加一个天空光照sky light 调节directionnal light的旋转角度来改变太阳的照射方向（之前一直调sky light和sky atmosphere，怪不得没效果） 导入模型，将所有模型在outliner中打入一个文件夹，地面和房子挪至父文件夹 其他放进物理环境文件夹 调高sky light的强度2 到project setting里的渲染中，global illumination选择lumen，下面lumen中，勾选第一个，在可能时使用硬件光线追踪（之前我建的项目没开光追，这个选项是灰色的，重新建了个项目，就可以勾选了，就是初始化项目初始化了好久），勾选software ray tracing的generate mesh distance fields（默认是给勾上了），勾选misc lighting中的allow static lighting（默认也是勾着的）。默认设置里，bloom关掉，auto exposure自动曝光关掉 打开bridge插件，上方widow-&gt;Quixel bridge 在bridge中找一个模型，下载并拖入场景 修改视角为过场动画视角：窗口左上角，perspective-&gt;cinematic viewport 创建一个摄像机cinematic -&gt; cine camera actor 进入摄像机视角，perspective中选择相机名称 调整摄像机焦距40 2. 创建新视口与修正锚点（轴） 多开视口操作：window-&gt;viewport-&gt;viewport2，更改perspective即可 关于锚点不在物体模型中心的解决方法：点击模型，右键 -&gt; pivot -&gt; set pivot offset here(snapped) ，再次右键-&gt;pivot-&gt;set as pivot offset 可以通过降低screen percentage来节省性能 3. 搭建场景 使用bridge内的素材搭建场景 ctrl + G可以使多个物体打组 4. 附材质、放置植被 在content drawer中添加材质实例material instance的搜索标签 在bridge的surface-&gt;metal中下载合适的材质 双击材质，勾选Tiling/Offset，可以修改tiling x和y 5. 植物模式与光影调整 选择模式，改为植物模式Foliage mode 调节光与雾 6. 贴花与导出 在bridge的decals下载资源 创建贴花 视觉效果-&gt;贴花actor 点击选项可以导出高分辨率截图 最终效果 " }, { "title": "Learn How To Make A 2D Platformer In Unreal Engine 5学习笔记#6&7关卡设计和最后的优化", "url": "/posts/Learn-How-To-Make-A-2D-Platformer-In-Unreal-Engine-5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-6&7%E5%85%B3%E5%8D%A1%E8%AE%BE%E8%AE%A1%E5%92%8C%E6%9C%80%E5%90%8E%E7%9A%84%E4%BC%98%E5%8C%96/", "categories": "Unreal5, Learn How To Make A 2D Platformer", "tags": "学习笔记, 蓝图", "date": "2022-06-25 14:39:00 +0000", "snippet": "6.1Designing A Level 去修改之前创建的tileset_tilemap，大小60*20 layer命名main fill类似油漆桶，很方便，设计main的tile 创建一个layer，命名Treebackground，放几棵树，如果发现有些地方框选不到，那就到tileset里调整tilesize 再创建一个l...", "content": "6.1Designing A Level 去修改之前创建的tileset_tilemap，大小60*20 layer命名main fill类似油漆桶，很方便，设计main的tile 创建一个layer，命名Treebackground，放几棵树，如果发现有些地方框选不到，那就到tileset里调整tilesize 再创建一个layer，bushbackground 在地图边缘创建空气墙，放一个cube，调整大小，在details中搜索hid，勾选actor hidden in game 放一些小怪 6.2Creating A Main Menu 拖入UI资源 在UI文件夹，右键-&gt;user interface-&gt;widget blueprint,命名mainmenu_wb 拖入image,anchors选最右下角那个填满的，接着image的offset全设置为0 image设置为刚拖入的资源 拖入vertical box，anchors锚点设置为中心，命名start menu，并勾选is variable 向box中拖入两个button，再拖两个text到button上，一个是开始，一个是推出游戏 拖入一个text，锚点设置在top 调整image的tint，让画面暗点 设置button的style 给button添加on click事件 退出按钮直接就指向quit game节点 拖入一个水平盒命名level menu，勾选 is variable，锚点依然是中心，放入几个按钮用来表示level 在level menu的details中搜索visibility，设置为hidden 在屏幕左下角放置一个button，命名back button，也设置为hidden，锚点在左下角 点击开始游戏显示关卡菜单和返回菜单 为开始游戏按钮添加on pressed事件 把levelmenu和backButton拖入蓝图（上面已经设置成了variable） on pressed节点后，设置开始菜单的visibility为hidden，另外两个显示 back button添加on click事件，上面的事反着来 按 alt + 左键可以快速取消连接 6.3Creating The Main Menu Level 点击窗口左上角file -&gt; new level -&gt; default level save为level menu 点击上方blueprint按钮，选择open level bluprint brgin play节点指向create widget，选择main menu，指向add to view port 右键创建get player controller 节点，指向 set show mouse cursor节点 get player controller 节点指向set input mode ui only节点 创建一个game mode base蓝图，命名mainMenuGameMode 点击上方window-&gt;world settings，设置game mode 前往主菜单的控件蓝图去，给level 1按钮添加click事件，指向open level节点，输入level名字 前往角色蓝图，begin play节点后面设置鼠标隐藏，并set game mode only 6.4Creating A Pause Screen Edit -&gt; project settings -&gt; input添加action mappings，命名Pause game，使用按键P 创建控件蓝图（widget），paused_wb 拖入image，跟上个一样，填充屏幕，然后透明度降低点 拖入text，锚点中央，paused 进入角色蓝图，右键创建pausegame节点（开始创建的action mapping），pressed指向create widget节点，选择pause_wb return value生成一个变量pause UI，指向 add to viewPort 指向set game paused节点 为了能取消暂停，pressed指向一个branch节点，condition为is game paused 如果false就暂停否则，先判断pauseUI 是否is valid，就是如果现在pauseUI确实显示在屏幕上，就解除暂停，即指向remove from parent，再指向 set pauseUI节点，这样就会设置为unvalid（应该是为了防止快速连按），最后设置为非暂停 点击最开始的输入节点，勾选execute when paused（一定要勾选这个！！） 6.5Creating Game Over Screen 创建一个widget，GameOver_WB 拖入image，像上面一样 拖入text，game over 进入蓝图模式，在event construt节点后指向delay节点，延迟4s后，指向open level by name，回到主菜单 去角色蓝图，死亡后直接创建game over的widget即可 7.1Creating A Save Game Pt 1 创建蓝图类，搜索save game，创建并命名PlatformerSave 创建变量coins（float），NoOfAxe（float），Lives（float） 进入mainmeui_wb蓝图，event construct节点指向Dose Save Game Exist，slot name设置为1，return value指向一个branch（condition） 如果false就执行create save game object，选择platformer game save（刚才建的） 然后执行set coins（0）、NoOfAxe（0）、Lives（5）、save game to slot 进入角色蓝图，在beginPlay节点后，指向Load Game from slot节点，slot name设为1，return value指向cast to platformerSave 再通过这个cast to platformerSave节点的as platformersave来get三个变量 接着设置玩家的三个变量 7.2Creating A Save Game Pt 2 在角色蓝图中，当lives减少时，更新存档 将Platformersave创建成变量（去之前的cast to Platformersave节点处右键创建） 设置完lives，就指向save game to slot 当 game over的时候，前往gameover_wb，event construct指向load game from slot节点，再cast to platformersave，设置lives为5，最后指向save game to slot1 前往coin蓝图，当收集到金币时，就设置存档的金币（金币clamp到0-100的范围内），存档类用角色类的变量引用 在存完档后检测是否等于100，否的话就存档，是的话命+1，再设置存档 enemy conin也做类似的处理 当投掷完斧子后也存下档 前往axe pickup蓝图，捡到斧子时也要存档 发现了一个非常严重的bug，就是关于存档，在begin play事件读存档的话，最后的值会被默认值覆盖，但我把读存档放在按攻击键之后的话，就能读取成功了，总之就是很怪，这begin play感觉它后面还有个default事件，给我把前面赋得值全给擦了，甚至把初始化的变量也给擦了，导致后面更新存档时，说Psave这个变量是空值，总之就很怪，设置成读存档按键好了（合理逃避），不然也太费时间了，还有就是，开局必须按G，不然退出会报错psave为none，哎~ 我试了个新方法，把存档功能整理成一个存档事件，然后再beginPlay事件最后delay个0.5s再执行，就可以了，而且0.5s很难察觉出来哈哈哈哈 7.3Updating The UI 没啥好说的，就是改了改布局，加了个图片 7.4Updating The Pause Menu 给暂停界面加个返回主菜单和继续的按钮 记得在暂停的时候set show mouse cursor（要先创建get player controller节点才行），并set input mode ui only，解除暂停时也要set input mode game only 需要注意的是，在没碰撞获取2dCharacter时，需要get player character来获取2dCharacter类，而不是 get player controller 7.5Creating The End Level Box 创建一个actor，命名level change 拖入flag资源，制作flipbook 添加beginoverlap事件（给box加） 7.6Level Unlock System 进入platformersave蓝图，创建变量levelUnlocked？（boolean-array） 复制一份level1，变成level2 复制一份tilemap，成level2tilemap 设计level2map并更换 前往mainmenu_wb，复制一份level1，变成level2，添加on click事件，open level2 接下来是锁关系统：在上面的on click节点后，先判断是否有存档1，有的话就加载slot1，投射platformersave类，get levelunlocked？，get（a copy）（设置为1），指向branch，如果解锁，就解锁第二关 前往第一关的level change蓝图中，在碰撞节点的cast to 2dcharacter节点后加载slot1， 投射platformersave类，get levelunlocked？，指向set array elem节点，将index生成一个变量levelnum，勾选item 设置完了，就save game to slot 我发现一旦涉及到tilemap就容易crash， 7.7Adding Invisible Collision To The Level 由于关卡开始的空气墙也可以被玩家爬，所以fix this bug 选择cube，设置collision presets为custom，勾选visibility的ignore 7.8Updating The Wall Slide 前往角色蓝图 再beginplay节点后指向get all actors with tag，tag设置为nowallslide，out actors生成一个变量，命名nowallslideactors 到滑墙系统板块，line trace by channel节点的arrays to ignore指向刚创建的nowallslideactors变量 最后将墙设置为nowallslide即可防止角色话去滑设定的墙（但我不需要哈） 7.9Updating The Enemies 小怪在空中移动距离过大，前往enemy蓝图，选择character movement，搜索lateral（横向的），设置falling lateral frict为2.5 由于小怪被玩家在身后打了后的受伤动画是朝着玩家动的，很不自然（被打了也不回头也很不自然好吧233） 前往enemy蓝图，在伤害板块，select节点的return value生成一个变量，命名HitDirection，并set这个值放在set enemy health后 前往动作处理模块：在sequence的then0后加一个branch判断是否受伤害了，如果受伤了，就根据HitDirection来设置转身 7.10Updating The Projectile Attack 前往axe蓝图，添加标签projectile 给小怪的子弹也加上标签projectile 回到axe蓝图，在apply damage节点签添加actor has tag节点，tag设为projectile 作为branch的条件，branch加在destroy前，如果有这个tag就两种子弹都destroy 怪物的子弹也加上这个 7.11Final level Touches 拖入campfire unlit资源，并创建flip book 将检查点的动画设置成这个，然后在碰撞事件的最后加上设置动画，设置成着火的状态 再丰富下地图 创建一个tiemap，可以跳的那种 给tileset添加box后，点击refresh map可以直接更新 又出bug了，说是range enmey的launch velocity节点由于之前的damage causer为none，导致报错，但明明enemy就没事，很怪，强行设置了玩家为damage causer就不报错了。 7.12Packaging The Project Edit -&gt; project setting -&gt; maps &amp; modes，找到default maps，设置里面game default map为menu 回到编辑器，点击play旁边的platforms-&gt;windows-&gt;（选择shipping）package project(vs要安装NET.SDK) 完结撒花啦~" }, { "title": "CCF CSP-灰度直方图 & 邻域均值", "url": "/posts/CCF-CSP-%E7%81%B0%E5%BA%A6%E7%9B%B4%E6%96%B9%E5%9B%BE-&-%E9%82%BB%E5%9F%9F%E5%9D%87%E5%80%BC/", "categories": "算法刷题, CCF CSP", "tags": "模拟, 数字图像处理", "date": "2022-06-24 10:06:00 +0000", "snippet": "    听说山大夏令营要机试，内容是csp类型的题，暂时就先停停PAT吧，等8月份再开刷，到时候也没项目做了，可以专心准备机试了，估计还有大概一周左右山大就要开营了，先刷一周CSP好了，熟悉下题型。 争取每天两三道吧。202104-1. 灰度直方图#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int mai...", "content": "    听说山大夏令营要机试，内容是csp类型的题，暂时就先停停PAT吧，等8月份再开刷，到时候也没项目做了，可以专心准备机试了，估计还有大概一周左右山大就要开营了，先刷一周CSP好了，熟悉下题型。 争取每天两三道吧。202104-1. 灰度直方图#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main(){ int n, m, L;//n行m列，灰度级L cin&gt;&gt;n&gt;&gt;m&gt;&gt;L; vector&lt;int&gt; diagram(L, 0); for(int i = 0; i &lt; n*m; i++) { int tmp;//储存灰度 cin&gt;&gt;tmp; diagram[tmp]++; } for(int i = 0; i &lt; L; i++) { if(i == 0) cout&lt;&lt;diagram[i]; else cout&lt;&lt;\" \"&lt;&lt;diagram[i]; }}     这道题不难，就是鼓捣了半天DevC++这个编译器，不得不说，有点点难用，不过捣鼓好了，接下来就是刷题了。202104-2. 邻域均值#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main(){ //n图像宽高，L灰度级，r邻域半径，t阈值（L好像是用不到的） int n,L,r,t; cin&gt;&gt;n&gt;&gt;L&gt;&gt;r&gt;&gt;t;//读取数据 vector&lt; vector&lt;int&gt; &gt; bmp(n, vector&lt;int&gt;(n, 0)) ; //将像素数据储存到二维数组中 for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { cin&gt;&gt;bmp[i][j]; } } //统计每个像素 每一行的前缀和 vector&lt; vector&lt;int&gt; &gt; prefixBmp(n, vector&lt;int&gt;(n, 0)); for(int i = 0; i &lt; n; i++) { int sum = 0;//每行都归0 for(int j = 0; j &lt; n; j++) { //等于这像素之前的灰度和 + 本像素的灰度 prefixBmp[i][j] = sum + bmp[i][j]; sum = prefixBmp[i][j]; } } //开始统计较暗处的个数 int ans = 0; //判断每个像素是不是暗处 for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { //统计该位置的邻域大小 int a,b,c,d;//分别代表邻域的 起始终止 列序号 和 行序号 a = (j - r &gt;= 0 ) ? (j - r) : 0;//如果起始列越界那就0 b = (j + r &lt; n) ? (j + r) : (n - 1);//如果终止列号越界那就n-1 c = (i - r &gt;= 0) ? (i - r) : 0;//如果起始行越界，那就0 d = (i + r &lt; n) ? (i + r) : (n - 1);//如果中止行越界，那就n - 1； //统计这片区域的大小，即像素个数 int areaCnt = (b - a + 1) * (d - c + 1); //统计这片区域的灰度和 int greySum = 0; //算每一行即可 for(int p = c; p &lt;= d; p++) { //利用前缀和数组 greySum += prefixBmp[p][b] - prefixBmp[p][a] + bmp[p][a]; } //判断是否小于等于阈值 if(greySum &lt;= t * areaCnt) ans++; } } cout&lt;&lt;ans;}    一遍AC，不愧是数字图像处理拿优秀的我哈哈哈哈。使用前缀和数组节省开销，别的就没什么需要注意的了。" }, { "title": "Learn How To Make A 2D Platformer In Unreal Engine 5学习笔记#5生命、检查点、拾取、音效与贴图", "url": "/posts/Learn-How-To-Make-A-2D-Platformer-In-Unreal-Engine-5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5%E5%81%A5%E5%BA%B7-%E6%8B%BE%E5%8F%96-%E9%9F%B3%E6%95%88%E4%B8%8E%E8%B4%B4%E5%9B%BE/", "categories": "Unreal5, Learn How To Make A 2D Platformer", "tags": "学习笔记, 蓝图", "date": "2022-06-23 16:36:00 +0000", "snippet": "demo演示地址：Learn How To Make A 2D Platformer In Unreal Engine 5学习笔记#5生命、检查点、拾取、音效与贴图5.1How to create a moving platform 创建一个actor蓝图，命名moving platform 添加paper sprite，设置为灰色块 调整形状 ...", "content": "demo演示地址：Learn How To Make A 2D Platformer In Unreal Engine 5学习笔记#5生命、检查点、拾取、音效与贴图5.1How to create a moving platform 创建一个actor蓝图，命名moving platform 添加paper sprite，设置为灰色块 调整形状 add interpToMovemrnt组件，设置behaviour type 为Ping Pong 添加两个 control points 创建两个变量，Location1（vector），Location2（vector），都设置为可编辑模式，并勾选show 3d widget（这样就可以直接在场景中修改位置了） 创建一个变量Duration（float） 前往construction script，设置控制点和时间，蓝图： 5.2How to create a Coin System 拖入coin资源，制作flipbook 创建Coin的actor 添加paperFlipbook，调整大小 添加sphere碰撞盒 在角色蓝图中添加变量NoCoins（integer） 去PlayerHud_WB中添加一个horizontal box，在里面加一个text，一个image text绑定角色的NoCoins 去coin的蓝图中添加begin overlap事件，让角色的NoCoins变量增加 将金币放在移动平面的子物体中，可以跟随平板移动 之前一直没碰撞是因为金币的y坐标不是0，所以触发不了碰撞事件 5.3How to create a Checkpoint System 创建变量Respawn Location（vector） 创建自定义事件：RespawnPlayer，指向setactorLocation，设置为Respawn Location 创建actor，命名checkPoint，添加一个box collison（解除hide）和一个scene 为box collison添加begin overlap事件 当碰撞时，设置respawn location为这个acor的scene的world location 到蓝图的更新生命值板块，如果生命值&lt;=0了，就指向RespawnPlayer节点 创建变量maxHealth为最大生命值 先在beginPlay后设置maxHealth为Health 在respawn player节点后再重新设置health为maxHealth set health节点指向remove from parent，将playerhud从view port删除，接着指向create widget节点，选择playerHud_WB，再将return value设置为playerhud变量，最后再指向add to viewport节点 在beginPlay节点后设置respawn location为角色位置（z+10），避免没有碰到检查点就死掉后重生在奇怪位置的bug 拖入checkPoint资源（campFire），给检查点添加动画 测试的时候，给一个按键加个apply damage功能即可 做的时候有个小bug，生命条不显示，是因为忘加add to viewport节点了 5.4How to create a Life System 添加变量lives 每当生命值小于0时，就减少一条命（如果lives&gt;0），如果没命了，就将下面创建的isDead置为true 添加变量isDead 更新死亡动画，如果死亡状态就是do once，设置死亡动画smoke（下面创建），动画播放结束就set sprite visibility不可见，角色的movement也set active（不勾选） 拖入deathSmoke资源，创建flipbook 在playerhud_wb中添加vertical box，将之前的信息都放到里面，再添加一个horizontal box记录命的条数 此时，出现了一个问题，当我往text绑定角色类的lives时，发现在下拉列表中找不到lives这个float变量，然后发现有的float变量能找到，有的float变量找不到，然后上虚幻论坛查了查受到点启发，去create bind，然后通过蓝图来绑定，就可以，其中自动把float给转换成double了，很怪。 5.5How to create a Spike System 拖入spike资源（地刺） 创建actor，命名spikes，添加paper sprite，box collision，去掉paper sprite的collision 添加begin overlap事件，对玩家造成伤害，蓝图： 5.6Setting Up A Background For Are Level 拖入tileset文件夹，其中BG1要单独拖入，不然创建sprite就会变成绿色（因为拖入tileset文件夹就会按normal map导入），全部创建精灵（创之前要记得apply 2dtexture） 拖入BG1，设置坐标，y=-100，修改大小（测试而已） 右键BG1、BG2、BG3（创建精灵前的），sprites action -&gt; create tile set 右键创建好的tile set创建tile map 进入tile map，设置setup中的宽高10*6 重命名这个图层为skybackground 在上面创建一个图层，放置云，clouds 再在上面创建一个图层，grassLayer，save后即可使用tilemap 5.7Tilesets 将资源中的tile set设置成tile set（双击进去，将tile size改为16*16） 点击上方的add box可以给tile set添加碰撞盒，add polygon可以给贴图添加奇形怪状的碰撞盒，add circle可以加原型碰撞盒 点击colliding tiles可以显示加了碰撞的贴图 创建个tilemap，20*20大小的，做个小地形放进去 中间不知道为啥突然crash了，去论坛查了查，有人重新放了下素材就好了，我试了试，也可以了，虽然不知道为啥crash….. 5.8Setting Up Custom Projectiles 进入rangeEnemy蓝图的攻击板块，右键SpawnActor的class节点，生成一个变量EnemyProjectile，设置为可以编辑的，后面是通过在编辑器的修改来改变弹药种类（其实可以加个branch） 复制MushroomProjectile的actor，命名Bomb Projectile 更换精灵图，修改伤害值 5.9Enemy Fixes 当小怪成为尸体后，创建一个金币，spawnActor coin 复制coin创建一个enemycoin，创建一个变量random coin Num，使得碰撞后+random coin Num个金币（记得勾选instance editable和expose on spawn，这样才能在节点显示） 回到小怪蓝图的spawnActor coin节点，class设置为刚建的enemy coin random coin Num指向random float in range节点，指向random float in range节点需要再取整，加个round节点（如果是int就不用了） 将transform拆分，location为尸体的位置 将capsule component拖入蓝图，指向set collision profile name节点，并左右连接set dead body和spawnactor节点 set collision profile name节点的name改为overlap only pawn 在处理动作板块加个判断死亡，就不再执行动作 将产生金币复制到melee enemy蓝图中 在小怪攻击动画结束后如果死掉，就不再对玩家造成伤害，加个branch 远程攻击的话，是spawn actor之前判断下是否死亡 5.10Creating A Health Pick Up 给心脏贴图创建个精灵（之前竟然一直没建 创建一个actor命名heartPickUp，add paper sprite（去掉碰撞）和box collision 添加begin overlap事件，类似捡手斧，蓝图： 前往playerHud_WB，复制Heart Ref变量为RemovedHearts，拖入蓝图，指向add节点，for loop的array element指向add的select asset，最后左右分别连接remove heart节点和remove节点 前往heart_WB，新建自定义事件节点showheart，跟remove heart反着来就行，显示心脏 前往playerHud_WB，创建自定义事件showHeart，指向for loop，for loop的first index设置为1，last index连向showHeart节点 前往heartPickUp，在set后指向showHeart节点（需要先有playerHud_wb的引用噢，就是获取2dCharacter的playerHud变量） last index为这个heartPickUp的health，最后再destroy 回到playerHud_WB，拖入removedHearts，指向get（a copy）节点，其中get的index指向为removedHearts的长度-1，这样copy的就是失去的最后一个心（也就是刚失去的） get后指向 show up（也就是让一颗心visible），然后再add heart ref，remove removedhearts： 由于满血时再吃心，会报错，前往playerHud_WB，在get节点后加个判断is valid节点，因为，removed hearts有可能长度为0，再-1成负数了，显然不可能 5.11Adding Sound Effects 拖入音效资源 前往Axe_pickup蓝图，在destory前，加入Play sound2d节点 前往角色蓝图，生成斧子节点后播放投手斧的声音 前往coin_sound文件夹，右键-&gt;sounds-&gt;sound cue，命名coinsoundcue 将所有coinsound拖入cue的蓝图中，所有节点指向random 前往coin的蓝图，在destroy前，加入play sound 2d节点，选择coinsoundcue enemycoin的actor也加入play sound 2d节点，选择coinsoundcue 前往heart pick up蓝图，加入play sound 2d节点选择heartpickup 为近战攻击也创建个soundcue 前往角色蓝图，在攻击后的检测中，如果hit actor is valid，就播放近战攻击声音，在delay前播放swoosh声音 在set is attacking节点前加一个do once sequence节点加一个pin，then2指向do once的reset 前往enemy的蓝图，在设置小鬼受伤后面（set is damaged节点后）播放hurt动画 5.12Creating Double Jump 直接去角色蓝图中，点击component中的2dcharacter（self），在details中搜索jump，修改jump max count即可（so easy）" }, { "title": "UE5 Widget蓝图中为text内容绑定时部分float变量不可见", "url": "/posts/UE5-Widget%E8%93%9D%E5%9B%BE%E4%B8%AD%E4%B8%BAtext%E5%86%85%E5%AE%B9%E7%BB%91%E5%AE%9A%E6%97%B6%E9%83%A8%E5%88%86float%E5%8F%98%E9%87%8F%E4%B8%8D%E5%8F%AF%E8%A7%81/", "categories": "Unreal5, 问题总结", "tags": "学习笔记, 问题解决, Widget", "date": "2022-06-23 09:40:00 +0000", "snippet": "    在2dCharacter中创建了Lives变量（float），但在playerHud_WB中text的content上bind该变量时，发现找不到（明明可以看到像Melee Damage这样的float值），换成integer类型后就可以看到了，但这治标不治本，万一下次真的需要用到包含小数的变量呢？            去论坛查了查，受到了点启发，点击create binding，...", "content": "    在2dCharacter中创建了Lives变量（float），但在playerHud_WB中text的content上bind该变量时，发现找不到（明明可以看到像Melee Damage这样的float值），换成integer类型后就可以看到了，但这治标不治本，万一下次真的需要用到包含小数的变量呢？            去论坛查了查，受到了点启发，点击create binding，将需要绑定的变量做成蓝图即可        点击create binding，这里我已经创建过了，就是这个GetText_1        点击后会自动跳转到蓝图页面，将需要绑定的变量指向return value即可，其中自动给加了转换成double，看来这个变量需要变成double才能够被绑定，其实蛮奇怪的，因为有的float也不需要转换成double再去绑    " }, { "title": "PAT-Kuchiguse & Stucked Keyboard & getline()用法", "url": "/posts/PAT-Kuchiguse-&-Stucked-Keyboard-&-getline()%E7%94%A8%E6%B3%95/", "categories": "算法刷题, PAT", "tags": "模拟", "date": "2022-06-21 09:25:00 +0000", "snippet": "A1077. Kuchiguse#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;using namespace std;int main(){ int N;//记录有几个句子 int minLength = 257;//记录句子最短长度 vector&lt;char&gt; stack;...", "content": "A1077. Kuchiguse#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;using namespace std;int main(){ int N;//记录有几个句子 int minLength = 257;//记录句子最短长度 vector&lt;char&gt; stack;//当作栈使，存后缀 vector&lt;string&gt; sentence;//记录每一条句子 cin &gt;&gt; N; getchar();//吸收换行 for (int i = 0; i &lt; N; i++) { string tmp; getline(cin, tmp); //更新最短长度 if (tmp.size() &lt; minLength) minLength = tmp.size(); sentence.emplace_back(tmp);//记录每个句子 } bool isStop = false; //从每个字符的最后一个开始 for (int i = 0; i &lt; minLength; i++) { char last = sentence[0][sentence[0].size() - 1 - i]; //查每个句子的对应的字符 for (int j = 1; j &lt; N; j++) { if (sentence[j][sentence[j].size() - 1 - i] != last) { isStop = true; break; } } if (isStop)//如果已经出现不同了 { if (stack.empty())//说明从最后一个字符开始就不一样了 { cout &lt;&lt; \"nai\"; } else//如果栈里有字符，那就反过来打印 { while (!stack.empty()) { cout &lt;&lt; stack.back(); stack.pop_back(); } } break; } else//如果没有stop { stack.emplace_back(last); } } //如果遍历完了，说明最短的字符就是答案 while (!stack.empty()) { cout &lt;&lt; stack.back(); stack.pop_back(); }}    这道题目就是从后往前遍历即可，稍微用到了栈，但我用vector当栈使了，中间有个编译错误，是因为我用vector&lt;string&gt;类型的结构去接收char了。    由于这道题再次使用到了getline()函数，那么在这里总结下getline()函数的用法吧getline()函数用法有两种getline函数1.头文件&lt;istream&gt;中语法 istream &amp;getline( char *buffer, streamsize num );istream &amp;getline( char *buffer, streamsize num, char delim );    getline()函数用于输入流，读取字符到buffer中，直到下列情况发生： num - 1个字符已经读入, 碰到一个换行标志， 碰到一个EOF， 或者，任意地读入，直到读到字符delim。delim字符不会被放入buffer中。#include &lt;iostream&gt; using namespace std;int main(){ char name[256]; cout &lt;&lt; \"Please input your name: \"; cin.getline(name, 256); cout &lt;&lt; \"The result is: \" &lt;&lt; name &lt;&lt; endl; return 0;}2.头文件&lt;string&gt;中语法 istream&amp; getline (istream&amp;  is, string&amp; str, char delim); istream&amp; getline (istream&amp;&amp; is, string&amp; str, char delim); istream&amp; getline (istream&amp;  is, string&amp; str); istream&amp; getline (istream&amp;&amp; is, string&amp; str); is    ：表示一个输入流，例如 cin。 str   ：string类型的引用，用来存储输入流中的流信息。 delim ：char类型的变量，所设置的截断字符；在不自定义设置的情况下，遇到’\\n’，则终止输入。 #include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main(){ string name; cout &lt;&lt; \"Please input your name: \"; getline(cin, name); cout &lt;&lt; \"Welcome to here!\" &lt;&lt; name &lt;&lt; endl; return 0;}A1112.Stucked Keyboard#include&lt;iostream&gt;#include&lt;unordered_map&gt;#include&lt;string&gt;#include&lt;cmath&gt;using namespace std;const int L = 256;int main(){ int k;//记录重复的个数 cin&gt;&gt;k; string sentence; cin&gt;&gt;sentence; bool isBroken[L] = {false};//用来判断这个键是否坏掉 bool isShowed[L] = {false};//用来判断之前是否已经查过这个键 bool isPrinted[L] = {false};//用来判断打印第一行时是否打印过 int left = 0, right = 1;//双指针判断 while(right &lt; sentence.size()) { if(isShowed[sentence[left]])//如果当前字符已经检查过 { left++; right = left + 1; continue; } //当前字符没有检查过 if(sentence[right] != sentence[left])//如果下一个字符和当前字符不一样 { isShowed[sentence[left]] = true;//设置为检查过 left++; right = left + 1; continue; } else//如果下一个字符和当前字符一样 { //开始检查一样的个数有几个 while(right &lt; sentence.size() &amp;&amp; sentence[right] == sentence[left]) { right++; } if((right - left) % k == 0)//说明是坏键 { isBroken[sentence[left]] = true;//设置为坏键 isShowed[sentence[left]] = true;//设置为检查过 } else //说明不是坏键 { isShowed[sentence[left]] = true;//设置为检查过 } } //此时，下一个字符和当前字符一样，并且已经处理完毕，可以继续去判断了 left = right; right = left + 1; } //更新坏键，如果一开始判断为坏键，但后面又出现了正确的形式，那就应该再更新一次 for(int i = 0; i &lt; sentence.size(); i++) { if(isBroken[sentence[i]])//如果这个键是坏的 { int j = i + 1; while(j &lt; sentence.size() &amp;&amp; sentence[j] == sentence[i]) j++; if((j - i) % k != 0) isBroken[sentence[i]] = false;//此时更新，坏键其实是好的 i = j - 1; } } //先打印个坏键 for(int i = 0; i &lt; sentence.size(); i++) { //如果没被打印过，而且还是坏键 if(!isPrinted[sentence[i]] &amp;&amp; isBroken[sentence[i]]) { cout&lt;&lt;sentence[i]; isPrinted[sentence[i]] = true; } } cout&lt;&lt;endl; //打印正确的顺序 for(int i = 0; i &lt; sentence.size(); i++) { //如果没坏，照常打印 if(!isBroken[sentence[i]]) cout &lt;&lt; sentence[i]; else { cout &lt;&lt; sentence[i]; i += k - 1;//跳过后面相同的字符（注意 - 1是因为下一次循环会+1） } }}    这道题，坑有点多…… 首先是理解题目意思，只有连续出现k次或k的倍数次才算可能是坏键，如果连续出现了2*k - 1次，就不是坏键 还有就是，输出的时候，是每k个输出一次坏键 尽管判断是坏键了，但后面有可能平反，如果一开始判断是坏键但出现了一段不是k的倍数次的序列，那么就得更新为不是坏键比如3 aaabbbcccaabb（这就是测试点1为什么过不去） 还有要注意的点是，再后面更新坏键的循环中，更新后，i = j是不对的，因为下一步到了for循环，i还会+1，这样就会跳过一个字符，产生错误 " }, { "title": "Collection of My Works", "url": "/posts/Collection-of-My-Works/", "categories": "游戏设计", "tags": "学习笔记, 游戏开发", "date": "2022-06-20 12:20:00 +0000", "snippet": "一、Unity3D开发桌面fps游戏 - 主程 - 2021.12 - 2022.01 实现玩家状态机、武器管理、敌人控制 运用了临界阻尼实现慢入慢出的平滑技术，难点在于数学公式转换成实际代码 demo演示地址:游戏编程作业：Escape from the forest二、GameMaker Studio2 开发桌面RPG-Roguelike游戏 - 主程 - 2022.1- 2022...", "content": "一、Unity3D开发桌面fps游戏 - 主程 - 2021.12 - 2022.01 实现玩家状态机、武器管理、敌人控制 运用了临界阻尼实现慢入慢出的平滑技术，难点在于数学公式转换成实际代码 demo演示地址:游戏编程作业：Escape from the forest二、GameMaker Studio2 开发桌面RPG-Roguelike游戏 - 主程 - 2022.1- 2022.5 实现了RPG基础功能、外加随机地图功能、光照系统功能 运用了回溯算法生成块状分割型迷宫，难点在于块状分割与回溯迷宫的结合；运用选择性光阻拦方法实现光照系统，难点在于影子的计算与柔和的计算 该作品为大学生创新训练项目：使用2D像素roguelike游戏演绎生理疾病与心理健康的关系模式 demo演示地址: 蜕心之歌V1.0 三、Unity3D开发手机AR游戏宝可梦Go - 独立开发 - 2022.5 实现地图、捕捉、仓库功能 运用了GoMap插件LBS基于地理的服务功能，运用了Vuforia制作AR场景。难点在于手指滑动投掷精灵球功能 学习笔记: 复刻《PokemonGo》部分功能的学习记录 demo演示地址:虚拟现实课程设计：基于Unity3D的AR手机游戏《宝可梦Go》 四、Unreal5开发2D平面游戏 - 独立开发 - 2022.6 实现了平面游戏基础功能 全程使用蓝图，此项目用于入门Unreal5引擎。比较复杂的就是生命系统了，涉及到了使用蓝图调用数组，还要更新角色Hud 学习笔记：Learn How To Make A 2D Platformer demo演示地址：【UE5】2D平面游戏 五、Unreal5虚拟场景设计 - 2022.6 使用C4D+Unreal5搭建设计 模型与材质取自Unreal5中Bridge插件 学习笔记：虚拟场景设计笔记 六、基于Unreal5与TrueSkill的多人在线匹配系统 - 2022.7 使用Unreal5的Online Subsystem与Steam服务器搭建多人在线系统，使用TrueSkill算法中的游戏质量公式对正在匹配的玩家进行分组，组成4V4对战 设计文档与多人在线系统技术文档：多人在线游戏匹配系统 demo演示地址：【UE5】基于TrueSkill的多人在线匹配系统 七、Unreal5多人协同开发2d平台跳跃游戏 - 辅程 - 2022.7 2022年朝夕光年48h高校游戏开发挑战赛决赛，三人小队（通过初审） 使用Hamachi创建局域网与Unreal5的Multi-Edit(Beta)实现多人协同工作 我负责实现对话系统、双向跳跃平台与关卡搭建 demo演示地址：【Game Jam】LOOP CAT 八、GAMES101作业实践 - 2023.6 - 2023.7 在作业框架下补全实现软光栅，实现z-buffer深度缓冲消隐， Blinn-Phong光照模型、离线光线追踪渲染和离线路径追踪渲染，并采用了多线程加速，在离线路径追踪渲染部分实现了微表面模型 games101笔记以及作业过程博客：GAMES101 作业演示视频地址：GAMES101作业0-7 九、基于Vulkan的简易实时光线追踪 - 2023.11 基于开源template walnut的简易实时光线追踪渲染 简单实现了基于物理的实时渲染，为材质添加Roughness、emission属性，并使用多线程进行加速，在Realease模式下，三个球体在每一帧的渲染时间在10ms左右 演示视频地址：简易实时光线追踪 " }, { "title": "Learn How To Make A 2D Platformer In Unreal Engine 5学习笔记#4伤害系统", "url": "/posts/Learn-How-To-Make-A-2D-Platformer-In-Unreal-Engine-5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4%E4%BC%A4%E5%AE%B3%E7%B3%BB%E7%BB%9F/", "categories": "Unreal5, Learn How To Make A 2D Platformer", "tags": "学习笔记, 蓝图", "date": "2022-06-19 12:30:00 +0000", "snippet": "demo演示地址：Learn How To Make A 2D Platformer In Unreal Engine 5学习记录#4伤害系统4.1Damaging The Enemy 把enemies文件夹托在content里 进入enemy蓝图 新建event anydamage节点 进入enemy structure，新建变量Enem...", "content": "demo演示地址：Learn How To Make A 2D Platformer In Unreal Engine 5学习记录#4伤害系统4.1Damaging The Enemy 把enemies文件夹托在content里 进入enemy蓝图 新建event anydamage节点 进入enemy structure，新建变量EnemyHealth（float） 进入enemy datatable，为蘑菇怪的生命值设置处置5 返回蓝图，前往怪物数据表初始化板块（原设置怪物动画），初始化生命值（新建变量 ） 回到event anydamage节点，减少生命值，设置后退效果 前往角色蓝图，在apply damage节点的damage cause设置为self 4.2Updating The Enemy Damage Flipbook 在enemy蓝图中，受到伤害后更改动画，创建一个变量作为状态机isDamaged？（bool），如果生命值小于等于0的话就死亡，否则就设置为isDamaged状态，并指向retriggerable delay节点，时间为damaged动画的时间，最后再设置为非isDamaged状态 前往处理动画板块，在开始处，新建branch（快捷键：按住B后左键），判断是否在isDamaged状态，是的话就做受伤动画 damage动画太快，可以选择多复制其中的一帧 注意：设置了5滴血，打5次后就不会再出现受伤动画了嗷 4.3Giving The Axe Projectile Damage 前往axe蓝图，添加球形碰撞，调整大小 将paperSprite的collision presets设置为nocollision 球形碰撞添加on component begin overlap事件 对enemy造成伤害，并设置如果标签不是axe就造成伤害 去给角色和斧子都设置为axe标签（在角色蓝图中component的details中可以搜索到） 给角色蓝图中的spawnactor axe节点的owner设置为self 4.4Creating An Enemy Death System 新建EnemyDead变量，在怪生命值为0时，设置为true 在handleAnimation节点后再创建一个branch，如果没有dead跟以前一样，死了就： 创建变量EnemyDeadBody?并作为select的index，如果有尸体（true），那就是get enemy dead body节点，否则就是enemy die节点，最后指向set flipbook来设置动画 回到damage板块，当设置怪物的isEnemyDead后，die的动画结束后，设置EnemyDeadBody?为true，并在设置死亡前的branch后加上do once节点 在处理动作板块，在sequence节点的then1处添加branch，死亡后不再移动 考虑到死亡时有跳帧，那么有可能是动画结束时间的问题，把时间-0.2再delay会好一点 4.5Creating A Jump Attack System 终于要修跳怪头上后就无限下落的问题了，进入角色蓝图 选择component的character movement，在details中搜索pla，勾选constrain to plane，坐标轴设置为Y，意味着角色的y坐标不会改变，同样，enemy蓝图中也做此设置 给enemy蓝图添加box collison，调整大小和位置，放在头部 点击这个，可以更改对齐精度和是否对齐 添加begin overlap事件，判断当角色在跳跃状态时，就触发一个向上的速度 在damage板块添加自定义事件，JumpDamage，指向do once之前的branch 先到 角色蓝图中添加变量jumpdamage，作为跳跃伤害 回到enemy蓝图，在碰撞板块，添加扣血逻辑并最后指向之前创建的JumpDamage节点，最后连接launch character 当enemy死亡后，destroy component ，来销毁box碰撞 bug：角色起跳时就发生碰撞，那么将box改小一点即可 4.6Making The Enemy Damage The Player Character 给enemy添加box collision，命名attack box，调整位置和大小，添加碰撞事件，begin overlap事件和end overlap事件 begin overlap节点投射到2dcharacter后，指向set timer by event节点，event事件指向一个新建的自定义事件，attackPlayer，return value 设置一个新变量为AttackEvent，Time设置为0.1，勾选Looping attack player事件：如果enemy未死亡，do once指向设置isAttacking为true 在处理动画板块，在isdamaged的branch后，再添加一个branch，根据isAttacking状态设置攻击动画 回到攻击板块，在进入攻击状态后，delay节点后执行sequence节点，then0指向set isAttacking为false，then1指向line trace for objects line trace for objects节点的线由怪物自身向前发射，长度100，objects types指向make array节点，选择pawn，actors ignore指向make array，再指向self，勾选ignore self out hit 指向break hit result，当hit actor == get Player character，如果true，apply damage，hit actor指向apply damage 新建变量enemyDamage（float）（1）作为base damage，并勾选变量的instance editable和expose on spawn 前往角色蓝图的event anydamage节点，其中的damage指向减节点 回到enemy蓝图，apply damage节点指向delay节点，新建变量coolDown（float）（3），结束后，指向之前do once的reset end overlap节点要刷新attack event并且指向do once的reset，这是因为当玩家没有被打到，离开碰撞盒时，就要重置do once，可以再次攻击，否则do once没打到玩家的话就一直不重置，就不能再攻击了 前面有点小bug没有播放动画，后来又是只攻击了一次就停下来了，查了下，是有两处节点没有连接起来，所以部分节点没有运行…… 由于怪物打玩家总是只掉一滴血，所以去修这个bug 由于update health每次只减少一滴血，所以要加个循环 enemy在攻击时也不能移动，加上这个条件 4.7Creating A Ranged Enemy Pt 1     由于第5节内容较少，所以和第3节合并 复制enemy 蓝图，命名rangeEnemy 进入rangeEnemy蓝图，删掉处理动作板块，将handle movement改为handle rotation（因为要小怪面向玩家），蓝图如下：（可以从伤害板块找到部分节点） 修改attack的box 修改 overlap begin事件（删掉end事件和begin doonce之后的节点） 将isAttack改为isRangeAttack，并修改之前的动画 动画播放完毕就生成子弹，蓝图： 将子弹精灵图片提取出来，将第一帧命名为mushroom projectile 将axe的actor复制一份拖到enemy文件夹，命名mushroom projectile 修改精灵图，将Projectilemovement的速度修改为700 将actor has tag节点的tag修改为enemy 为enemy添加enemy tag 回到mushroom projectile蓝图，add scene，作为发射点 最后一个delay完成后要指向do once的reset。蓝图： 4.8Creating A Ranged Enemy Pt 2 由于投掷的斧子触碰到怪物的攻击碰撞盒也会触发，所以要去修改怪物的攻击碰撞盒，collision中的presets修改为custom，ignore world static和worldDynamic Blueprint Runtime Error: “Attempted to access Axe_C_0 via property K2Node_ComponentBoundEvent_OtherActor, but Axe_C_0 is not valid (pending kill or garbage)”. Node: Branch Graph: EventGraph Function: Execute Ubergraph Mushroom Projectile Blueprint: MushroomProjectile 解决这个问题，意思就是飞斧打到怪物的子弹，想要造成伤害，但子弹没有受到伤害节点，所以就报错了 前往axe的蓝图，在begin overlap后加一个is valid节点，other actor指向其 input object 在mushroomProjectile蓝图中做相同的事情 4.9How To Add New Enemy Sprites 处理goblin精灵图（创建动作文件夹Attack、Death、Idle、Projectile、run、damaged、rangeattack），提取精灵图、创建flipbookf 前往enemydata table，添加哥布林 可以通过修改enmey蓝图的type直接更改enemy 将蓝图中，初始化精灵图的节点复制到construction script中去，可以在开始游戏前就看到更换的效果 " }, { "title": "PAT-The Dominant Color & Set Similarity", "url": "/posts/PAT-The-Dominant-Color-&-Set-Similarity/", "categories": "算法刷题, PAT", "tags": "模拟", "date": "2022-06-16 15:57:00 +0000", "snippet": "A1054. The Dominant Color#include&lt;iostream&gt;#include&lt;unordered_map&gt;using namespace std;int main(){ int M,N; cin&gt;&gt;M&gt;&gt;N; unordered_map&lt;string, int&gt; m;//用来记录相同像素值...", "content": "A1054. The Dominant Color#include&lt;iostream&gt;#include&lt;unordered_map&gt;using namespace std;int main(){ int M,N; cin&gt;&gt;M&gt;&gt;N; unordered_map&lt;string, int&gt; m;//用来记录相同像素值的个数 for(int i = 0; i &lt; N; i++) { for(int j = 0; j &lt; M; j++) { string color; cin&gt;&gt;color; m[color]++; } } int max = -1; string ans; //找到最大的 for(auto each : m) { if(each.second &gt; max)//如果某个个数大于max { ans = each.first;//更新主要颜色 max = each.second; } } cout&lt;&lt;ans;}    直接使用哈希表轻松解决。A1063. Set Similarity#include&lt;iostream&gt;#include&lt;set&gt;#include&lt;cstdio&gt;using namespace std;int calShared(set&lt;int&gt; a, set&lt;int&gt; b){ int cnt = 0; set&lt;int&gt;:: iterator aIndex = a.begin(), bIndex = b.begin();//双指针 //当两个指针都还指向合法的数据时 while(aIndex != a.end() &amp;&amp; bIndex != b.end()) { //开始分情况 if(*aIndex == *bIndex)//如果两个数字相等 { cnt++; aIndex++; bIndex++; } else if(*aIndex &gt; *bIndex)//如果a指针比b指针所指数字大 { bIndex++; } else//如果b指针比a指针所指数字大 { aIndex++; } } return cnt;}int main(){ int N,M,K;//N个set，每个set有M个数，有K次询问 cin&gt;&gt;N; set&lt;int&gt; s[N + 1]; for(int i = 1; i &lt;= N; i++)//N个set { cin&gt;&gt;M;//一共有M个数存入一个set while(M--) { int num; cin&gt;&gt;num; s[i].insert(num);//自动去重加从小到大排序 } } //处理询问 cin&gt;&gt;K; while(K--) { int a, b; cin&gt;&gt;a&gt;&gt;b;//保存两个set的序号 //计算两个set重叠的部分 int shared = calShared(s[a], s[b]); //计算百分比并打印 if(K != 0)//当不是打印最后一行时 { printf(\"%.1f%%\\n\",(double)(100*shared) / (double)(s[a].size() + s[b].size() - shared)); } else printf(\"%.1f%%\",(double)(100*shared) / (double)(s[a].size() + s[b].size() - shared)); }}    这道题乍一看挺简单，但还是得想那么一下。    思路：将数据存放在set，会自动排序+去重，使用双指针法计算两个set重叠的部分，最后再计算比例    注意： set&lt;int&gt;即可，不需要两个int 初始化不能像vector那样用()，得用[] 不能像vector使用下标，得用迭代器 迭代器的声明：set&lt;int&gt; :: iterator it = s.begin();//注意不要拼错 提取迭代器所指的数值：*it； printf打印%号时，要打两个%% 小结    写完这道题时已经十一点多了，有点晚了，不写第三题了，回宿舍睡觉了。" }, { "title": "Learn How To Make A 2D Platformer In Unreal Engine 5学习笔记#3Hud和投掷斧子", "url": "/posts/Learn-How-To-Make-A-2D-Platformer-In-Unreal-Engine-5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3Hud%E5%92%8C%E6%8A%95%E6%8E%B7%E6%96%A7%E5%AD%90/", "categories": "Unreal5, Learn How To Make A 2D Platformer", "tags": "学习笔记, 蓝图", "date": "2022-06-16 14:00:00 +0000", "snippet": "demo演示视频：Learn How To Make A 2D Platformer In Unreal Engine 5学习记录#3Hud和攻击3.1Creating a HUD For The Players Health 添加hearts图片资源 打开2dCharacter文件夹，右键-&gt;user interface-&gt;widget blueprin...", "content": "demo演示视频：Learn How To Make A 2D Platformer In Unreal Engine 5学习记录#3Hud和攻击3.1Creating a HUD For The Players Health 添加hearts图片资源 打开2dCharacter文件夹，右键-&gt;user interface-&gt;widget blueprint,命名Heart_WB,进入 先搜索panel，先拖进去一个canvas panel，教程里自带panel，但我这个版本没有，所以得自己加上 在palette搜索image，拖入，并在detail中的brush的image改为heart，调整size和position，命名FullHeart 复制FullHeart，命名NoHeart，修改image 前往角色的蓝图，创建Health变量（float），设置为5 回到编辑器，创建PlayerHud_WB，进入 拖进一个Wrap Box，将锚点（anchors）设置为top middle 在details搜索wra，找到explicit wrap size，勾选，并设置size为1500，进入graph，右上角 只留下 event construct节点，其余删掉 event construct节点指向cast to 2dCharacter节点，其中的object指向Get Player Character节点 右键cast to 2dCharacter节点的As 2d character，生成变量2DCharacter 进入角色蓝图中的construction script（就是构造函数）蓝图中，创建变量HeartContainers（int），拖入set HeartContainers 拖入get health，并连接set HeartContainers节点 construction script节点执行set HeartContainers节点 前往PlayerHud_WB的蓝图，set 2DCharacter节点（刚才生成变量时自动生成的）指向for loop节点，first设置为1 set 2DCharacter节点指向get heart container节点，get heart container节点再指向for loop的last index for loop指向create widget节点，并选择Heart_WB， 进入Designer mode（右上角） 选中之前创建的wrap box，再details中，勾选 is variable 回到Graph mode，可以看到左侧变量中有了wrap box_0，拖入get wrap box_0节点 get wrap box_0节点指向add child to wrap Box create widget节点的return value 指向add child to wrap Box的content 创建变量HeartRef（Heart WB（Array）） 拖入get HeartRef，指向add节点 create widget节点的return value 指向add节点 create widget节点执行add节点，add节点再指向add child to wrap Box节点 前往角色蓝图，去event beginplay节点板块，set节点指向create widget ，选择playerHud_WB 将create widget节点的return value 生成变量Playerhud，set Playerhud节点指向 add viewport节点 3.2Setting Up What Happens When The Player Is Damaged 前往heart_wb的蓝图，创建自定义事件RemoveHeart 拖入get fullheart，指向set visibility，hidden 进入2d character蓝图，创建event anydamage节点 拖入get health节点，并-1后set heath，event anydamage节点执行set节点 前往player heart蓝图，创建自定义事件updatehealth，拖入get heart ref节点，指向for eachloop的array，updatehealth执行这个loop 拖入get heart ref，计算length（length节点），再减1 array index == 步骤6的输出，作为一个branch的条件 loop执行这个branch loop的 array element 指向 remove heart branch的true指向这个removeheart节点 最后再remove掉heart ref里面的这个元素：拖入heart ref节点，指向remove节点的array，removeheart节点执行remove节点，最后for each loop的array element指向remove的item 回到2d character蓝图，在刚才的板块最后拖入PlayerHud节点，并执行updateHealth节点 为了测试，加一个节点，搜索1，按下1时执行set health 3.3Creating A Screen Shake Effect 新建蓝图，搜索shake，创建MatineCameraShake，命名damageCameraShake 进入蓝图，设置以下参数： 进入2d character蓝图 在updateHealth节点后执行Play world camera shake节点，shake选择刚创建的shake 创建get actor location节点，连接epiccenter orient shake towards epiccenter勾选 outer radius 500 3.4Setting Up Melee Attack Pt 1 删掉10、11、12attack精灵图后创建flipbook 添加action mapping，meeeAttack（左键）和projectileAttack（x） 进入角色蓝图 新建MeleeAttack节点，如果不在falling和wallslide就攻击 创建变量isAttackinng（bool） 前往动画处理板块 在检测不在falling状态下，来检查是否在isAttacking状态，不在就执行以前的节点，在的话就设置我i攻击动画（为动画创建变量AttackingAnimation） 回到按键触发攻击板块，获取攻击动画的total duration（运行后查看是0.6） 添加delay节点，0.6s后停止动画，设置isAttacking为false 3.5Setting Up Melee Attack Pt 2 在delay节点后创建sequence then1指向线追踪检测节点（lineTrace for objects），start：actor位置，end为朝向的100距离，objects type指向make array，选择pawn，action to ignore指向make array，选择self，out hit指向break hit result节点 hit actor指向apply damage节点，base damage设置1 线追踪检测节点执行apply damage节点 3.6Setting Up Ranged Attack 进入objects文件夹，拖入axe资源 创建actor蓝图类，命名Axe add paper sprite，设置为刚添加的axe，scale设置为2 add projectile movement，initial 和max speed分别设置为200、500 设置gravity = 1 点击simulation可以演示 add rotating movement，rotation rate的Y设置为-180 前往2dCharacter蓝图，新建projectileAttack节点，指向spawnActor Axe节点，并split transform 进入viewport视图，Add scene，命名AxeSpawn，放到合适的位置（斧子生成位置） 返回蓝图视图，拖入AxeSpawn，指向get world location节点，并连接spawnActor Axe节点的transform 提譬如 ismovingright，指向select节点，false的话z设置为180 去设置axe，scale5，速度设置为1000 创建变量：NumOfAxe：10 再扔斧子之前检查是否有斧子，有才能扔，并且扔了就要减1 3.7Displaying Projectiles On The HUD 前往PlayerHud_WB，添加horizontal box，并在其下添加3个text和1个img（img也可以外挂） 点击一个text，在detail的content下，点击bind，绑定2dcharacter的numofaxe变量，第二个text为“/”，第三个为MaxAxe，img为斧子精灵图 修改text的padding，right统统设置10，size可以设置为fill 3.8Adding Projectile Pick Up 创建actor，命名AxePick add paper sprite，设置为axe，调整scale5，在details中的collision中的collision presets设置为nocollision add box collision，调整box extent 找到details的events为其添加on component begin overlap（重叠）事件 other actor指向cast 2d character节点，接下来设置增加斧子数量，需要注意的是： 创建Noofaxe变量作为斧子能够增加的数量 使用clamp节点控制斧子数量不能超过maxAxe set完后消失，指向destrory节点 效果：" }, { "title": "曾经我也想过一了百了", "url": "/posts/%E6%9B%BE%E7%BB%8F%E6%88%91%E4%B9%9F%E6%83%B3%E8%BF%87%E4%B8%80%E4%BA%86%E7%99%BE%E4%BA%86/", "categories": "摄影", "tags": "生活", "date": "2022-06-15 04:49:00 +0000", "snippet": " 数字摄影大作业——“曾经我也想过一了百了” 数媒1902 张召寒 1191190218 摘要：    这个主题源于岛美嘉演唱的一首歌曲《曾经我也想过一了百了》。这个选题是我这学期最繁忙也最焦虑的时期定下的，当时面临着大创结题、各种大作业以及保研文书的各种准备，每天早晨都是被焦虑叫醒的，甚至由于那段时期的繁忙而熬夜、不规律饮食还引起了一些疾病，正像这首曲子的题目一样，痛苦万分的...", "content": " 数字摄影大作业——“曾经我也想过一了百了” 数媒1902 张召寒 1191190218 摘要：    这个主题源于岛美嘉演唱的一首歌曲《曾经我也想过一了百了》。这个选题是我这学期最繁忙也最焦虑的时期定下的，当时面临着大创结题、各种大作业以及保研文书的各种准备，每天早晨都是被焦虑叫醒的，甚至由于那段时期的繁忙而熬夜、不规律饮食还引起了一些疾病，正像这首曲子的题目一样，痛苦万分的我何曾没有想过一了百了，但是，我知道坚持下去一定会柳暗花明，就像曲子的最后，因为一个人的出现让主角觉得悄悄喜欢上了这个世界。所以，尽管这首曲子看似是首表达痛苦的心情，但实际上是想表达因为某人的出现才会让“一了百了”这个想法变为“曾经”。虽然我并没有遇到这么样一个人，但度过了那么段让人身心俱疲的时期后，能让我更清晰地认识到自己真正想要追求的真物。    我用摄影的方式记录了曲子中的一些歌词的意象，也是我这段时期生活的写照。    其中1，2，3，5，9，11，12是在学院影棚拍摄。    1，2，3，5，10进行过后期微调，所以参数仅为拍摄时相机参数。1. 杏花 焦距 快门 光圈 白平衡 感光度 曝光补偿 30mm 1/125s f16 手动 200 0     这张照片源于歌词中“我曾想死是因为，生日那天杏花又开放”，其实这句歌词起初没太懂，为什么看到美丽的事物会想死的，查了下才发现是这样的： 一个人在负能量满满的时候过生日必然是开心不起来的，反之，会因为自己遭遇的种种而怀疑人生意义，生出“我为什么要生下来”、“做人好累”之类的消极想法。     那如果TA在这时看到一树杏花开得明艳，树下躺着一只虫子的死尸，又会想到什么呢？     这张照片拍摄时，白平衡开的手动，忘记调整了，导致画面色温过高，我认为太暖的色调与主题并不相符，所以后期降了点色温，提高了点饱和度，凸显杏花。    当时拍摄的时候不仅已经过了杏花开放的时节，而且还在封校，所幸网上有卖标本的。2. 薄荷糖 焦距 快门 光圈 白平衡 感光度 曝光补偿 30mm 1/80s f13 手动 200 0     这张照片就源于歌词中提到的”薄荷糖“，那一段列举了一连串的生活中的物品、景象。选这个薄荷糖拍其实就是正好能在华联买到，像渔港灯塔、生锈的拱桥，根本没法去拍……    这张也跟上一张一样，色温偏高了，后期降了下。3. 鞋带松开 焦距 快门 光圈 白平衡 感光度 曝光补偿 30mm 1/125s f16 手动 200 0     这张照片源于歌词”我曾想死是因为鞋带松开了，不擅长重新系起，与人的牵绊亦是如此“。其实这一点我和演唱者不太相似，因为我的朋友们对我还是很好的。    这张也和上一张一样，色温偏高，后期降了点色温。4. 楼上的噪音 焦距 快门 光圈 白平衡 感光度 曝光补偿 30mm 1/80s f13 自动 200 0     这张照片来源于”楼上的噪音，电话的铃声，塞起的耳朵，那笼中的少年“。这是小提琴的消音器，因为平时在宿舍练琴，制造噪音的其实是我 。5. 电话铃声 焦距 快门 光圈 白平衡 感光度 曝光补偿 30mm 1/125s f16 手动 200 0     这张照片来源于”楼上的噪音，电话的铃声，塞起的耳朵，那笼中的少年“。    因为拍的时候，闪光灯的原因导致屏幕很暗，所以后期在局部提高了点曝光，让手机屏幕亮了一点，醒图app还挺方便，功能齐全，操作简单。6. 笼中的少年 焦距 快门 光圈 白平衡 感光度 曝光补偿 22mm 1/250s f4.5 自动 100 0     这张照片同样源于歌词”楼上的噪音，电话的铃声，塞起的耳朵，那笼中的少年“。    这是当时课程ppt说让拍黑白照片时去拍的，直接用的是相机的黑白颗粒滤镜，拍下摄像头，其实就是想表达我们在封校的情况下，与”笼中的少年“无异。7. 废弃的自行车 焦距 快门 光圈 白平衡 感光度 曝光补偿 22mm 4s f5.6 自动 500 0     这张照片源于歌词中的”废弃的自行车“。其实有点牵强 。    这是讲完光效那节课后拍的，室友买了个能挂载到自行车气孔的灯，就是为了拍光效的照片。因为要开慢快门，完全没办法手持，当时又没有三脚架，试了下我的谱架，把相机放在谱架上，手扶着就行了。8. 洒下的阳光 焦距 快门 光圈 白平衡 感光度 曝光补偿 5mm 1/250s f1.8 自动 100 0     这张照片源于”若是在那洒下的阳光里打盹“。    这张于学院楼拍摄，当时正在前往厕所的路上，碰巧发现了这一幕，感觉很漂亮，就拿手机拍了下了，仅仅拍了十分钟，这束光就变了样子，没法再拍了。原图更大一些，这是裁剪后的。9. 梦想 焦距 快门 光圈 白平衡 感光度 曝光补偿 85mm 1/125s f16 手动 100 -0.3     这张源于《Tody》中的歌词”有限，总之我不相信明天啊，因为如果今天是最后的话，就是充满懊悔的人生，所以我要用今天，树立远大的理想，实现它“。这首曲子虽然不是《曾经我也想过一了百了》但它属于《曾经我也想过一了百了》的专辑。    其实这也是我的人生观了，为了明天不后悔，那么今天就尽力而为。    这个水杯是在影棚的桌子上发现的，正好拿来做道具了。10. 樱花 焦距 快门 光圈 白平衡 感光度 曝光补偿 2mm 1/60s f2.4 手动 1600 +2     这张照片源自于《当樱花翩翩起舞》中的”樱花纷飞时，我独自一人“，同样是属于《曾经我也想过一了百了》的专辑。    这个地方就在三食堂门口，可以说是非常著名了，经常见到有人拍这个樱花树下的路灯，亲眼见到更漂亮，由于是手机拍的，效果没那么好。    11. 伤痕累累 焦距 快门 光圈 白平衡 感光度 曝光补偿 30mm 1/80s f13 自动 200 0     接下来两张照片就和歌词无关了，但和主题还是有点关系的。    这是小提琴的松香，用微距镜头拍摄。12. 骄傲的琴头 焦距 快门 光圈 白平衡 感光度 曝光补偿 30mm 1/80s f11 自动 200 0     这是小提琴的琴头，同样用微距镜头拍摄。" }, { "title": "UE5 Outliner中显示部分资源为灰色并且注释unload", "url": "/posts/UE5-Outliner%E4%B8%AD%E6%98%BE%E7%A4%BA%E9%83%A8%E5%88%86%E8%B5%84%E6%BA%90%E4%B8%BA%E7%81%B0%E8%89%B2%E5%B9%B6%E4%B8%94%E6%B3%A8%E9%87%8Aunload/", "categories": "Unreal5, 问题总结", "tags": "学习笔记, 问题解决", "date": "2022-06-14 14:17:00 +0000", "snippet": "    今天一打开UE5的场景，发现角色和小怪都不见了，一看Outliner，显示两个actor都变灰色了，并且注释着（unload），google了一下：        一开始还不知道这world partition是什么，又搜了下world partition，才知道是这个：先左键长按拖拽选中全部   再右键，选第一个全加载就可以了", "content": "    今天一打开UE5的场景，发现角色和小怪都不见了，一看Outliner，显示两个actor都变灰色了，并且注释着（unload），google了一下：        一开始还不知道这world partition是什么，又搜了下world partition，才知道是这个：先左键长按拖拽选中全部   再右键，选第一个全加载就可以了" }, { "title": "PAT-Raffle for Weibo Followers & Shortest Distance & A+B and C (64bit)", "url": "/posts/PAT-Raffle-for-Weibo-Followers-&-Shortest-Distance-&-A+B-and-C-(64bit)/", "categories": "算法刷题, PAT", "tags": "模拟", "date": "2022-06-14 10:44:00 +0000", "snippet": "A1124. Raffle for Weibo Followers#include&lt;iostream&gt;#include&lt;unordered_map&gt;using namespace std;int main(){ int M,N,S;//M:粉丝人数，N:中奖人数间隔, S:开始的人序号（从1开始） cin&gt;&gt;M&gt;&gt;N&gt;&gt;...", "content": "A1124. Raffle for Weibo Followers#include&lt;iostream&gt;#include&lt;unordered_map&gt;using namespace std;int main(){ int M,N,S;//M:粉丝人数，N:中奖人数间隔, S:开始的人序号（从1开始） cin&gt;&gt;M&gt;&gt;N&gt;&gt;S; if(S &gt; M) cout&lt;&lt;\"Keep going...\";//开始序号大于粉丝数 else { unordered_map&lt;string, int&gt; m;//用来查重 string names[M + 1]; //将名字放在数组中 for(int i = 1; i &lt;= M; i++)cin&gt;&gt;names[i]; //开始抽奖 int index = S; m[names[S]]++;//加入map cout&lt;&lt;names[S]; index += N; while(index &lt;= M) { if(m.count(names[index]))//如果已经中过奖 { index++; } else//如果没中过奖 { m[names[index]]++;//加入map cout&lt;&lt;endl&lt;&lt;names[index]; index += N; } } }}    这道题太折磨了，本来挺简单的题，让我玩复杂了。我一开始为了省这一千个数组的空间复杂度，想挨个遍历，结果就问题重重，用取余来算，还有特判，最后只拿了17分（满分20），最后一个样例没通过，后来又改，结果改的四不像。最后还是选择了最简单的思路拿最多的分。这道题给我的教训是，拿分就行了，别老搁那想优化了嗷，优化半天代码量蹭蹭往上涨，bug也蹭蹭涨，就省那么点空间复杂度，真不值。    PAT全英文+大量description，多少有点折磨了，但还是得适应，想念leetcode的第2天。A1046. Shortest Distance#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;vector&gt;using namespace std;int main(){ //数据读入 int N, M;//N:节点个数, M:询问次数 cin&gt;&gt;N; //将每个节点的举例储存在数组中 vector&lt;int&gt; dis(N + 1);//因为要从1开始，所以多申请一个空间 for(int i = 1; i &lt;= N; i++) { cin&gt;&gt;dis[i]; } //储存前缀和 vector&lt;int&gt; pre(N + 1); int sum = 0; pre[0] = dis[N];//0节点就储存从最后一个节点走到开头的距离 //计算前缀和，计算从1节点到该位置需要走的距离 for(int i = 1; i &lt;= N; i++) { pre[i] = sum; sum += dis[i]; } //开始处理询问 cin&gt;&gt;M; while(M--) { int x,y;//储存两个位置 cin&gt;&gt;x&gt;&gt;y;//读入 //计算最短距离，两种情况，要么直达，要么反向直达 int minIndex = min(x, y);//获取小坐标 int maxIndex = max(x, y);//获取大坐标 if(M != 0)//没处理到最后一个，都输出换行 { //pre[maxIndex] - pre[minIndex] = 正向直达，从小坐标直接走到大坐标 //pre[N] - pre[maxIndex] + pre[minIndex] + pre[0] = 反向直达 //先从大坐标走到结尾，再从结尾走到小坐标 //二者取小值打印 cout&lt;&lt;min(pre[maxIndex] - pre[minIndex], pre[N] - pre[maxIndex] + pre[minIndex] + pre[0]); cout&lt;&lt;endl; } else//处理到最后一个, 不输出换行 { cout&lt;&lt;min(pre[maxIndex] - pre[minIndex], pre[N] - pre[maxIndex] + pre[minIndex] + pre[0]); } }}    这道题是典型的前缀和，没什么多说的，需要注意的就是前缀和算哪一部分，包不包含自己节点，还有就是边界处理。    由于PAT的题需要写头文件，所以经常会因为漏写头文件而导致编译错误，还要继续适应。A1065. A+B and C (64bit)#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int main(){ int N;//记录有几组数据 scanf(\"%d\", &amp;N); for(int i = 1; i &lt;= N; i++) { long long a,b,c; bool flag; scanf(\"%lld %lld %lld\", &amp;a, &amp;b, &amp;c); long long sum = a + b;//求和 //判断溢出情况： //正溢出，肯定大于c if(a &gt; 0 &amp;&amp; b &gt; 0 &amp;&amp; sum &lt;= 0)flag = true; //负溢出，肯定小于c else if(a &lt; 0 &amp;&amp; b &lt; 0 &amp;&amp; sum &gt;= 0)flag = false; //正常情况 else flag = sum &gt; c; if(flag)// { //cout&lt;&lt;\"Case #\"&lt;&lt;i&lt;&lt;\": \"&lt;&lt;\"true\"&lt;&lt;endl; printf(\"Case #%d: true\\n\", i); } else printf(\"Case #%d: false\\n\", i); //cout&lt;&lt;\"Case #\"&lt;&lt;i&lt;&lt;\": \"&lt;&lt;\"false\"&lt;&lt;endl; }}    这道题，我起初想用字符串的运算，但好麻烦，看了别人的，直接算，去判断是否溢出就行了。而且有一件十分诡异的事情，就是，同样的代码，使用cin和cout的话，最后一个测试点就无法通过，但使用printf和scanf的话，就能通过，而且错误不是超时，是答案错误。    这道题再次给我的教训就是，能暴力模拟就别想着花里胡哨。" }, { "title": "Learn How To Make A 2D Platformer In Unreal Engine 5学习笔记#2小怪巡逻状态", "url": "/posts/Learn-How-To-Make-A-2D-Platformer-In-Unreal-Engine-5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2%E5%B0%8F%E6%80%AA%E5%B7%A1%E9%80%BB%E7%8A%B6%E6%80%81/", "categories": "Unreal5, Learn How To Make A 2D Platformer", "tags": "学习笔记, 蓝图", "date": "2022-06-13 15:43:00 +0000", "snippet": "demo视频地址：# Learn How To Make A 2D Platformer In Unreal Engine 5学习记录#2小怪巡逻状态2.1How we are going to set up are enemy characters 在sprite文件夹中创建Enemies文件夹并将资源的Enemies文件夹内容拖入 在Enemies文件夹右键（在C...", "content": "demo视频地址：# Learn How To Make A 2D Platformer In Unreal Engine 5学习记录#2小怪巡逻状态2.1How we are going to set up are enemy characters 在sprite文件夹中创建Enemies文件夹并将资源的Enemies文件夹内容拖入 在Enemies文件夹右键（在Create advanced asset下）blueprints -&gt; enumeration，命名ListOfEnemies，双击打开，点击new（我这里是add enumerator）新建三个enumerators，命名分别为：MushroomEnemy，GoblinEnemy，FlyingEnemy，（我已经受不了一会大写一会小写了，教程中的老师MushroomEnemy的e小写了，蚌埠住了），点击save保存 2.2Setting Up Structures 在Enemies文件夹右键（在Create advanced asset下）blueprints -&gt; structure，命名EnemyStructure，双击进入 创建一个New Variable，变量类型为之前创建的ListOfEnemies，命名为EnemyType 修改default values至GoblinEnemy（其实选啥都行应该） 创建7个New Variable，类型：paperFlipbook -&gt; objects reference,命名为：Idle、Moving、Attacking、Ranged Attack、Damaged、Die、Dead Body 2.3Setting Up The Data Table 在Enemies文件夹右键Miscellaneous-&gt;data table,命名EnemyDataTable。 EnemyDataTable中点击add，创建一个mushroomEnemy的数据表 前往Enemies文件夹中的mushroomEnemy文件夹 ，创建Attack, Idle, Death, Run, RangeAttack, Projectile(炮弹), Damaged文件夹 将怪的精灵图申请Paper2d后再Extract Sprite Sprite Extract选Grid Cell Width:150(被分成8份),点击Extract即可提取 创建flipbook——MushroomAttack 重复以上工作，制作damaged、idle等flipbook 奖Death_Sprite_3制作成flipbook：MushroomDeadBody 回到EnemyDataTable为蘑菇怪添加动画 2.4Modifying The Data Table 在Enemies文件夹创建Enemy_BP文件夹 在里面创建蓝图-&gt;paperCharacter，命名Enemy Enemy蓝图的Sprite设置为EnemyIdle Scale放大为3.5，降低capsule的height至64 调整精灵位置 拖入场景中 进入蓝图，创建变量，类型为ListofEnemy，命名enemyType并设置 进入事件图中，删掉Event Tick和Event ActorBeginOverlap节点 Event BeginPlay节点指向Get Data Table Row names节点，选择Enemy Data Table Get Data Table Row name节点指向For Each Loop节点(Out Row Names 和 Array连接) For Each Loop节点再指向一个新的Get Data Table Row 节点（Array element和Row name连接），右键out row，split 拖入Get EnemyType节点 指向Equal(Enum)，Get Data Table Row 节点的Out RowEnemy Type 和Equal(Enum)节点相连 Equal(Enum)节点作为新建的branch节点的condition Get Data Table Row 节点的Row Found指向Branch节点 为Get Data Table Row 节点的每一个动作out添加变量，并拖入set类型的节点，branch的true连接Idle的节点，然后一次连接其余动作节点 以上节点意思就是通过遍历data table，匹配目标，利用其预设的动画，为paperCharacter的flipbook类型的变量赋值 2.5Creating The Enemy Pt 1 进入蓝图，新建Event Tick节点（看到这蚌埠住了，之前为啥要删掉哈哈哈哈） 新建自定义事件节点：Handle Animation 新建自定义事件节点：Handle Movement Event Tick节点指向新的Handle Animation节点，新的Handle Animation节点再指向新的Handle Movement节点（其实就是再update函数里写俩脚本运行） 接下来创建一套节点，判断当有速度时选择设置flip book： 添加一个float变量enemyDirection默认值是1 Handle Movement节点指向sequence节点 拖入Get Movement Directon节点，当大于0时，作为branch的条件，sequence节点的then 0指向branch节点 branch的true和false指向SetActorRoatation节点，其中false的SetActorRoatation节点的z要设置为180 sequence节点的then 1指向add movement input节点，其x设置为1，scale连接get enemy direction节点 2.6Creating The Enemy Pt 2 承接上回，add movement input节点指向Line trace by channel节点 新建GetActorLocation节点，指向Line trace by channel节点的start参数 新建Get actor forward vector节点指向multiply，x设置10（但我听他说的是 a hundred fifty，麻了），再加上刚才的location作为Line trace by channel节点的end。x就是150，他说对了，但写错了哈哈 Line trace by channel节点的return value作为一个branch的condition true指向do once节点，completed指向character movement的set max walk speed节点 set max walk speed节点指向delay节点，将duration生成一个变量waitTime，设置为2 delay节点再指向character movement的set max walk speed节点，为walk speed创建一个变量enemyWalkSpeed，设置为400（将设置enemyWalkSpeed的这三个节点拖到设置怪物动画板块） set max walk speed节点后再设置下速度，将速度*-1即可 将set enemy direction节点再指向 do once 节点的reset（双击连接线可以增加控制点调整曲线） 点击运行按钮那一行里后面的三个点按钮，选择simulate可以直接在编辑视图运行 进入蓝图，选择enemieDirection 在details中将instance editable和expose on spawn勾选就可以在编辑模式下修改这个值了 为了让怪物判断悬崖，添加以下节点来检测前方是否有地板 在add movement input节点后添加sequence节点，0还是指向的检查墙壁板块的节点，1指向检查地板，节点和检查墙壁类似，粘贴过来复用 将local location节点的z坐标-100用于检测地面是否有碰撞 如过没有碰撞就掉头了，这的branch就可以连接上面写的掉头do once了 效果： " }, { "title": "PAT-Boys vs Girls & Shuffling Machine & Look-and-say Sequence", "url": "/posts/PAT-Boys-vs-Girls-&-Shuffling-Machine-&-Look-and-say-Sequence/", "categories": "算法刷题, PAT", "tags": "模拟", "date": "2022-06-13 07:42:00 +0000", "snippet": "1036.Boys vs Girls#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;struct stu{ string name; char gender; string ID; int grade;};bool compM(stu s1, stu s2){ return...", "content": "1036.Boys vs Girls#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;struct stu{ string name; char gender; string ID; int grade;};bool compM(stu s1, stu s2){ return s1.grade &lt; s2.grade;}bool compF(stu s1, stu s2){ return s1.grade &gt; s2.grade;}int main(){ int N; cin&gt;&gt;N; stu f[N];//女学生 stu m[N];//男学生 int mNum = 0, fNum = 0;//分别代表男女生数量 //数据输入 while(N--) { string _name, _ID; char _gender; int _score; cin&gt;&gt;_name&gt;&gt;_gender&gt;&gt;_ID&gt;&gt;_score; if(_gender == 'M')//男学生 { m[mNum].name = _name; m[mNum].ID = _ID; m[mNum].grade = _score; mNum++; } else//女学生 { f[fNum].name = _name; f[fNum].ID = _ID; f[fNum].grade = _score; fNum++; } } //排序 if(fNum &gt; 0) { sort(f, f + fNum, compF); cout&lt;&lt;f[0].name&lt;&lt;' '&lt;&lt;f[0].ID&lt;&lt;endl; } else cout&lt;&lt;\"Absent\"&lt;&lt;endl; if(mNum &gt; 0) { sort(m, m + mNum, compM); cout&lt;&lt;m[0].name&lt;&lt;' '&lt;&lt;m[0].ID&lt;&lt;endl; } else cout&lt;&lt;\"Absent\"&lt;&lt;endl; if(mNum == 0 || fNum == 0) { cout&lt;&lt;\"NA\"; }else cout&lt;&lt;f[0].grade - m[0].grade;}    PAT的题目跟力扣一个很大的不同就是需要自己写输入，而且一旦自己写输入就意味着代码量比力扣的多很多，这道题目并不难，就是变量太多了，测试的时候有很多编译错误就是变量打错了……1042. Shuffling Machine#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;using namespace std;int main(){ int N;//洗牌次数 vector&lt;int&gt; pos(55);//洗牌位置 vector&lt;string&gt; cards;//牌,不要声明数组大小！不然用不了emplace_back vector&lt;string&gt; tmp(55);//临时数组 //数据输入,牌先初始化（题目竟然不给初始化，岂可修！） cards.emplace_back(\"Null\");//先把0位置占掉 for(int i = 0; i &lt; 4; i++) { string s1; switch(i) { case 0 : s1 = \"S\";break; case 1 : s1 = \"H\";break; case 2 : s1 = \"C\";break; case 3 : s1 = \"D\";break; } for(int j = 1; j &lt;= 13; j++) { cards.emplace_back(s1 + to_string(j)); } } cards.emplace_back(\"J1\"); cards.emplace_back(\"J2\"); cin&gt;&gt;N; for(int i = 1; i &lt;= 54; i++)cin&gt;&gt;pos[i]; //开始洗牌 while(N--) { //先把牌放到临时数组中 for(int i = 1; i &lt;= 54; i++) { //把当前i位置的牌放到pos[i]的位置 tmp[pos[i]] = cards[i]; } //再把临时数组的牌换成cards for(int i = 1; i &lt;= 54; i++) { cards[i] = tmp[i]; } } for(int i = 1; i &lt;= 54; i++) { cout&lt;&lt;cards[i]; if(i != 54) cout &lt;&lt;' '; }}    emmm，这道题最需要注意的地方是，如果初始化给vector了固定空间，那么就不能用emplace_back()函数了！！我这里没有把牌做到0~53的映射，直接用string存了，写了50行代码，我看有个博主写的映射，写了30行代码，但我觉得我这个也挺好读的哈哈哈。1140. Look-and-say Sequence#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;int main(){ int D, N; cin&gt;&gt;D&gt;&gt;N; string d = to_string(D); N -= 1;//第N项，其实是算了N - 1次 while(N--) { //左右双指针 int l = 0, r = 1; string tmp;//临时string，用来存n + 1项 for(; r &lt; d.size(); r++)//遍历右指针 { if(d[r] != d[l])//如果右指针和左指针指的数不一样了 { tmp += d[l] + to_string(r - l);//左指针所指数字+次数 l = r; } } //把最后的数字也加入tmp,无论最后是都相等还是最后一个不相等了，都适用 tmp += d[l] + to_string(r - l); d = tmp;//更新d } cout&lt;&lt;d;}    首先，这道题要先弄清楚题意，不是统计上一个字符串中每种数字一共有几个，而是连续的有几个，一旦不连续了就要重新算的。比如111222333111222就是：1323331323（3个1，3个2，3个3，3个1，3个2）而不是162633.    第二，想用memset就要包含&lt;cstdio&gt;和&lt;cstring&gt;这两个头文件才行小结    今天开始刷pat，比想象中的更费时间，主要还是得熟悉熟悉这个答题的格式，毕竟跟leetCode还是有点区别。每天尽量三道题吧，这样一个暑假应该是能把所有类型刷一遍。" }, { "title": "力扣-不同的二叉搜索树", "url": "/posts/%E5%8A%9B%E6%89%A3-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/", "categories": "算法刷题", "tags": "动态规划", "date": "2022-06-12 04:52:00 +0000", "snippet": "96. 不同的二叉搜索树class Solution {public://动规五部曲//1.确定dp数组和下标i的含义//i个节点组成不同的二叉搜索树个数为dp[i]//2.确认递推公式（j从1到i）//dp[i] += dp[以j为头节点时，左子树节点数量] * dp[以j为头节点时，右子树节点数量]//dp[i] += dp[j - 1]*dp[i - j]//3.初始化dp//dp[0...", "content": "96. 不同的二叉搜索树class Solution {public://动规五部曲//1.确定dp数组和下标i的含义//i个节点组成不同的二叉搜索树个数为dp[i]//2.确认递推公式（j从1到i）//dp[i] += dp[以j为头节点时，左子树节点数量] * dp[以j为头节点时，右子树节点数量]//dp[i] += dp[j - 1]*dp[i - j]//3.初始化dp//dp[0] = 1;//空节点算一种//4.遍历顺序：从前往后//5.举例验证：//1 2 3 4 n = 4时，dp[4] = dp[0]*dp[3] + dp[1]*dp[2] + dp[2]*dp[1] + dp[3]*dp[0];//1 2 5 14 int numTrees(int n) { vector&lt;int&gt; dp(n + 1); dp[0] = 1; //遍历 for(int i = 1; i &lt;= n; i++) { for(int j = 1; j &lt;= i; j++) { dp[i] += dp[j - 1] * dp[i - j]; } } return dp[n]; }};    今天这题目，感觉挺难想的，特别像找规律的题，我一开始找的规律是这样的：\\[dp[i] = dp[i - 1] + \\sum_{j=0}^{j=i-1}dp[j]\\]    但在第五步推导时，n=4就不对了，所以规律找错了，我也有想到按头节点来分类找，但没想到这个正确的规律。    今天早晨为了等热水，来自习室挺晚了，所以偷下懒，就写一道吧~    我看代码随想录到这道题也有个小结，下面就是背包问题了，刷代码随想录就先到此为止吧，明天开始看胡凡的数据结构，开刷pat了。" }, { "title": "Learn How To Make A 2D Platformer In Unreal Engine 5学习笔记#1角色动作和滑墙系统", "url": "/posts/Learn-How-To-Make-A-2D-Platformer-In-Unreal-Engine-5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/", "categories": "Unreal5, Learn How To Make A 2D Platformer", "tags": "学习笔记, 蓝图", "date": "2022-06-11 15:30:00 +0000", "snippet": "demo视频地址：Learn How To Make A 2D Platformer In Unreal Engine 5学习记录#11.1Introduction 创建blank项目，platformer 2dproject（蓝图模式，默认选项，取消掉初学者内容包） 更改自己喜欢的layout（这里就跟教程选择一样的ue4layout了），点击上方window-&g...", "content": "demo视频地址：Learn How To Make A 2D Platformer In Unreal Engine 5学习记录#11.1Introduction 创建blank项目，platformer 2dproject（蓝图模式，默认选项，取消掉初学者内容包） 更改自己喜欢的layout（这里就跟教程选择一样的ue4layout了），点击上方window-&gt;load layout 1.2Setting up input player input 创建文件夹2DPlatfomerBlueprints 创建蓝图，搜索paperCharacter，创建并命名2dCharacter 设置输入：点击上方Edit-&gt;project settings-&gt;Engine-&gt;input 添加Action Mapping：Jump：Space Bar和Up 添加Axis Mapping：Moveright：Right（Scale 1）和Left（Scale -1） 在初始目录新建文件夹Sprites，再里面新建PlayerCharacterSprites 将HeroSprites中资源拖入文件夹 精灵模糊解决：选中精灵图片-&gt;右键-&gt;Sprite Actions-&gt;Apply Paper2D Texture Settings 为图片创建sprite：选中精灵图片-&gt;右键-&gt;Sprite Actions-&gt;create sprites 为精灵创建flipbook，选中精灵序列，右键-&gt;create flipbook 双击点开flipbook可以在右侧更改播放速度 以同样的方式创建run、jump、full的flipbook 1.3Setting up the player character pt1 双击之前创建的蓝图 选择sprite并使用idle作为源sprite 锁住scale并调整参数至5，调整精灵位置 点击上方event graph 右键创建节点，搜索jump，添加之前创建的action event：Jump 点击Pressed连接Jump，点击released连接Stop Jumping 右键创建节点，添加之前创建的Moveright，点击箭头（exec执行）创建新节点Add movement input，并将Moveright的Axis Value连接至Scale Value，将Add movement input中world Direction设置x=1 在左侧components下点击add添加springArm并点击视图中上侧的旋转按钮，将方向旋转-90° 在springArm添加camera并将投影模式设置为Orthographic（正交投影），Ortho Width设置为1000 在sprites文件夹中创建新文件夹Objects，在里面创建GraySquare文件夹，在里面拖进资源graySquare，并用该图片创建sprite 将之前创建的2dCharacter拖到场景中，在details处搜索pawn，将auto possess pawn设置为player0（游戏开始相机便会锁定角色） 删掉地形（不能直接删父landscape，删不掉，得删完其下的所有，才能删），并将graySquare拖入 更改人物和灰色地块的y为0，并将灰色地块拉长 1.4Setting up the player character pt2 进入2dCharacter中的ViewPort，设置springArm的rotation type为world 在左侧components搜索Character movement并拖到蓝图中，指向get velocity节点，右键split struct pin 将event tick指向print string节点，并将刚才创建的getvelocity节点的x速度与print string的 in string连接便可以打印速度（试试就行了，可以删掉print string节点了） 将get velocity的x指向compare float节点，将event kit指向compare float的exec（执行） 创建get controler节点，return value指向is valid节点（带问号的）的input object compare float节点的&gt;指向isValid的exec get controller节点的return value还要指向set control rotation节点target，isValid节点的isValid再指向set control rotation节点 set control rotation节点的new roatation指向make rotator 复制一份get controler节点、is valid节点、set control rotation节点、make rotator节点 将compare float的&lt;指向复制的isValid的exec，并将复制的make rotator的z改为180 以上是为了当x速度大于0时，人物朝右，小于0时，人物朝左 我看接下来意思要搞一个状态机来判断朝左朝右 InputAxis Moveright节点指向branch，InputAxis Moveright节点的axis value指向greater节点并设置为0，greater节点指向branch的condition 在my blueprint的variables中添加boolean：ismoveingright?并将这个变量拖入蓝图，使用set ismoveingright?节点 将branch的true指向set ismoveingright?节点，并将ismoveingright?勾选 最后将set ismoveingright?节点指向add movement input节点 branch的false节点指向一个新的branch节点（其实这里有点没搞懂） InputAxis Moveright节点的axis value指向less节点设置为0，less节点再指向刚才新建的branch的condition，新branch的true指向一个新建的set ismoveingright?节点 set ismoveingright?节点指向add movement input节点 新branch的false也指向add movement input节点（感觉这一条线会在松开小键盘右键时触发） 前往更改朝向的蓝图区域，将compare float的==指向一个branch，branch的condition分支设置为Get ismovingright，如果true，就执行上方（朝右看）的is Valid，false就执行下方的is Valid 点击左上角compile编译后，设置ismovingright的默认为true 以上是为了当没有移动时，仅仅靠按左右键就能更改人物的朝向（比如现在跳跃时，之前按左右是不能改变朝向的，因为x方向的速度一直没有变的，但加了这部分蓝图后，只要按键就会改变） 1.5Giving The Player Character Animations 选中下面这部分蓝图，按下C键，分组为处理输入事件 新建节点custom event，命名Updateanimation event kit指向一个新建的Updateanimation节点 创建get velocity节点，指向vector length节点再指向greater节点 将左侧component的sprite拖进蓝图，并指向新的节点set flipbook greater指向新建select节点（三个分支），select节点和set flipbook的new flipbook连接 select节点true设置为run，false设置为idle greater节点连接select节点 updateanimation节点连接set flipbook节点 右键select节点的true，点击promote variable生成run的状态，同理生成idle状态 点击左侧 my bluegraph中的variables，为run和idle创建种类文件夹（category）Animation updateanimation节点指向一个branch 将左侧components中的character movement拖到蓝图中，并指向is falling 节点，is falling 节点指向branch的conditon branch的false连接set flipbook，true 复制select和set flipbook节点（用于创建降落时的动画） 创建get velocity节点，并split struct pin，如果z坐标less（新节点）0，连接select节点 设置select节点true为fall动画（z的速度&lt;0说明在下落），false为jump动画 最后将branch的true连接set filpbook 同上，为jump和fall创建variable（Jumping、Falling）（我不知道为啥这里首字母要大写，之前的run和idle不大写） 1.6Changing The Player Characters Speed 点击左侧component中的character movement 在右侧details搜索speed可以看到速度 将character movement拖入蓝图，指向新建的set max walk speed节点 将event beginplay节点（本来就有）连接set max walk speed节点 为max walk speed新建variable：Playerspeed 编译后，点击playerspeed，然后就可以设置速度啦 1.7Adding Sprinting 先利用graysquare创建个台阶 edit -&gt; project settings -&gt; input添加action mappings：sprint，按键为left shift 进入蓝图的处理输入板块 新建sprint节点 拖进来character movement节点指向set max walk speed节点，为其创建variable：SprintingSpeed（我很费解为啥这里的s又大写了，感觉这老师就是随便写的哈哈哈，没太严格的规范） sprint节点的pressed连接set max walk speed节点 设置SprintingSpeed的数值 复制冲刺的节点，改成冲刺完的节点，需要把SprintingSpeed换成之前创建的Playerspeed 1.8Creating Dash Ability 打开蓝图，修改camera的width至2000 编辑下地图 创建dash的fipbook 添加Action Mapping：Dash，按键为Z 前往蓝图中的输入事件板块，创建Dash节点，指向新建的launch character节点（要split struct pin 嗷） 创建get ismovingright节点，指向select节点，select节点的return value 连接launch character节点的launch velocity x select节点的false和true都 设置为2500 勾选launch character节点的XYOverride（试了下，勾没勾没啥区别啊） 由于跳跃时冲刺会冲很远，所以要修改下摩擦力，在蓝图的component中找到character movement，在details中找到jumping/falling，修改falling lateral friction 为2.0 在蓝图的变量中，复制jumping，改为Dash， 将details中的默认值改为dashflipbook（需要先编译一下） 创建一个Boolean变量： isdashing? 将isdashing拖入蓝图（set），使launch character节点指向isdashing?节点，并勾选（true） 将Dash变量拖入蓝图，指向GetTotal Duration，获取动画时间 isdashing?节点指向retriggerable delay节点，并将GetTotal Duration的return value连接retriggerable delay节点的duration 最后retriggerable delay节点再指向set isdashing?节点（这次就不勾了false） 前往处理动画板块 在Update animation节点后添加branch节点，拖入isdashing节点并连接该branch节点，false连接之前的branch 拖入sprite，指向set flipbook节点 将之前创建的dash变量（其实就是dash的flipbook）拖入，连接set flipbook节点的new flipbook 修改下dash的距离：3300，并修改falling lateral friction 为2.5 1.9Creating Wall Slide Mechanic 制作wallSlide的flipbook 进入蓝图，创建custom event节点，命名WallSlidemechanic（不是很懂为什么最后一个单词首字母不大写了） 向上找event tick节点，在Updateanimation节点后指向WallSlidemechanic节点 回到WallSlidemechanic节点处，拖入character movement节点，指向is falling节点 is falling节点指向一个branch的condition WallSlidemechanic节点执行branch branch true指向line trace channel 节点 新建节点：get actor location，其return value 指向line trace by channel 节点的start 新建节点：get actor forward vector，其return value 指向multiply（就是乘个数呗）（split），x设置为50 get actor location节点添加add节点，连接multiply节点和add节点，最后将add节点连接至line trace by channel 节点的end line trace by channel 节点的out hit指向break hit result节点 break hit result节点的Blocking hit指向 set Wallslide?节点（新建的变量），ine trace by channel 节点也要执行set Wallslide?节点 在最开始的branch节点的false指向 set Wallslide?节点（不勾选意味着不是falling状态就不能是wallslide状态） 回到处理动画板块，在判断是否在空中的branch的true后新建branch，用于判断 is Wallslide状态，false就跟以前一样 拖进sprite并指向set flipbook 添加wallslide动画（flipbook）变量 向上找到event tick后面的 wall Slide Mechanic节点，指向一个branch，根据wallslide状态判断，如果false跟以前一样 1.10Creating Wall Jump 前往处理输入事件，在Jump的pressed后添加branch，condition就是Wallslide?，false就跟以前一样，true指向launch character（velocity拆分） 新建get actor forward节点（split（拆分） return value） ，x指向mutiply 节点，mutiply 节点设置为-1500（反向跳跃），再指向launch character的节点中的x 为了跳跃时向上一点，将launch character的节点中的z设置为650 勾选上launch character的节点的XYZ override，这样计算的就是绝对数值而不是相对数值 角色在空中时很难控制，所以在蓝图的components中找到character movement，details中搜索air，将air control设置为1 修改角色的碰撞胶囊在蓝图的components中找到capsule component，拖入动画处理板块中，指向set capsule radius节点，radius设置为1 当is falling的branch是true时，连接set capsule radius节点（记得set capsule radius节点要连上之后的branch节点） 复制capsule component节点和set capsule radius节点，当不再空中时，胶囊半径恢复 将滑墙系统中mutiply节点的x从50改为5（这个距离就是碰撞检测的距离） " }, { "title": "力扣-不同路径 II & 整数拆分", "url": "/posts/%E5%8A%9B%E6%89%A3-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84-II-&-%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86/", "categories": "算法刷题", "tags": "动态规划", "date": "2022-06-11 03:46:00 +0000", "snippet": "63. 不同路径 IIclass Solution {public: //动规五部曲 //1.确定dp数组以及下标的含义 //到达坐标为(i,j)的格子的路径数目为dp[i][j] //2.递推公式：dp[i][j] = //obstacleGrid[i - 1][j] == 0 ? dp[i - 1][j] : 0 //+ obstacleGrid[...", "content": "63. 不同路径 IIclass Solution {public: //动规五部曲 //1.确定dp数组以及下标的含义 //到达坐标为(i,j)的格子的路径数目为dp[i][j] //2.递推公式：dp[i][j] = //obstacleGrid[i - 1][j] == 0 ? dp[i - 1][j] : 0 //+ obstacleGrid[i][j - 1] == 0 ? dp[i][j - 1] : 0; //3.dp数组初始化，先初始化左上角，然后初始化上边和下边 //上边和左边初始化,初始化公式dp[0][j] = dp[0][j - 1];dp[i][0] = dp[i - 1][0] //4.遍历顺序，从（1, 1）从左往右，按行遍历 //5.示例1推导： //1 1 1 //1 0 1 //1 1 2 int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) { int m = obstacleGrid.size(); int n = obstacleGrid[0].size(); //3.先初始化左上角,是石头的话，直接返回0，因为出发点被堵了，哪也去不了 if(obstacleGrid[0][0] == 1) return 0; vector&lt; vector&lt;int&gt; &gt; dp(m, vector&lt;int&gt;(n)); dp[0][0] = 1; //3.把dp数组中最上边和最左边初始化， //最上边一行： for(int j = 1; j &lt; n; j++) { //是石头置0，否则就是上一个位置的路径数 if(obstacleGrid[0][j] == 1) dp[0][j] = 0; else dp[0][j] = dp[0][j - 1]; } //最左边一行 for(int i = 1; i &lt; m; i++) { if(obstacleGrid[i][0] == 1) dp[i][0] = 0; else dp[i][0] = dp[i - 1][0]; } //4.从（1，1）遍历 for(int i = 1; i &lt; m; i++) { for(int j = 1; j &lt; n; j++) { //递推公式 //是石头置0 if(obstacleGrid[i][j] == 1) dp[i][j] = 0; else { dp[i][j] = (obstacleGrid[i - 1][j] == 0 ? dp[i - 1][j] : 0 )+ (obstacleGrid[i][j - 1] == 0 ? dp[i][j - 1] : 0); } } } return dp[m - 1][n - 1]; }};    这道题目是昨天的升级版，有了很多坑。我一开始还是像上次一样初始化最上边和最左边，都设置为1，然后有石头的设置为0，结果就有样例通不过，发现上边和左边不仅有石头的话路径数是0，如果左边或者上边有石头挡路，那么后面的也都是0。所以这道题和上次最大的不同就是初始化，而且要做两次初始化。    还有一点就是，在遍历的过程中，遇到石头置0，不能初始化时把所有石头置0后面就不管了，不然有可能到后面遍历的时候，石头位置被赋值了而且不是0，那就错了。343. 整数拆分class Solution {public: //动规五部曲 //1.确认dp数组和下标的含义 //正整数i的拆分乘积最大为dp[i] //2.确认递推公式：从1到i开始试，选取 只拆成两个 和 拆成大于两个 中较大的一个 //dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j]));//(dp[i - j])拆的项肯定 &gt;= 2 //3.初始化dp数组：只用初始化dp[2] = 1 即可，dp[0]和dp[1] 本身就不能拆 //4.遍历顺序，从小数往大数遍历，即从前往后 //5.举例2推导 n = 10 //2 3 4 5 6 7 8 9 10 //1 2 4 6 9 12 18 27 36（2 * dp[8]） int integerBreak(int n) { vector&lt;int&gt; dp(n + 1); dp[2] = 1; for(int i = 3; i &lt;= n; i++) { //可以取i-2但不取i-1，因为如果取i-1那么就会出现dp[1] for(int j = 1; j &lt;= i - 2; j++) { dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j])); } } return dp[n]; }};    别看代码很短，还挺难想的。主要难点就在于递推公式的推导。把数拆为几项是个问题，首先是拆成两个，其次是拆成多个，拆成多个的话就可以利用之前的值了，也就是dp[i - j]，不得不说，这个思路我一开始是真没想到。    还有要注意的就是初始化，初始化dp[2]就行，在遍历的时候遍历到 j = i -2 就可以了。" }, { "title": "力扣-使用最小花费爬楼梯 & 不同路径 & Vector二维数组初始化方法", "url": "/posts/%E5%8A%9B%E6%89%A3-%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF-&-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84-&-Vector%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95/", "categories": "算法刷题", "tags": "动态规划", "date": "2022-06-10 03:18:00 +0000", "snippet": "746. 使用最小花费爬楼梯class Solution {public://动规五部曲//1.确定dp数组以及下标的含义//爬到第i阶的台阶需要的花费为dp[i]//2.确定递推公式//dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);//3.初始化dp数组//4.遍历顺序，从前往后//5.实例2推导// dp数组...", "content": "746. 使用最小花费爬楼梯class Solution {public://动规五部曲//1.确定dp数组以及下标的含义//爬到第i阶的台阶需要的花费为dp[i]//2.确定递推公式//dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);//3.初始化dp数组//4.遍历顺序，从前往后//5.实例2推导// dp数组：0 0 1 2 2 3 3 4 4 5 6//cost数组：1 100 1 1 1 100 1 1 100 1 int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) { int dp[2]; //初始化dp数组 dp[0] = 0; dp[1] = 0; //遍历 for(int i = 2; i &lt;= cost.size(); i++) { int tmp = min(dp[1] + cost[i - 1], dp[0] + cost[i - 2]); dp[0] = dp[1]; dp[1] = tmp; } return dp[1]; }};    本质上和昨天的爬楼梯是一样的，动规五部曲就可以轻松解决，不一样的就在于递推公式不太一样。62. 不同路径class Solution {public://动规五部曲//1.确定dp数组和下标的含义//到达坐标为（i，j）的格子的路径数目为dp[i][j]//2.确认递推公式//dp[i][j] = dp[i - 1][j] + dp[i][j - 1];//3.dp数组初始化//其实只需要初始化上边和左边一条线，但为了方便就全初始化1了，因为不影响//4.遍历顺序，从（1，1）开始从左往右，一行一行地遍历//5.示例1推导（从1，1）开始// 2 3 4 5 6 7// 3 6 10 15 21 28 int uniquePaths(int m, int n) { //创建数组并初始化： vector&lt; vector&lt;int&gt; &gt; dp(m, vector&lt;int&gt;(n, 1)); //遍历 for(int i = 1; i &lt; m; i++) { for(int j = 1; j &lt; n; j++) { dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } return dp[m - 1][n - 1]; }};    这道题和上一道题也很类似，使用动规五部曲就可以轻松化解，不同的是这个题目需要用到二维数组，正好记录一下c++ vector二维数组的三种初始化方法：C++ Vector二维数组初始化方法第一种int m = 10;int n = 10;//只是开辟空间vector&lt; vector&lt;int&gt; &gt; dp(m, vecor&lt;int&gt; (n));//所有元素初始化为1vector&lt; vector&lt;int&gt; &gt; dp(m, vecor&lt;int&gt; (n, 1));第二种int m = 10;int n = 10;vector&lt; vector&lt;int&gt; &gt; dp = vector&lt; vector&lt;int&gt; &gt;(m, vecor&lt;int&gt; (n));第三种不知道为啥{ {1,2,3},{4,5,6}};总是报错，上传不上去了……int m = 2;int n = 3; vector&lt; vector &gt;dp(m, vecor (n)) = {{1,2,3},{4,5,6}};    Google了一下，发现改法挺搞笑的哈哈哈哈：    然后发现加个空格还是不行……试试这个    蚌埠住了 ……上面两种方法都可以，一直报错是因为“不知道为啥{ {1,2,3},{4,5,6}};总是报错，上传不上去了……”这句话一开始我没加空格也没加raw标签。" }, { "title": "力扣-斐波那契数 & 爬楼梯", "url": "/posts/%E5%8A%9B%E6%89%A3-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0-&-%E7%88%AC%E6%A5%BC%E6%A2%AF/", "categories": "算法刷题", "tags": "动态规划", "date": "2022-06-09 08:31:00 +0000", "snippet": "509. 斐波那契数class Solution {public: //动规五部曲 //1.确定dp数组以及下标的含义： //第i个斐波那契数是dp[i] //2.确定递推公式：dp[i] = dp[i - 1] + dp[i - 2]; //3.dp数组初始化：题目已给出 //4.遍历顺序：从前往后遍历 //5.举例推导： //0 1 1 2...", "content": "509. 斐波那契数class Solution {public: //动规五部曲 //1.确定dp数组以及下标的含义： //第i个斐波那契数是dp[i] //2.确定递推公式：dp[i] = dp[i - 1] + dp[i - 2]; //3.dp数组初始化：题目已给出 //4.遍历顺序：从前往后遍历 //5.举例推导： //0 1 1 2 3 5 8 13 int fib(int n) { if(n &lt;= 1) return n; vector&lt;int&gt; fi(n + 1); //初始化 fi[0] = 0; fi[1] = 1; //遍历顺序 for(int i = 2; i &lt;= n; i++) { fi[i] = fi[i - 1] + fi[i - 2]; } return fi[n]; }};    虽然是一道非常简单的题目，而且之前也做过，但没有从动规五部曲的角度去做，之后的dp题目要按照五部曲来刷~动规五部曲 确定dp数组以及下标的含义 确定递推公式 dp数组初始化 遍历顺序 举例推导 70. 爬楼梯class Solution {public: //动规五部曲 //1.确认dp数组和下标的含义 //爬到第i阶台阶的方法数为dp[i] //2.确定递推公式 //dp[i] = dp[i - 1] + dp[i - 2] //3.dp数组初始化 //4.遍历顺序：从前往后 //5.举例推导 //（从0阶开始）1 1 2 3 5 8 13 int climbStairs(int n) { if(n == 1)return 1; int dp[2]; //3.dp数组初始化 dp[0] = 1; dp[1] = 1; //4.遍历顺序：从前往后 for(int i = 2; i &lt;= n; i++) { int tmp = dp[0] + dp[1]; dp[0] = dp[1]; dp[1] = tmp; } return dp[1]; }};    这道题目本质上和斐波那契数列是一样的，只是递推公式没有给出，而是需要自己算，这次我换了中方式，没有创建n个长度的数组，只用两个空间的数组就可以了。" }, { "title": "力扣-监控二叉树", "url": "/posts/%E5%8A%9B%E6%89%A3-%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91/", "categories": "算法刷题", "tags": "贪心", "date": "2022-06-08 07:14:00 +0000", "snippet": "968. 监控二叉树/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * ...", "content": "968. 监控二叉树/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: //后序遍历+贪心 int result;//记录摄像头个数 //0无覆盖 1有摄像头 2有覆盖 //1.确认返回类型和参数,通过返回值来判断左右孩子的状态 int traversal(TreeNode* root) { //2.中止条件，如果节点是空，那么该节点设置为有覆盖 //不然这个空节点的父节点（叶子节点）要放摄像头了 if(root == nullptr) return 2; //3.每个节点的行为 //后序遍历，先获得左右孩子的状态 int left = traversal(root -&gt; left); int right = traversal(root -&gt; right); //两个孩子只要有其中一个没有被覆盖，那么该节点就要放置摄像头 if(left == 0 || right == 0) { result++; return 1;//设置摄像头 } //两个孩子只要有一个是有摄像头，那么该节点状态为被覆盖 else if(left == 1 || right == 1) { return 2; } return 0;//不放摄像头也没被覆盖，那就还是0 } int minCameraCover(TreeNode* root) { result = 0; if(traversal(root) == 0) result++; return result; }};    这道题，我跟代码随想录的思路是一样的，都是后序遍历+贪心，但我实在太贪，细节没处理好，只能通过部分样例，我没有写traversal函数，直接用原函数递归，结果就有特殊情况（只有一个根节点的时候），分开写后，加了特判，还是不行，原来还是有逻辑漏洞的。还是得根据左右孩子的状态来判断是否设置摄像头，而且特判情况是当根节点没有被覆盖时，都要+1，我之前自己写的特判是，当树只有一个节点时，才会+1，怪不得不能全部通过。    这是代码随想录里贪心章节的最后一题，正好是个困难，那今天就刷一道好了（偷个懒）。明天开动态规划章节，我看dp章节题目挺多的，大概刷一周就继续去刷PAT吧，备战浙大吧还是（还不知道能不能过夏令营初审呢）。" }, { "title": "力扣-单调递增的数字 & 买卖股票的最佳时机含手续费", "url": "/posts/%E5%8A%9B%E6%89%A3-%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E7%9A%84%E6%95%B0%E5%AD%97-&-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9/", "categories": "算法刷题", "tags": "贪心", "date": "2022-06-07 05:44:00 +0000", "snippet": "738. 单调递增的数字class Solution {public: //题目中说到x&lt;=y即可，也就是说299999也是单调递增的 //贪心，局部最优推出全局最优，两个数字，当左边的比右边的大时，左边就可-1右边改为9 //问题在于具体哪一位要-1 int monotoneIncreasingDigits(int n) { string N =...", "content": "738. 单调递增的数字class Solution {public: //题目中说到x&lt;=y即可，也就是说299999也是单调递增的 //贪心，局部最优推出全局最优，两个数字，当左边的比右边的大时，左边就可-1右边改为9 //问题在于具体哪一位要-1 int monotoneIncreasingDigits(int n) { string N = to_string(n); int flag = N.size();//记录从哪里开始改 //不能从前往后遍历，不然会改变已经排好的数，比如339 //从后往前遍历 for(int i = N.size() - 1; i &gt; 0; i--) { //如果左边的数大于右边的数了 if(N[i - 1] &gt; N[i]) { N[i - 1] -= 1; flag = i; } } //将flag之后的所有数字变为9 for(int i = flag; i &lt; N.size(); i++) { N[i] = '9'; } return stoi(N); }};    这道题利用贪心算法，有几点需要注意： 原题目中相等的数也算递增，我忽略了这一点 在遍历过程中需要从后往前遍历，去寻找最靠前的需要退位的数字，我自己开始写的时候，从前往后遍历了，导致出错，339这个成了329，这是不行的 用字符串存数字也挺简单的，不一定非得把数存在整型数组里 714. 买卖股票的最佳时机含手续费class Solution {public: //贪心，要分三种情况 int maxProfit(vector&lt;int&gt;&amp; prices, int fee) { int result = 0;//记录利润 int minPrice = prices[0];//记录最小价格，用于计算买卖后的利润 for(int i = 0; i &lt; prices.size(); i++) { //判断是否要买入，如果价格低，那么minprice就是买入时的价格，只要不买，可以一直更新的 if(prices[i] &lt; minPrice) minPrice = prices[i]; //判断是否卖出,如果当前价格比最小价格+手续费还低，那么不卖 else if(prices[i] &lt;= minPrice + fee) { continue; } else//此时要考虑卖掉 { result += prices[i] - minPrice - fee; //因为不确定这次价格是否为这个区间内最高的价格 //所以要将minPrice置为暂时卖掉的钱-fee， minPrice = prices[i] - fee; } } return result; }};    这道题考虑买入卖出的时机，分三种情况： 要买：当前价格小于最低价格，更新价格； 不卖：如果当前价格高于最低价格但又低于最低价格+手续费； 要卖：如果当前价格高于最低价格+手续费，卖掉当前股票，并更新最低价格。 注意：    当卖掉时，可能只是暂时卖掉，因为有可能此时不是价格区间中最高的价格，所以最低价格要减手续费，这样，当下一个价格高于 minPrice+fee时，就像等于高于上一个股票的原价，那么利润增加价格差，正好手续费也消掉了。    不得不说，这个代码随想录的贪心算法思路还是很巧妙的，挺难想到的。" }, { "title": "力扣-无重叠区间 & 划分字母区间", "url": "/posts/%E5%8A%9B%E6%89%A3-%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4-&-%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4/", "categories": "算法刷题", "tags": "贪心", "date": "2022-06-06 10:30:00 +0000", "snippet": "435. 无重叠区间class Solution {public:static bool cmp(vector&lt;int&gt; &amp;a, vector&lt;int&gt; &amp;b){ return a[0] &lt; b[0];//按左边界从小到大排}//贪心：局部最优推出全局最优//先按左边界排个序//当两个重叠时，删掉右边界较大的一个更好 int eras...", "content": "435. 无重叠区间class Solution {public:static bool cmp(vector&lt;int&gt; &amp;a, vector&lt;int&gt; &amp;b){ return a[0] &lt; b[0];//按左边界从小到大排}//贪心：局部最优推出全局最优//先按左边界排个序//当两个重叠时，删掉右边界较大的一个更好 int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) { int pre = 0;//记录上一个区间（就是指当前区间要和上一个区间进行比对，看是否重叠） int cnt = 0;//记录需要删除几个 //先按左边界排序 sort(intervals.begin(), intervals.end(), cmp); for(int i = 1; i &lt; intervals.size(); i++)//从第二个开始遍历 { //和上一个区间对比,如果 当前左边界 大于等于 上一个左边界 并且 小于上一个右边界 //那么就重叠了 if(intervals[i][0] &gt;= intervals[pre][0] &amp;&amp; intervals[i][0] &lt; intervals[pre][1]) { //此时两者已经重叠，那么删掉右边界较大即可 cnt++; //如果当前的右边界大，难么删掉当前的，pre还是不变，否则删掉上一个，pre更新 pre = intervals[i][1] &gt; intervals[pre][1] ? pre : i; } else//如果不重叠 { pre = i;//更新上一个区间 } } return cnt; }};    先排序，然后贪心。需要注意的是，如果不重叠，也要记得更新pre，因为当两个区间不重叠时，下一个区间就要和上一组两个区间种的第二个区间进行比对。763. 划分字母区间class Solution {public: vector&lt;int&gt; partitionLabels(string s) { //记录每个字母出现的最远下标 int hash[26] = {0}; for(int i = 0; i &lt; s.size(); i++) { hash[s[i] - 'a'] = i;//遇到字符就更新最远下标 } //遍历整个字符串，当遍历位置i和 之前所有字符 最大的出现位置（即最远下标） 相等时 int maxIndex = 0; int left = 0;//记录子串的起始坐标 int right = 0;//记录子串的最远下标 vector&lt;int&gt; ans; for(int i = 0; i &lt; s.size(); i++) { right = max(right, hash[s[i] - 'a']);//更新当前子字符串的最远下标 //如果当前遍历位置与子串中所有字符中的最远下标相等 //（也就是其中个别字符的最远下标已经遍历过去了） if(i == right)//这个点就是分割点 { ans.emplace_back(right - left + 1);//记录子串个数 left = i + 1;//更新 新子串的起始位置 } } return ans; }};    这道题被标记为贪心，但确不能用局部最优推出全局最优，很疑惑，我也没做出来。这是代码随想录的思路，记录每个字母的最远下标，然后去遍历字符串，遇到下标相同（即遍历下标和遍历下标所指字母所对应的最远下标），就作为分割点。" }, { "title": "力扣-根据身高重建队列 & 用最少数量的箭引爆气球", "url": "/posts/%E5%8A%9B%E6%89%A3-%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97-&-%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83/", "categories": "算法刷题", "tags": "贪心", "date": "2022-06-05 03:27:00 +0000", "snippet": "406. 根据身高重建队列class Solution {public: static bool cmp(vector&lt;int&gt; &amp;a, vector&lt;int&gt; &amp;b) { if(a[0] != b[0])//如果第一个数不相等，也就是身高不相等 { return a[0] &gt; b[0...", "content": "406. 根据身高重建队列class Solution {public: static bool cmp(vector&lt;int&gt; &amp;a, vector&lt;int&gt; &amp;b) { if(a[0] != b[0])//如果第一个数不相等，也就是身高不相等 { return a[0] &gt; b[0];//按从大到小排 } else//如果身高相等，那就排第二个数 { return a[1] &lt; b[1];//按从小到大排//为的就是先往结果里插 身高最高 而且 前面比他高的人数最少 的人 } } vector&lt;vector&lt;int&gt;&gt; reconstructQueue(vector&lt;vector&lt;int&gt;&gt;&amp; people) { //先排序 sort(people.begin(), people.end(), cmp); //开始插入 vector&lt;vector&lt;int&gt;&gt; ans; //遍历people每个人 for(int i = 0; i &lt; people.size(); i++) { ans.insert(ans.begin() + people[i][1], people[i]); } return ans; }};    简单的贪心策略，先按身高从大到小排序，身高一样了按第二个值从小到大排序，然后遍历依次插入相应位置。    要注意的是：cmp函数形参要写vector，不能写pair&lt;int, int&gt;，不然会报错。    顺便记录下vector中insert的用法insert用法语法： iterator insert( iterator loc, const TYPE &amp;val ); void insert( iterator loc, size_type num, const TYPE &amp;val ); void insert( iterator loc, input_iterator start, input_iterator end );解释： 在指定位置loc前插入值为val的元素,返回指向这个元素的迭代器, 在指定位置loc前插入num个值为val的元素 在指定位置loc前插入区间[start, end)的所有元素 .452. 用最少数量的箭引爆气球class Solution {public: static bool cmp(vector&lt;int&gt; &amp;a, vector&lt;int&gt; &amp;b) { return a[0] &lt; b[0]; } //贪心，局部最优推出全局最优，每支箭尽可能地多射气球 int findMinArrowShots(vector&lt;vector&lt;int&gt;&gt;&amp; points) { //先按气球左边界从小到大排序 sort(points.begin(), points.end(), cmp); //第一个气球一定是要用一只箭打到的 int cnt = 1;//记录箭矢的数量 int minEnd = points[0][1];//记录每一组气球的最小右边界 //遍历所有气球 for(int i = 1; i &lt; points.size(); i++) { //判断这个气球能否和这一组气球们用一只箭打下来 //当这支箭的左边界超过这组气球的最小右边界时 if(points[i][0] &gt; minEnd) { //这个气球就成了下一组的第一个气球 cnt++;//需要多一支箭 minEnd = points[i][1];//新一组气球的最小右边界 } //如果能加入这组气球，比如第二个气球的左边界就小于第一个气球的右边界 //那么右边界要时刻尝试更新 minEnd = min(points[i][1], minEnd); } return cnt; }};    这道题需要注意的点还挺多的。 核心点：贪心策略怎么贪？  需要先把气球排好序，然后从第一个气球开始，尽可能地每一箭射中（包括第一个）最多的气球，这样局部最优推出全局最优。 怎么排？  按气球的左边界从小到大排就行了 注意点：最小右边界  排序过后可以保证下一个气球的左边界一定大于等于上一个气球的左边界，那么这个气球是否能够加入上一组气球中一起射中，就要看这个气球的右边界了。  如果这个气球的右边界小于等于上一组所有气球中的最小右边界也就是类似这样: （（ （））），中间的（）是这个气球，那么这个气球就可以加入到上一组。  如果这个气球的左边界大于上一组气球中的最小右边界，也就是这样： （（ ）{） }，花括号作为这个气球， 可以看到此时一箭不能射中三个气球了，必须再多射一箭了。 " }, { "title": "复盘基于临界阻尼弦的慢入慢出的平滑方法", "url": "/posts/%E5%A4%8D%E7%9B%98%E5%9F%BA%E4%BA%8E%E4%B8%B4%E7%95%8C%E9%98%BB%E5%B0%BC%E5%BC%A6%E7%9A%84%E6%85%A2%E5%85%A5%E6%85%A2%E5%87%BA%E7%9A%84%E5%B9%B3%E6%BB%91%E6%96%B9%E6%B3%95/", "categories": "Unity3D", "tags": "关键技术, GAME PROGRAMMING GEMS 4, 学习笔记", "date": "2022-06-04 14:57:00 +0000", "snippet": "介绍    平滑（smoothing，也译作校平或修匀）是一个极有用的概念，对于游戏方方面面的质量都起着重要作用。不使用平滑，游戏看起来毛毛糙糙、停停动动，比较生硬；而使用平滑，则可以让游戏变得流畅、精致并且更为自然。本文中使用的“平滑”一词，指的是一种随时间流逝逐渐调整某个值来逼近目标值的方法。我们可以对任何会随时间改变的值进行平滑，无论这个值是标量、矢量、颜色还是角度。因此本文描述的方法...", "content": "介绍    平滑（smoothing，也译作校平或修匀）是一个极有用的概念，对于游戏方方面面的质量都起着重要作用。不使用平滑，游戏看起来毛毛糙糙、停停动动，比较生硬；而使用平滑，则可以让游戏变得流畅、精致并且更为自然。本文中使用的“平滑”一词，指的是一种随时间流逝逐渐调整某个值来逼近目标值的方法。我们可以对任何会随时间改变的值进行平滑，无论这个值是标量、矢量、颜色还是角度。因此本文描述的方法具有广泛的适用性。数学原理    临界阻尼弦的工作原理是什么？该技术基于阻尼弦（一个有阻力的弹簧）。在弹簧末端的点（y）上有一个与弹簧实际长度与其自然长度（即目标位置$y_d$）的改变量成正比的力，这是胡克定律（Hooke’s Law）。此外，阻尼弦上还有一个方向与y点的速度方向相反的阻力。因此，阻尼弦上y点的运动规律可以用如下的微分方程来刻画：\\[m\\frac{d^2y}{dt^2}=k(y_d-y)-b(\\frac{dy}{dt})            (1)\\]    式中 m 是 y 点的质量，k是弹簧常数（或称其为弹簧强度），b是阻尼常数（或者说阻力的大小程度）。这些常数影响弹簧恢复$y_d$长度的过程，在我们讨论平滑函数这个语境下，此过程即是我们的值接近目标值的过程。给 b 一个较小的值，会造成伸缩过头和振荡；如果给b一个较大的值，则有慢慢收敛的效果。临界阻尼在 b位于两个极值中的情况下发生，既不产生振荡，又能以最理想的收敛速率接近 $y_d$。当 $b^2=4mk$时发生临界阻尼。因此，我们可以将公式化简为：\\[\\frac{d^2y}{dt^2}=\\omega^2(y_d-y)-2\\omega\\frac{dy}{dt},其中\\omega=\\sqrt {\\frac km}            (2)\\]w是弹簧的固有频率，也可以说是弹簧硬度或强度的度量。实现    现在看如何实现这个模型。我们的目标是编写一个函数，根据输入的目标位置、时间间隔、以及平滑因子，更新位置和速度，像这样： y = SmothCD(y, desiredY, &amp;velY, smoothness);     y是当前位置，desiredY是目标位置，velY是当前速度（使用引用是为了之后要改变），smoothness是平滑因子    临界阻尼弦模型可以用标准的数值积分方法来逼近，但是事实上这并没有必要，因为存在一个确切的（分析的）闭合解。如下式：\\[y(t)=y_d+((y_0-y_d)+(\\hat y_0+\\omega(y_0-y_d))t)e^{-\\omega t}            (3)\\]    上式中$y_0$是初始位置；$\\hat y_0$则是初始梯度，即速率。    用很小的步长对此式进行微分，我们得到：\\[y_1=y_d+((y_0-y_d)+(\\hat y_0+\\omega (y_0-y_d))\\Delta t)e^{-\\omega \\Delta t}            (4)\\]\\[\\hat y_1=(\\hat y_0-(\\hat y_0+\\omega (y_0-y_d))\\omega \\Delta t)e^{-\\omega \\Delta t}            (5)\\]    两个等式（精确地）给出了经过时间间隔Δ后的新位置和新速度，这正是我们需要的。关于平滑因子，注意我们能够使用$\\omega$来表示，但是一般来说，用平滑时间而不是弹簧强度来控制平滑函数，那样更为直观。对平滑时间的一种定义是“预期的以最高速度到达目标所需的时间”（见图5）。这样的定义是有用的，理由有二。首先，朝移动中的目标进行平滑的时候（由于阻力）它与滞后时间相同，滞后的计算就变得十分简单。其次，它为我们提供了非常简单的换算关系：$\\omega$= 2/smooth time。    仍然有一个问题，那就是指数函数的调用需要付出相当昂贵的计算代价。幸运的是，这在我们的使用范围内可以精确估计。作为结果，下面给出完整的函数。这个函数由我改编成了适用于unity的C#语言。float[] SmoothCD(float from,float to,float vel,float smoothTime) { float[] pos_vel = new float[2];//用于返回新位置和新速度 float omega = 2.0f / smoothTime; float x = omega * Time.deltaTime; float e= 1.0f / (1.0f + x + 0.48f * x * x + 0.235f * x * x * x); float change = from - to; float tmp = (vel + omega * change) * Time.deltaTime; vel=(vel-omega*tmp)*e; pos_vel[0] = to + (change + tmp) * e; pos_vel[1] = vel; return pos_vel; }    书中的代码如下：float SmoothCD(float from,float to,float &amp;vel,float smoothTime) { float omega = 2.f / smoothTime; float = omega * Time.deltaTime; float exp = 1.f / (1.f + x + 0.48f * x * x + 0.235f * x * x * x); float change = from -e to; float temp = (vel + omega * change) * timeDelta; vel = (vel - omega * temp) * exp;//第五个公式 return to + (change + tmp) * exp;//第四个公式    估计$e^x$的近似值方法是运用如下所示的截断的泰勒展开式。我们这里$e^{-\\omega \\Delta t}$幂可以作为$\\frac {1}{e^x}$来计算，其中x为$\\omega \\Delta t$。\\[e^x\\approx \\sum _{i=0}^n \\frac {x^i}{i!}\\]    可以在经常使用的范围里调节系数，以更好地逼近。对我们的函数来说，这范围基本上就是0&lt;x&lt;1。采取以上近似方法计算exp的误差小于0.1%。在PC上，速度也比使用exp0函数要快上差不多 80 倍！通过使用阶数更高的多项式可以给出更准确的近似值。拓展    最后再简短地展示一条便利的扩展：如何来设置平滑速率的上限。由于出发点和运动中的目标之间有滞后距离（大小等于s*smoothTime)的存在，如果和目标之间的距离被限制在不大于滞后距离的范围内，那么s就成了速率的上限。    做法是这样的，在值设定之后，再一次改动它，从而较平稳地接近平滑速率的上限。float maxChange = maxSpeed*smoothTime;change = min(max(-maxChange, change), maxChange);应用与改进    我们将这个算法用于玩家按Shift跑步加速过程，原本是从5到10的一个突变，加入该平滑函数后，它会根据原理加速变得更加平滑，让游戏变得流畅，但这个函数有一个小小的问题，就是在平滑的结尾，总是会趋近于设定的目标值，而不会等于，因此会一直计算，造成计算浪费。所以我们添加的改动是添加边界处理，在接近目标值的位置设置一个阈值，到达阈值则不再调用此函数运算，节省开销。参考文献[1]Kirmse A. GAME PROGRAMMING GEMS 4[M]. 1. 人民邮电出版社, 2003 :80-92." }, { "title": "力扣-分发糖果 & 柠檬水找零", "url": "/posts/%E5%8A%9B%E6%89%A3-%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C-&-%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6/", "categories": "算法刷题", "tags": "贪心", "date": "2022-06-04 06:35:00 +0000", "snippet": "135. 分发糖果class Solution {public: //贪心：局部最优推出全局最优： //右边孩子比左边孩子大，那么就=左边孩子糖果数+1，相反亦如此 //要左右孩子分开考虑，不能同时考虑 int candy(vector&lt;int&gt;&amp; ratings) { vector&lt;int&gt; candies(rating...", "content": "135. 分发糖果class Solution {public: //贪心：局部最优推出全局最优： //右边孩子比左边孩子大，那么就=左边孩子糖果数+1，相反亦如此 //要左右孩子分开考虑，不能同时考虑 int candy(vector&lt;int&gt;&amp; ratings) { vector&lt;int&gt; candies(ratings.size(), 1); //先考虑当前孩子得分比左边的孩子得分高的情况 for(int i = 1; i &lt; ratings.size(); i++) { if(ratings[i] &gt; ratings[i - 1]) { candies[i] = candies[i - 1] + 1;//那么当前孩子就比左边的孩子多一个 } } //再考虑当前孩子比右边孩子大，此时需要从后往前遍历 for(int i = ratings.size() - 2; i &gt;= 0; i--) { if(ratings[i] &gt; ratings[i + 1] &amp;&amp; candies[i] &lt;= candies[i + 1]) { //如果当前孩子糖果比右边孩子少，那么左边孩子比右边孩子多一个（已经大的话就不用加了） candies[i] = candies[i + 1] + 1; } } //求个和 int sum = 0; for(auto i : candies) { sum += i; } return sum; }};    这道题要分开考虑，要先考虑一边再考虑另一边，不能同时考虑一个孩子的左右两个孩子，还要注意在考虑第二边的时候，要注意目前糖果数量的对比，如果经历了第一次遍历，更改了糖果数量，在进行第二次遍历时已经比右边糖果大了，那就不用再+1了。860. 柠檬水找零class Solution {public: bool lemonadeChange(vector&lt;int&gt;&amp; bills) { vector&lt;int &gt; cash(2, 0); //开始卖柠檬水 for(int i = 0; i &lt; bills.size(); i++) { if(bills[i] == 5)//如果顾客支付5刀 { cash[0]++; } else if(bills[i] == 10)//如果顾客支付10刀 { if(cash[0] &gt; 0)//如果有5刀的零钱 { cash[1]++;//10刀零钱+1 cash[0]--;//5刀零钱-1 }else return false; } else//如果顾客支付20刀 { if(cash[0] &gt; 0 &amp;&amp; cash[1] &gt; 0)//有10和5刀的零钱 { cash[0]--; cash[1]--; } else if(cash[0] &gt;= 3)//如果只有5刀的零钱而且5刀还必须多余三张 { cash[0] -= 3; } else return false; } } return true; }};   这道题相对上面那道题就简单多了，方法不难，就是贪心，就是这个分类讨论得分对。" }, { "title": "力扣-K次取反后最大化的数组和 & 加油站", "url": "/posts/%E5%8A%9B%E6%89%A3-K%E6%AC%A1%E5%8F%96%E5%8F%8D%E5%90%8E%E6%9C%80%E5%A4%A7%E5%8C%96%E7%9A%84%E6%95%B0%E7%BB%84%E5%92%8C-&-%E5%8A%A0%E6%B2%B9%E7%AB%99/", "categories": "算法刷题", "tags": "贪心", "date": "2022-06-02 14:59:00 +0000", "snippet": "1005. K 次取反后最大化的数组和class Solution {public: static bool cmp(int a, int b) { return abs(a) &gt; abs(b); } //使用两次贪心 局部最优推出全局最优 //第一次：将绝对值最大的负数取反 //第二次：如果k有剩余（要么没负数了，要么数组遍历完了），...", "content": "1005. K 次取反后最大化的数组和class Solution {public: static bool cmp(int a, int b) { return abs(a) &gt; abs(b); } //使用两次贪心 局部最优推出全局最优 //第一次：将绝对值最大的负数取反 //第二次：如果k有剩余（要么没负数了，要么数组遍历完了），那么就反复取反最小的数字 int largestSumAfterKNegations(vector&lt;int&gt;&amp; nums, int k) { //首先要按绝对值的从大到小进行排序 sort(nums.begin(), nums.end(), cmp); for(int i = 0; i &lt; nums.size(); i++) { //如果遍历到的这个位置是负数，那么取反 if(nums[i] &lt; 0) { nums[i] *= -1; k--;//使用一次k } //k用完了就不继续遍历了嗷 if(k == 0) break; } //如果k没用完，而且还是奇数 if( k % 2 == 1) nums[nums.size() - 1] *= -1; //求和 int sum = 0; for(auto &amp;each : nums) { sum += each; } return sum; }};    最开始我自己写的时候直接按大小排序，结果呢，后面还要分情况考虑，但如果是按绝对值大小排序的话，就没有那么多弯路去走了。    注意，sort（）的cmp函数需要时static静态的，不然报错。134. 加油站class Solution {public: int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) { int totalGas = 0;//记录跑完一圈后剩余油量 int curGas = 0;//记录当前油量 int start = 0;//记录出发车站 int len = gas.size(); //使用贪心算法：局部最优推出全局最优，选出出发点 for(int i = 0; i &lt; len; i++) { int rest = gas[i] - cost[i]; totalGas += rest;//时刻更新剩余油量 curGas += rest; if(curGas &lt; 0)//如果当前油量小于0，那么从start到i这个位置都不能作为出发点 { start = i + 1; curGas = 0; } } //如果总的剩余油量小于0 说明走不完一圈 if(totalGas &lt; 0) return -1; return start; }};    这道题很遗憾啊，我的想法和代码随想录有相似的地方，但是start这个没有处理好，一旦当前油量小于0那么从下标0到这个下标i位置都不能做初始点。这一点是举不出反例的，就可以直接贪心了    没想到，贪心还挺难的。" }, { "title": "复刻《PokemonGo》部分功能的学习记录", "url": "/posts/%E5%A4%8D%E5%88%BB-PokemonGo-%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/", "categories": "Unity3D", "tags": "虚拟现实, 学习笔记", "date": "2022-06-02 02:47:00 +0000", "snippet": "一、实验摘要    《宝可梦GO》是一款能对现实世界中出现的宝可梦进行探索捕捉、战斗以及交换的游戏。玩家可以通过智能手机在现实世界里发现宝可梦，进行抓捕和战斗。玩家作为宝可梦训练师抓到的宝可梦越多会变得越强大，从而有机会抓到更强大更稀有的宝可梦。    本次实验复刻了宝可梦GO的LBS地图系统、AR捕捉系统以及仓库系统。二、实验过程0.环境介绍 Unity2017.3.1 ...", "content": "一、实验摘要    《宝可梦GO》是一款能对现实世界中出现的宝可梦进行探索捕捉、战斗以及交换的游戏。玩家可以通过智能手机在现实世界里发现宝可梦，进行抓捕和战斗。玩家作为宝可梦训练师抓到的宝可梦越多会变得越强大，从而有机会抓到更强大更稀有的宝可梦。    本次实验复刻了宝可梦GO的LBS地图系统、AR捕捉系统以及仓库系统。二、实验过程0.环境介绍 Unity2017.3.1 Andriod SDK 、NDK、OpenJDK均来自于Unity2020.3.14版本安卓模块 1.游戏内容分析传统部分 选择阵营，参与争夺 宠物捕捉 宠物升级进化 宠物PK 道具系统：收集，购买 创新内容 LBS： 增加与现实世界互动 增加玩家代入感 增加社交互动 AR 增加现实世界互动 形式新奇 2.项目设计 app功能 用户登录 LBS基于地理的服务功能 AR捉宠功能 宠物仓库功能 数据更新与保存 制作流程及标准 以模块的形式做成独立的项目 LBS使用GoMap插件 AR使用Vuforia 宠物仓库 UGUI制作登陆界面 资源 角色模型 精灵球、食物模型 卡通宠物模型 UI美术 粒子特效及音效 3.unity实现LBS服务（Location Based Service） 先配置环境 unity2017.3.1 安卓SDK（我用的是unity2021版本自带的sdk） 导入GoMap插件包 在demo文件夹拷贝一个POI demo的场景 build出一个安卓apk进行测试（注意在导出之前要更改player setting中的package name） 4.获取地图运营商密钥 在mapbox官网注册账号 点击token创建新的token 选择默认选项即可 注意，一开始申请注册账号的时候需要visa信用卡，就放弃了注册，但后来给我发送了确认邮件，我验证后就注册成功了5.GoMap的图块机制 tile buffer 图块缓冲越大，一次申请访问的地图就越大 Coordinates / units Ratio 单位取真实世界的米 Zoom level 值越大，地图比例越小。放大和缩小不会更改比例尺，意味着放再大单位还是取真实世界的米 6.GoMap的坐标机制    开始游戏时，世界中心坐标将会和场景中心坐标(0,0,0)匹配，并且不会变动，人物的行走会改变人物的位置坐标，这与普通地图SDK有所不同（普通地图SDK人物不产生位移，地图画面移动）7.设置地图玩家角色 替换角色模型 修改角色比例与方向，再拖到Avatar下，将角色物体拖到Avtar物体的Move Avtar脚本的Avatar Figure上 让模型根据移动速度产生动画的变化 创建Animator文件夹（在Avatar_01下），创建Animator controller作为角色模型的控制器 将animation文件夹中的Idle、run、walk拖入控制器 将any state连接（Transition）三个动画 在any state中添加参数：三个trigger（idle、run、walk） 在三个连接中添加对应的条件（condition） 将控制器拖到模型Boy的Animator组件的controller中 写脚本控制动画 创建文件夹，创建脚本BoyControl.cs using System.Collections;using System.Collections.Generic;using UnityEngine; public class BoyControl : MonoBehaviour {//储存动画控制器private Animator ator;//储存角色控制器private MoveAvatar moveAvatar;// Use this for initializationvoid Start () { //获取动画控制器 ator = gameObject.GetComponent&lt;Animator&gt;(); //获取父物体的角色控制器 moveAvatar = transform.parent.GetComponent&lt;MoveAvatar&gt;();} // Update is called once per framevoid Update () { //如果角色控制器当前的状态是 定义的待机状态 if(moveAvatar.animationState == MoveAvatar.AvatarAnimationState.Idle) { //而且当前动画不是待机动画，就将动画控制器的动画设置为待机 if(!ator.GetCurrentAnimatorStateInfo(0).IsName(\"Idle\"))ator.SetTrigger(\"Idle\"); } else if(moveAvatar.animationState == MoveAvatar.AvatarAnimationState.Run) { if (!ator.GetCurrentAnimatorStateInfo(0).IsName(\"Run\")) ator.SetTrigger(\"Run\"); } else if(moveAvatar.animationState == MoveAvatar.AvatarAnimationState.Walk) { if (!ator.GetCurrentAnimatorStateInfo(0).IsName(\"Walk\")) ator.SetTrigger(\"Walk\"); }}} 将main camera的target设置为boy模型，保证视角的正确 8.范围内生成随机点 指定预制体作为事件点的载体 获取角色坐标信息 定义随机点与角色距离范围 在距离范围内取一个随机坐标 在随机坐标的位置生成随机点预制体 新建一个cube改名为EventPoint，拖到创建的prefab文件夹 新建脚本InsPoint.cs using System.Collections;using System.Collections.Generic;using UnityEngine; public class InsPoint : MonoBehaviour { //储存地图角色 public GameObject Ava; //储存事件点预制体 public GameObject PrePoint; //储存距离范围最小点 public float MinDis = 3f; //储存距离范围最大点 public float MaxDis = 50f; //储存当前角色当前位置 private Vector3 v3Ava; // Use this for initialization void Start () { } // Update is called once per frame void Update () { } public void InsPointFuc() { //获取角色坐标位置 v3Ava = Ava.transform.position; //从距离范围内取一个随机距离值 float _dis = Random.Range(MinDis, MaxDis); //从原点为（0，0）随机获取一个方向的向量 Vector2 _pOri = Random.insideUnitCircle; //将该方向向量标准化 Vector2 _pNor = _pOri.normalized; //计算生成随机点的位置向量 随机点x坐标 随机点y坐标 Vector3 _v3Point = new Vector3(v3Ava.x + _pNor.x * _dis, 0, v3Ava.z + _pNor.y * _dis); //生成随机点的预制体 GameObject poiMark = Instantiate(PrePoint, _v3Point, transform.rotation); }} 新建一个空物体作为manager，删掉之前创建的eventpoint物体 将随机点生成脚本挂载manager上 将avtar、预制体prePoint拖到manager的脚本上 创建canvas，创建按钮（锚点右上角），添加manager中的随机点函数到按钮中 9.在地图上生成随机事件随机事件： 生成小精灵 生成精灵球 生成食物 实现手段： 制作三个预制体 在随机点的脚本中随机选取事件 生成对应的预制体 具体流程 导入资源包食物和精灵球，放到package文件夹下 将资源包中prefab的蛋糕和精灵球拖到hierarchy修改比例后放到工程的prefab文件夹作为预制体（将精灵球刚体组件删掉） 创建一个圆柱暂时作为宠物 新建脚本PointEvent.cs using System.Collections;using System.Collections.Generic;using UnityEngine; public class PointEvent : MonoBehaviour { //分别储存精灵、精灵球、食物的预制体 public GameObject Pet; public GameObject Ball; public GameObject Food; //储存偏移量 private Vector3 offset; // Use this for initialization void Start () { int _randomEvent = Random.Range(0, 3);//随机选 0 1 2 if (_randomEvent == 0) insPet(); else if (_randomEvent == 1) insBall(); else if (_randomEvent == 2) insFood(); offset = new Vector3(0, 5f, 0); } // Update is called once per frame void Update () { } private void insPet() { Instantiate(Pet, transform.position + offset, transform.rotation); } private void insFood() { Instantiate(Food, transform.position + offset, transform.rotation); } private void insBall() { GameObject _ball = Instantiate(Ball, transform.position + offset, transform.rotation); //设置精灵球的角度 _ball.transform.localEulerAngles = new Vector3(-30f, 0, 0); }} 将脚本挂载到eventPoint预制体上，并将蛋糕、精灵球和精灵（现在是圆柱）挂载在脚本上 删掉eventPoint预制体上的meshrender和cube组件（不用显示） 新建脚本MoveEffect.cs控制随机生成的物体的动态效果 using System.Collections;using System.Collections.Generic;using UnityEngine; public class MoveEffect : MonoBehaviour { //设置起始弧度参数 private float radian = 0f; //弧度变化值 private float perRad = 0.03f; //位移偏移量 private float add = 0f; //储存物体生成时的真实坐标 private Vector3 posOri; // Use this for initialization void Start () { //获取初始位置的坐标信息，否则就是0，0，0 posOri = transform.position; } // Update is called once per frame void Update () { //弧度值变化 radian += perRad; //计算偏移量 add = Mathf.Sin(radian); //更改物体位置 transform.position = posOri + new Vector3(0, add, 0); //控制物体旋转（我试了下，无论是space.self还是world都是绕自己y轴旋转 怪） transform.Rotate(0, Time.deltaTime * 25f, 0, Space.World); }} 10.生成精灵实现方式： 制作精灵预制体 使用resource加载预制体 编写随机生成事件 制作流程 导入精灵包 将精灵包文件夹中prefab-&gt;low poly -&gt; naked中的预制体拖到hierarchy中，修改大小，改名字为01 在精灵文件夹中新进animator文件夹，并创建animator controller 将Animation文件夹中的idle basic拖到刚创建的controller中 将controller添加到01上 在根目录创建Resource文件夹，并在里面创建Pets文件夹，将01拖到pets文件夹中形成预制体 将场景中的01删掉 以相同的方式添加多个精灵 创建脚本InsPets.cs生成宠物 using System.Collections;using System.Collections.Generic;using UnityEngine; public class InsPets : MonoBehaviour { //创建数组 存储精灵预制体 private GameObject[] pets; void Awake() { pets = Resources.LoadAll&lt;GameObject&gt;(\"Pets\"); } // Use this for initialization void Start () { InsPet(); } // Update is called once per frame void Update () { } private void InsPet()//注意不要和脚本同名 { //随机生成一个精灵序号 int _petIndex = Random.Range(0, pets.Length); //生成精灵 Instantiate(pets[_petIndex], transform.position, transform.rotation); }} 将脚本拖到之前创建的精灵预制体（圆柱），删掉圆柱的mesh 11.随机事件与角色互动互动事件： 角色碰撞到食物或者精灵球时，对应UI数字增加 角色碰到精灵时，出现面板询问是否捕捉 实现方式： 给事件添加碰撞器，使用触发碰撞器 给角色增加”Avatar“标签，并增加碰撞器 判断进入事件点碰撞器的物体标签是否为Avatar 具体流程： 搭建UI，在canvas新建image至左上角，命名为im_Ball,锚点设置在左上角 在im_Ball上添加text_Mark 作为×号和text_num作为数字，将锚点放在右侧（因为符号和数字在父物体img的右侧） 复制im_Ball做成food 创建Pics文件夹再在里面创建UI文件夹，将食物和精灵球图片拖入，将图片类型改为sprite 新建脚本UI_Mgr_02.cs using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI;public class UI_Mgr_02 : MonoBehaviour { //储存精灵球和食物的数量 public Text Tx_BallNum; public Text Tx_FoodNum; //申请静态类变量,便于其他脚本直接调用该类的方法 public static UI_Mgr_02 Instance; void Awake() { Instance = this; } public void AddBallNum() { int _num = int.Parse(Tx_BallNum.text); _num++; Tx_BallNum.text = _num.ToString(); } public void AddFoodNum() { int _num = int.Parse(Tx_FoodNum.text); _num++; Tx_FoodNum.text = _num.ToString(); } } 创建碰撞脚本Ball_Find.cs using System.Collections;using System.Collections.Generic;using UnityEngine; public class Ball_Find : MonoBehaviour { //碰撞函数 void OnTriggerEnter(Collider other) { if(other.tag == \"Avatar\")//与标签为“Avatar”的物体碰撞 { UI_Mgr_02.Instance.AddBallNum(); //销毁物体 Destroy(gameObject); } } } 创建空物体UI_mgr并挂载上UI_Mgr_02.cs，将Im_Ball和Im_Food的数字text挂载到UI_Mgr_02.cs变量上（不要挂maker，不然会报错嗷） 更改ball的预制体，添加刚体组件并把限制constraint中的freeze全打上勾，使其不受物理的原因而移动变化，挂上ballFind脚本，将碰撞器的is trigger勾上 为boy物体添加”Avatar“标签和box_collider 食物同理 12.触发精灵捕捉面板面板内容： 提示信息：精灵种类 开始捕捉 放弃捕捉 流程： 在canvas上添加img_catch 在img_catch添加三个text分别是恭喜、发现宠物和宠物名字，再添加两个按钮，分别为捕捉和放弃 扩充UI_Mgr_02.cs //储存捕捉面板 public GameObject Im_Catch //设置捕捉面板的激活状态 public void SetIm_Catch(bool bl) { Im_Catch.SetActive(bl); }; 将捕捉面板物体挂载到ui管理物体的脚本上 创建脚本Pet_Find.cs using System.Collections;using System.Collections.Generic;using UnityEngine; public class Pet_Find : MonoBehaviour { void Start() { //精灵初始朝向角色 transform.LookAt(GameObject.FindGameObjectWithTag(\"Avatar\").transform); } void OnTriggerEnter(Collider other) { if (other.tag == \"Avatar\")//与标签为“Avatar”的物体碰撞 { UI_Mgr_02.Instance.SetIm_Catch(true); //销毁物体 Destroy(gameObject); } } } 为所有精灵添加碰撞体和刚体，像食物和精灵球那样调整，挂上PetFind.cs 为面板的放弃捕捉按钮添加im-mgr物体，并选上SetIm_Catch方法 12.LBS部分重构 在Resources文件夹中新建文件夹ball和foods 将prefab文件夹中的对应物体拖入刚新建的文件夹 重构PointEvent.cs using System.Collections;using System.Collections.Generic;using UnityEngine; public class PointEvent : MonoBehaviour { //分别储存精灵、精灵球、食物的预制体 private GameObject[] Pets; private GameObject[] Balls; private GameObject[] Foods; //储存偏移量,让生成的物体高一点 private Vector3 offset; // Use this for initialization void Awake() { Balls = Resources.LoadAll&lt;GameObject&gt;(\"Balls\"); Foods = Resources.LoadAll&lt;GameObject&gt;(\"Foods\"); Pets = Resources.LoadAll&lt;GameObject&gt;(\"Pets\"); } void Start () { offset = new Vector3(0, 5f, 0); int _randomEvent = Random.Range(0, 3);//随机选 0 1 2 if (_randomEvent == 0) insPet(); else if (_randomEvent == 1) insBall(); else if (_randomEvent == 2) insFood(); } // Update is called once per frame void Update () { } private void insPet() { // 随机生成一个精灵序号 int _petIndex = Random.Range(0, Pets.Length); Instantiate(Pets[_petIndex], transform.position + offset, transform.rotation); } private void insFood() { int _foodIndex = Random.Range(0, Foods.Length); Instantiate(Foods[_foodIndex], transform.position + offset, transform.rotation); } private void insBall() { int _ballIndex = Random.Range(0, Foods.Length); GameObject _ball = Instantiate(Balls[_ballIndex], transform.position + offset, transform.rotation); //设置精灵球的角度 _ball.transform.localEulerAngles = new Vector3(-30f, 0, 0); } } 删掉InsPet.cs和Pet预制体 使用代码为预制体增加组件，继续重构PointEvent.cs，修改脚本中的insBall和insFood函数即可 private void insFood() { int _foodIndex = Random.Range(0, Foods.Length); GameObject _food = Instantiate(Foods[_foodIndex], transform.position + offset, transform.rotation); //添加碰撞体组件 _food.AddComponent&lt;BoxCollider&gt;(); //勾选isTrigger _food.GetComponent&lt;BoxCollider&gt;().isTrigger = true; //设置碰撞体 _food.GetComponent&lt;BoxCollider&gt;().center = new Vector3(0, 0, 0); _food.GetComponent&lt;BoxCollider&gt;().size = new Vector3(0.33f, 0.3f, 0.33f); //添加刚体组件 _food.AddComponent&lt;Rigidbody&gt;(); //更改刚体组件的限制 _food.GetComponent&lt;Rigidbody&gt;().constraints = RigidbodyConstraints.FreezeAll; //添加moveeffect组件和find组件 _food.AddComponent&lt;MoveEffect&gt;(); _food.AddComponent&lt;Food_Find&gt;(); } private void insBall() { int _ballIndex = Random.Range(0, Foods.Length); GameObject _ball = Instantiate(Balls[_ballIndex], transform.position + offset, transform.rotation); //设置精灵球的角度 _ball.transform.localEulerAngles = new Vector3(-30f, 0, 0); //添加球形碰撞体组件 _ball.AddComponent&lt;SphereCollider&gt;(); //勾选isTrigger _ball.GetComponent&lt;SphereCollider&gt;().isTrigger = true; //设置碰撞体大小 _ball.GetComponent&lt;SphereCollider&gt;().radius = 0.011f; //添加刚体组件 _ball.AddComponent&lt;Rigidbody&gt;(); //更改刚体组件的限制 _ball.GetComponent&lt;Rigidbody&gt;().constraints = RigidbodyConstraints.FreezeAll; //添加moveeffect组件和find组件 _ball.AddComponent&lt;MoveEffect&gt;(); _ball.AddComponent&lt;Ball_Find&gt;(); } 13.配置Vuforia 在周围随机出现精灵 发射精灵球 新建一个项目pokemonGo_AR 创建ARCamera时导入Vuforia的包 切换至安卓平台 更改playersetting中的XR settings 勾选Auforia 为ARcamera添加密钥 更改ARcamera下VuforiaConfiguraton的Device Tracker，勾选Track Device Pose 导出apk测试（导之前更改playersetting 里的名称还有other setting里的Android TV要取消掉） 14.规划AR模块的制作（生成精灵球）功能流程 读取数据 配置精灵球 配置精灵 可以发射精灵球 触发精灵捕捉成功 流程： 创建cube作为ballpos，调整位置与大小并拖给ARcamera作为子物体 创建一个球体作为精灵球，调整大小位置，删除碰撞器组件（因为要在代码中动态添加） 在Resources文件夹中创建Balls文件夹，并将球体拖进去作为预制体（在合并项目时，同名文件夹也会合并） 创建scripts文件夹再创建AR文件夹，在里面创建ARBallCtrl.cs脚本 using System.Collections;using System.Collections.Generic;using UnityEngine; public class ARBallCtrl : MonoBehaviour { //储存精灵球预制体 private GameObject[] balls; //精灵球生成位置 public Transform PosInsBall; // Use this for initialization void Start () { //加载路径在“Resources/Balls”的预制体 balls = Resources.LoadAll&lt;GameObject&gt;(\"Balls\"); insBall(); } // Update is called once per frame void Update () { } private void insBall() { Instantiate(balls[0], PosInsBall.position, PosInsBall.rotation); //设置精灵球的父物体 为了保证发射前始终在屏幕的固定位置 _ball.transform.SetParent(PosInsBall); //为精灵球添加球体碰撞器组件 _ball.gameObject.AddComponent&lt;SphereCollider&gt;(); }} 新建脚本管理器，添加ARBallCtrl.cs脚本，将BallPos拖到脚本中 15.发射精灵球发射效果 用手指滑动发射 发射后精灵球运动的过程类似于真实物体抛射 可以碰到精灵 受重力影响下落 落在地面上 制作思路 有碰撞器 有刚体 计算手指滑动方向 计算手指滑动距离 计算手指滑动的速度 注意事项 有的滑动方向不能触发精灵球发射 滑动距离不够不能触发精灵球发射 AR交互对算法的影响 流程 创建脚本ARShootBall.cs using System.Collections;using System.Collections.Generic;using UnityEngine; public class ARShootBall : MonoBehaviour { //设置给精灵球的力度 public float FwdForce = 200f; //设置夹角的参照数值 public Vector3 StanTra = new Vector3(0, 1f, 0); //判断手指是否碰到精灵球位置 private bool blTouched = false; //判断精灵球是否发射 private bool blShooted = false; //手指滑动起始点 private Vector3 startPosition; //手指滑动的终点 private Vector3 endPosition; //手指滑动的距离 private float disFlick; //手指滑动的速度 private float speedFlick; //手指滑动的时间(帧数) private int timeFlick = 0; //手指滑动的偏移向量 private Vector3 offset; //记录主摄像机 private Camera cameraMain; // Use this for initialization void Start () { //赋值为主摄像机 cameraMain = Camera.main; } // Update is called once per frame void Update () { if(blTouched)//如果按在小球上，允许检测手指的滑动 { slip(); } } //重置参数 private void resetVari() { //起始位置为手指按下的位置 startPosition = Input.mousePosition; } //当鼠标/手指 按下/触摸到 脚本挂载的物体 void OnMouseDown() { if(blShooted == false)//如果没发射 { blTouched = true;//允许检测手指滑动 } } //计算手指的滑动 private void slip() { timeFlick += 25;//时间每帧增加25 if(Input.GetMouseButtonDown(0))//当手指按下的时候 { resetVari();//重置参数 } if(Input.GetMouseButton(0))//当手指一直按下的时候 { //将终点位置坐标刷新为手指位置 endPosition = Input.mousePosition; //获取手指在世界坐标上的偏移量 offset = cameraMain.transform.rotation * (endPosition - startPosition); //计算手指滑动的距离 disFlick = Vector3.Distance(endPosition, startPosition); } if(Input.GetMouseButtonUp(0))//当手指抬起来 { //计算速度 speedFlick = disFlick / timeFlick; //手指触摸设置为false blTouched = false; //时间重置 timeFlick = 0; //如果手指滑动距离超过20而且是向上滑动 if(disFlick &gt; 20 &amp;&amp; endPosition.y- startPosition.y &gt; 0) { //允许发射 shootBall(); } } } //发射精灵球 private void shootBall() { //给精灵球添加刚体组件 transform.gameObject.AddComponent&lt;Rigidbody&gt;(); //使用局部变量储存刚体组件，便于后续操作 Rigidbody _rigBall = transform.GetComponent&lt;Rigidbody&gt;(); //给精灵球一个初始速度 _rigBall.velocity = offset.normalized * speedFlick; //为精灵球添加力度,方向为朝着屏幕前方（即为摄像机的前方） _rigBall.AddForce(cameraMain.transform.forward * FwdForce); //让精灵球旋转 _rigBall.AddTorque(transform.right); //设置精灵球阻力 _rigBall.drag = 0.5f; //设置为发射状态 blShooted = true; //让发射出去的球脱离父物体 transform.parent = null; //执行协程函数 StartCoroutine(LateInsBall()); } //协程函数 IEnumerator LateInsBall() { yield return new WaitForSeconds(0.2f); //延迟两秒执行 //生成新的精灵球 ARBallCtrl.Instance.InsNewBall(); }} 删掉BallPos的碰撞器和渲染插件，只需要为精灵球提供位置 将ARBallCtrl.cs的脚本生成新精灵球函数insBall改为公有函数方便调用，并修改： //申请脚本静态类对象 public static ARBallCtrl Instance; public void InsNewBall() 创建材质文件夹，新建一个带颜色的材质赋给cube方便区分球和cube 16.AR场景中生成精灵流程 升高ARcamera的y坐标至1.6 在Resources文件夹新建Pets文件夹，将cube拖入作为预制体 在ARcamera的周围创建多个生成点cube 删除cube的碰撞器和网格（因为只需要提供位置） 新建空物体PosMgr统一管理生成点（作为生成点的父物体） 新建脚本ARInsPets.cs using System.Collections;using System.Collections.Generic;using UnityEngine; public class ARInsPet : MonoBehaviour { //储存生成精灵位置的物体 public Transform[] TraPos; //储存精灵 private GameObject[] pets; // Use this for initialization void Start () { pets = Resources.LoadAll&lt;GameObject&gt;(\"Pets\"); } // Update is called once per frame void Update () { } public void InsPet() { //随机选一个生成的位置点 int _index = Random.Range(0, TraPos.Length); //获取该位置的transform Transform _tra = TraPos[_index]; //在该位置生成精灵 Instantiate(pets[0], _tra.position, _tra.rotation); }} 将脚本挂载到PosMgr上，并将五个位置点cube放在脚本上 17.地图模块与AR模块的整合目标 将两个项目文件合并 测试调整整合后的项目场景 场景的跳转 流程 打开pokemonGo_map项目文件，导出包 复制pokemonGo_AR项目文件改名为pokemonGo_main，作为主项目文件 导入包 切换场景到map 测试，为防止鼠标移动到按钮时相机发生变化，新建一个ARcamera并关掉所有组件 切换场景到AR 由于在文件合并时，相同文件夹的内容也会合并，同名的预制体会覆盖之前的预制体，所以要调整Ball 制作捕捉精灵时的跳转函数，修改UI_Mgr脚本 using UnityEngine.SceneManagement; public void Btn_GoARScn() { SceneManager.LoadScene(\"AR_Scn\"); } 要将场景添加到build setting中 切换至AR_Scn,创建一个脚本ARUI_Mgr.cs using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.SceneManagement;public class ARUI_Mgr : MonoBehaviour { public void Btn_GoMapScn() { SceneManager.LoadScene(\"Map_Scn\"); }} 18.Resource中的预制体标准标准 同一文件夹中的预制体类型要相同 同一批预制体的配置信息保持一致（坐标轴位置、旋转角度、模型朝向、导出前的操作） 外部导入的资源在进入unity前就要统一标准 流程 修改ARInsPet脚本，使精灵大小合适，在生成精灵函数最后进行修改 //在该位置生成精灵 GameObject _pet = Instantiate(pets[0], _tra.position, _tra.rotation); //调整缩放比例 _pet.transform.localScale = new Vector3(0.5f, 0.5f, 0.5f) ; 将BallPos 的scale全改为1 修改ARBallCtrl.cs脚本中生成精灵球函数最后加上 //设置精灵球的大小为25倍 _ball.transform.localScale = new Vector3(25f, 25f, 25f); 用代码来调整碰撞器的缩放比，并添加发射精灵球脚本 //为精灵球添加发射精灵球脚本 _ball.gameObject.AddComponent&lt;ARShootBall&gt;(); //设置精灵球的大小为25倍 _ball.transform.localScale = new Vector3(25f, 25f, 25f); //获取碰撞器并更改半径 _ball.GetComponent&lt;SphereCollider&gt;().radius = 0.01f; 19.数据的全局管理流程 切换至map场景，将img_Ball拖入Prefeb文件夹形成预制体 回到AR场景，将预制体拖到场景中 在脚本文件夹，创建Map文件夹，把之前的脚本拖到Map中 再新建一个Static文件夹，用来存放全局脚本 新建脚本StaticData.cs using System.Collections;using System.Collections.Generic;using UnityEngine; public static class StaticData { //精灵球初始数量 public static int BallNum = 5;} 修改UI_Mgr脚本 //精灵球数量 public Text Tx_BallNum; //单例 public static ARUI_Mgr Instance; void Awake() { Instance = this; } public void UpdateUIBallNum() { Tx_BallNum.text = StaticData.BallNum.ToString(); } 修改ARBallCtrl脚本 void Start () { //加载路径在“Resources/Balls”的预制体 balls = Resources.LoadAll&lt;GameObject&gt;(\"Balls\"); //刷新精灵球数量 ARUI_Mgr.Instance.UpdateUIBallNum(); InsNewBall(); } public void InsNewBall() { if(StaticData.BallNum &gt; 0) { GameObject _ball = Instantiate(balls[0], PosInsBall.position, PosInsBall.rotation); //设置精灵球的父物体 为了保证发射前始终在屏幕的固定位置 _ball.transform.SetParent(PosInsBall); //为精灵球添加球体碰撞器组件 _ball.gameObject.AddComponent&lt;SphereCollider&gt;(); //为精灵球添加发射精灵球脚本 _ball.gameObject.AddComponent&lt;ARShootBall&gt;(); //设置精灵球的大小为25倍 _ball.transform.localScale = new Vector3(25f, 25f, 25f); //获取碰撞器并更改半径 _ball.GetComponent&lt;SphereCollider&gt;().radius = 0.01f; } } 修改精灵球发射脚本ARShootBall中的发射函数，在发射结束后添加以下两行代码 //减少精灵球数量 StaticData.BallNum--; //更新UI ARUI_Mgr.Instance.UpdateUIBallNum(); 回到地图场景 修改UI_Mgr_02.cs脚本，增加start函数，初始化场景精灵球数量，修改增加精灵球数量 void Start() { Tx_BallNum.text = StaticData.BallNum.ToString(); } public void AddBallNum() { StaticData.BallNum++; Tx_BallNum.text = StaticData.BallNum.ToString(); } 保存精灵的全局变量：修改StaticData.cs脚本 //当前正要捕捉的精灵序号 public static int CatchingPetIndex; 修改Pet_Find脚本，修改void OnTriggerEnter(Collider other)函数 void OnTriggerEnter(Collider other) { if (other.tag == \"Avatar\")//与标签为“Avatar”的物体碰撞 { //显示捕捉面板 UI_Mgr_02.Instance.SetIm_Catch(true); //当与角色碰撞时，更改全局变量：要捕捉的精灵序号 StaticData.CatchingPetIndex = PetIndex; //销毁物体 Destroy(gameObject); } } 修改PointEvent脚本的生成精灵函数 private void insPet() { // 随机生成一个精灵序号 int _petIndex = Random.Range(0, Pets.Length); //储存随机生成的精灵 GameObject _pet = Instantiate(Pets[_petIndex], transform.position + offset, transform.rotation); //更新精灵的序号 _pet.GetComponent&lt;Pet_Find&gt;().PetIndex = _petIndex; } 回到AR场景，修改ARInsPet脚本中的InsPet函数。并修改start函数 //在该位置生成要捕捉的精灵 GameObject _pet = Instantiate(pets[StaticData.CatchingPetIndex], _tra.position, _tra.rotation); void Start () { pets = Resources.LoadAll&lt;GameObject&gt;(\"Pets\"); //生成精灵 InsPet();} 删掉之前生成精灵的按钮 20.精灵捕捉的处理功能效果 精灵播放被捕捉到的动画 精灵消失 显示捕捉成功界面 流程 打开PetsAnimator 打开Animation_FBX文件夹，将Hurt_die动画和jump_basic动画拖到Animator中 连接：Any State -&gt; hurt -&gt; jump 添加一个Trigger参数Catched 将Any State -&gt; hurt的连线condition添加参数Catched 回到AR场景，在canvas上创建一个Panel组件Pn_Catched，锚点在四角 在panel上添加输入框 新建两个按钮，一个是确认，一个是放生 修改ARUI.Mgr脚本，添加以下内容 //储存面板 public GameObject PnCatched; public void Show_PnCatched() { PnCatched.SetActive(true); } 给精灵球添加Ball标签 修改PetFind脚本 //延迟两秒显示捕捉面板并销毁精灵 IEnumerator ShowCatchedPn() { yield return new WaitForSeconds(2f); //显示捕捉面板 ARUI_Mgr.Instance.Show_PnCatched(); //销毁精灵物体 Destroy(transform.gameObject); } //播放被捕捉的动画 private void playCatched() { transform.GetComponent&lt;Animator&gt;().SetTrigger(\"Catched\"); } void OnTriggerEnter(Collider other) { if (other.tag == \"Avatar\")//与标签为“Avatar”的物体碰撞 { //显示捕捉面板 UI_Mgr_02.Instance.SetIm_Catch(true); //当与角色碰撞时，更改全局变量：要捕捉的精灵序号 StaticData.CatchingPetIndex = PetIndex; //销毁物体 Destroy(gameObject); } if(other.tag == \"Ball\") { //播放动画 playCatched(); //显示面板 ShowCatchedPn(); } } 21.精灵命名流程 在脚本文件夹中创建Pet文件夹，新建PetSave脚本 using System.Collections;using System.Collections.Generic;using UnityEngine; public class PetSave{ //记录精灵名字 private string strName = \"未命名宠物\"; //记录精灵模型的序号 private int petIndex = 0; //精灵名字属性 public string PetName { get { return strName; } set { strName = value; } } //精灵序号属性 public int PetIndex { get { return petIndex; } set { petIndex = value; } } //构造函数 public PetSave(string name, int index) { PetName = name; PetIndex = index; }} 修改全局数据脚本StaticData //申请列表储存捕捉到的精灵 public static List&lt;PetSave&gt; PetList = new List&lt;PetSave&gt;(); /// &lt;summary&gt; /// 向全局数据的精灵列表中添加精灵 /// &lt;/summary&gt; /// &lt;param name=\"petSave\"&gt;精灵的属性类 &lt;/param&gt; public static void AddPet(PetSave petSave) { PetList.Add(petSave); } 修改ARUI.Mgr脚本，为捕捉面板的按钮添加函数 //储存精灵名字 public Text InputPetName; //捕捉面板的确认按钮 public void Btn_Yes() { //从输入框中获取精灵名字 string _name = InputPetName.text; //从全局脚本中获取精灵序号 int _index = StaticData.CatchingPetIndex; //向全局脚本的精灵列表中添加一条精灵属性类数据 StaticData.AddPet(new PetSave( _name, _index)); } 22.精灵仓库的制作流程 新建Store.Scn场景 创建Text，修改canvas的canves Scaler中mode为Scale with the screen Size并修改分辨率为1080*1920 调整text大小尺寸，命名为Tx_Title并将锚点放在左上角 新建按钮放在右上角，返回 新建画布Cav_world，修改canves Scaler中mode为Scale with the screen Size并修改分辨率为1080*1920 在Cav_world上新建panel调整大小 在panel上新建text组件保存信息：宠物名称和宠物类型 添加image用来储存精灵图 再复制两个panel 将摄像机模式改为正交模式并调整相机大小 将Cav_World的canvas组件中Render Mode改为Camera，并将main camera拖到Render camera上 创建三个空物体储存精灵的位置 新建空物体Pos_Mgr管理这三个位置 在脚本文件夹中新建文件夹Store，创建新脚本StoreInsPets.cs using System.Collections;using System.Collections.Generic;using UnityEngine; public class StoreInsPet : MonoBehaviour { //储存展示的位置 public Transform[] Pos; //储存所有精灵预制体 private GameObject[] pets; //储存展示的精灵 private GameObject[] petsShow = new GameObject[3]; void Awake() { pets = Resources.LoadAll&lt;GameObject&gt;(\"Pets\"); } // Use this for initialization void Start () { InsPet(); } // Update is called once per frame void Update () { } public void InsPet() { // 获取精灵数量 int _petNum = StaticData.PetList.Count; //如果仓库中有精灵 if(_petNum &gt; 0) { for(int i = 0; i &lt; 3; i++) { //如果i大于了最后一个精灵的序号 if (i &gt; (_petNum - 1)) return; //储存精灵信息 PetSave _petInfo = StaticData.PetList[i]; //生成精灵 Instantiate(pets[_petInfo.PetIndex], Pos[i].position, Pos[i].rotation); //获取精灵的名字 string _petNm = _petInfo.PetName; //更新精灵的名字 StoreUIMgr.Instance.UpdatePetNm(i, _petNm); } } }} 新建脚本StoreUIMgr.cs using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI;public class StoreUIMgr : MonoBehaviour { //显示精灵名字的text public Text[] PetName; //显示精灵类型的text public Text[] PetType; //单例 public static StoreUIMgr Instance; void Awake() { Instance = this; } //更新精灵的名字函数 public void UpdatePetNm(int index, string strName) { PetName[index].text = strName; }} 新建一个空物体Mgr，并将刚才创建的两个脚本挂载上去 将三个位置物体挂载到Mgr的StoreInsPets下，三个名字和类型text挂载到Mgr的StoreUIMgr 切换到AR场景，在ARUI_Mgr脚本的Btn_Yes()函数最后加上跳转场景的代码 //跳转到仓库界面 SceneManager.LoadScene(\"Store_Scn\"); 给确定按钮绑定上Mgr物体上的ARUI_Mgr脚本的Btn_Yes()函数 由于精灵仓库场景中ARcamera的影响使得精灵显示不正常，新建一个ARcamera，关掉组件 23.完善场景切换设计： 地图场景： 可随时跳转到精灵仓库 碰到精灵时可跳转到AR场景 AR场景： 随时跳转到精灵仓库 捕捉成功跳转到精灵仓库 随时跳转到地图场景 放弃捕捉时跳转到地图场景 仓库场景 随时跳转到地图场景 流程 修改StoreUIMgr脚本，添加场景切换函数 using UnityEngine.SceneManagement; //跳转到地图场景 public void Btn_ToMap() { SceneManager.LoadScene(\"Map_Scn\"); } 给返回按钮添加Mgr物体，选择StoreUIMgr脚本的Btn_ToMap()函数 返回Map场景，复制扫描按钮，命名为精灵仓库 修改UI_Mgr_02脚本，添加跳转场景函数 回到AR场景，复制回到地图按钮，命名精灵仓库 修改ARUI_Mgr脚本，添加跳转到精灵仓库和放生的函数 完善 AR场景 仓库场景 流程 修改ARInsPet脚本，将ARcamera挂载到脚本上 //储存相机位置public Transform CameraTra; InsPet()中最后添加：//让生成的精灵面向我们_pet.transform.LookAt(new Vector3(CameraTra.position.x, _pet.transform.position.y, CameraTra.position.z)); 切换到精灵仓库场景，添加宠物类型显示功能，修改StoreUIMgr脚本，添加刷新精灵种类的函数 /// &lt;summary&gt; /// 刷新精灵类型函数 /// &lt;/summary&gt; /// &lt;param name=\"index\"&gt;精灵序号&lt;/param&gt; /// &lt;param name=\"strType\"&gt;精灵类型名字&lt;/param&gt; public void UpadatePetType(int index, string strType) { Tx_PetType[index].text = strType; } 再StaticData脚本中定义一个静态函数，用来根据序号返回精灵的种类 public static string GetPetName(int index) { if(index == 0) { return \"不灭狂雷\"; } else if(index == 1) { return \"牛头酋长\"; } else if (index == 2) { return \"赤小兔\"; } else if (index == 3) { return \"沙漠皇帝\"; } else if (index == 4) { return \"乌迪尔\"; } else if (index == 5) { return \"傲之追猎者\"; } else if (index == 6) { return \"麻花藤\"; } else if (index == 7) { return \"沙漠死神\"; } else { return \"不屈之枪\"; } } 修改StoreInsPet脚本，在InsPet函数最后添加刷新类型的函数 /// &lt;summary&gt; /// 刷新精灵类型函数 /// &lt;/summary&gt; /// &lt;param name=\"index\"&gt;精灵序号&lt;/param&gt; /// &lt;param name=\"strType\"&gt;精灵类型名字&lt;/param&gt; public void UpadatePetType(int index, string strType) { Tx_PetType[index].text = strType; } 24.美术及音效 新建一个登录场景Login_Scn 为防止Vuforia的影响，先创建一个ARcamera，关掉所有组件 在Pic文件夹中创建Icons、Btn、InputF、BG、Words文件夹，把之前的图标图片放到Icons中，导入美术资源，设置为sprite，记得apply 创建canvas，再创建一个panel作为背景 将导入的背景图片设置为panel的源图像，并将不透明度调为100% 在背景Panel上新建image，并选择导入的美术资源，设置锚点（就近原则） 新建inputfile，一个输入用户名，一个输入密码 新建一个登录按钮 新建几个image装饰一下 为登录添加跳转功能，在脚本文件夹新建Login文件夹，创建Login_UI脚本 using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.SceneManagement;public class Login_UI : MonoBehaviour { public void Login() { SceneManager.LoadScene(\"Map_Scn\"); }} 新建管理器物体，将脚本挂载到管理器上，为按钮添加跳转功能 新建一个文件夹Audios，存放音乐与音效，导入音乐包 创建一个空物体管理声音AuMgr（用来添加按钮的音源）,在Mgr添加audio source组件，勾选loop，选择一个bgm导入 创建一个脚本Login_Au using System.Collections;using System.Collections.Generic;using UnityEngine; public class Login_Au : MonoBehaviour { private AudioSource Au; //静态单例 public static Login_Au Instance; void Awake() { Instance = this; } // Use this for initialization void Start () { Au = GetComponent&lt;AudioSource&gt;(); } public void Btn_Play() { Au.Play(); }} 切换到Map场景，换掉场景中所有按钮图片 为Mgr添加音源 新建脚本Map_Au using System.Collections;using System.Collections.Generic;using UnityEngine; public class Map_Au : MonoBehaviour { private AudioSource Au; //静态单例 public static Map_Au Instance; void Awake() { Instance = this; } // Use this for initialization void Start() { Au = GetComponent&lt;AudioSource&gt;(); } public void Btn_Play() { Au.Play(); }} 新建空物体AuMgr，挂载声音控制脚本 给每个按钮的响应函数内添加一条： //播放按钮声音 Map_Au.Instance.Btn_Play(); 切换到AR界面 更改UI按钮、添加BGM、按钮音效、AR场景的AU管理脚本 切换到精灵仓库界面，重复上面的操作 25.游戏保存功能 导入Easy Save包 切换到仓库场景，复制一个按钮为保存 在静态脚本文件夹创建脚本SaveAndLoad.cs using System.Collections;using System.Collections.Generic;using UnityEngine; public static class SaveAndLoad{ public static void Save() { //保存精灵球数量 ES3.Save&lt;int&gt;(\"BallNum\", StaticData.BallNum); //保存已捕捉的精灵的数量 ES3.Save&lt;int&gt;(\"PetNum\", StaticData.PetList.Count); //保存每一个已捕捉到的精灵信息 for(int i = 0; i &lt; StaticData.PetList.Count; i++) { //储存每一个精灵的名字 ES3.Save&lt;string&gt;(\"PetName\" + i.ToString(), StaticData.PetList[i].PetName); //储存每一个精灵的序号 ES3.Save&lt;int&gt;(\"PetIndex\" + i.ToString(), StaticData.PetList[i].PetIndex); } } //加载函数 public static void Load() { if(ES3.KeyExists(\"BallNum\") &amp;&amp; ES3.KeyExists(\"PetNum\")) { //读取精灵球数量 StaticData.BallNum = ES3.Load&lt;int&gt;(\"BallNum\"); //读取精灵数量 int _petNum = ES3.Load&lt;int&gt;(\"PetNum\"); //读取每个精灵的信息 for(int i = 0; i &lt; _petNum; i++) { string _petName = ES3.Load&lt;string&gt;(\"PetName\" + i.ToString()); int _petIndex = ES3.Load&lt;int&gt;(\"PetIndex\" + i.ToString()); StaticData.AddPet(new PetSave(_petName, _petIndex)); } } } } 修改StoreUI_Mgr脚本，添加保存按钮的函数，并给按钮加上函数 public void Btn_Save() { Store_Au.Instance.Btn_Play(); SaveAndLoad.Save(); } 将加载函数加载登录的按钮函数内（在LoginUI脚本中），登录即读取 public void Login() { Login_Au.Instance.Btn_Play(); SaveAndLoad.Load(); SceneManager.LoadScene(\"Map_Scn\"); } 三、项目界面展示 界面 介绍 登录界面：该界面用户名密码其实并没有效果， 点击登录，会自动读取上一次的记录并跳转到地图界面 地图界面：打开app后允许gps功能，玩家在现实世界移动，游戏世界的角色也会跟着移动，地图为学校。左上方显示精灵球和食物数量，通过点击右上角的扫描区域，可以在周围随机刷新精灵球、食物和精灵。玩家碰撞到精灵球、食物，数量会增加，碰撞到精灵弹出捕捉面板 AR战斗界面：玩家手持手机环顾四周，寻找精灵，找到精灵后，通过滑动手指的动作来投掷精灵球，碰撞到精灵便捕捉成功，捕捉成功后显示成功面板，起名确认后跳转到仓库界面，否则跳转到地图界面 仓库界面：玩家捕捉的精灵将显示在该界面，点击保存将会保存当前精灵，下次登录时会自动读取 四、实验中遇到的问题 环境配置问题，如下     在上一次实验时，我就想导出安卓包，但出现了SDK的各种问题，先是找不到SDK，然后是版本低，不能够支持最新版本的Vuforia，尝试了很多办法。最开始解决找不到SDK时，把Unity卸载了重装，但安装又出现了问题，又看博客的单独安装，就是把各种需要的模块、包、SDK等等单独下载，再整合一起，找到SDK了，但版本又不支持，于是又重新下载了最新的Unity，但最新的Unity的安卓sdk版本依旧不支持最新版本的Auforia，于是乎，便排查出不是Unity的问题，而是安卓包和Auforia版本不匹配的问题，最后又下回了Unity2020的稳定版本，导入Vuforia后，降低Vuforia的版本后能够成功导出安卓包了。但此次实验的环境是Unity2017，因为Unity2017自带Vuforia，更方便，根本不用担心安卓包和Auforia版本不匹配的问题。 实验开始阶段MapBox的密钥申请问题    MapBox以往和Vuforia是一样的，只要注册登录就可以申请密钥，使用其LBS插件的功能，但今年有所变化，注册账号必须要visa等国际银行卡，但这种银行卡不是随随便便轻而易举就能办下来的，所以正在我一筹莫展之时，MapBox一小时后还是给我发来了验证邮件，没有银行卡还是注册账号成功了。 中间有时会发生一些小bug，不过无足轻重很快就能调整好，比较麻烦的问题是最后的canvas布局问题     导到手机上测试时，发现仓库界面的精灵信息面板发生重叠，发现是分辨率的不同导致的，电脑上设置的分辨率是1080*1920，而我的手机估计是10：21的比例，所以有所不同，于是查阅博客对canvas scaler的描述，更改canvas scaler的UI Scale Mode为 Scale With Screen Size，并根据情况更改Match即可，像上面这个，宽度其实不用缩放，只需要根据手机的高度来缩放UI的高度即可，因此Match拉到1。五、个人收获    本项目的技术难点不多，大多学习到的是项目的管理和游戏基本功能在Unity中的实现 项目管理方式，为不同模块创建不同的文件夹存放脚本、预制体、资源等内容。在场景中使用不同的Manager空物体来管理场景中的脚本事件，比如Au_Mgr管理音频的脚本事件，Mgr管理场景主要事件的脚本，UI_Mgr管理界面的事件脚本。 项目的合并，相同文件夹会自动合并，在开发不同模块的功能时，如AR场景和地图场景可以分开开发，开发完毕后再合并项目。 使用Unity的Resources文件夹加载预制体，不用再一个一个手动拖拽添加了，节省了不少人力。 强力插件的运用，本项目就使用了GoMap插件和Easy Save插件，使用强力的插件能够节约开发时间 静态脚本以及单例的运用。使用静态脚本储存全局变量，可以保存场景切换时的数据，这一点与GameMaker Studio2的global变量如出一辙，并且要利用静态脚本实现保存和读取的功能，本项目使用了插件，只用实现保存和读取功能能即可，在GameMaker Studio2中还需要多两步，就是保存为json文件和读取json文件，整体流程很相似。单例可以直接使用类.单例名来调用该类的函数，功能和静态脚本很相似。 " }, { "title": "力扣-跳跃游戏 & 跳跃游戏II", "url": "/posts/%E5%8A%9B%E6%89%A3-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-&-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII/", "categories": "算法刷题", "tags": "回溯, 贪心", "date": "2022-06-01 14:18:00 +0000", "snippet": "55. 跳跃游戏class Solution {public: int isUsed[30000] = {0}; //思路：回溯 + 贪心 //回溯三部曲 //1.确定返回类型和参数 bool backtracing(vector&lt;int&gt;&amp; nums, int startIndex) { //2.终止条件 ...", "content": "55. 跳跃游戏class Solution {public: int isUsed[30000] = {0}; //思路：回溯 + 贪心 //回溯三部曲 //1.确定返回类型和参数 bool backtracing(vector&lt;int&gt;&amp; nums, int startIndex) { //2.终止条件 //如果这个到达这个位置后可以到达最后的位置 if(startIndex &gt;= nums.size() - 1 ) return true; //如果该位置可移动距离为0 或者该位置曾经走过（又走一遍说明上一次走到这个位置后再往前怎么走都走不通了） else if(nums[startIndex] == 0 || isUsed[startIndex]) return false; //如果这个位置可以开始走了，那么先把这个位置设置为走过了 isUsed[startIndex] = 1; //3.每次回溯的遍历过程 for(int i = nums[startIndex]; i &gt; 0; i--) { //如果从这个位置起步走发现能走到终点那么就会一步一步地往上返回true if(backtracing(nums, startIndex + i)) return true; } //遍历完了也没有找到 return false; } bool canJump(vector&lt;int&gt;&amp; nums) { return backtracing(nums, 0); }};    这是我的思路，回溯，到一个位置后先往远了跳，不行就减1，而且每次走过的位置标记一下，再次跑到同样位置就直接终止。   过是过了，就是时间和空间用的很多，岂可休！    本来想改成动态生成数组，结果leetcode老是说我数组越界，明明VS上跑的非常正确，查了之后发现leetcode编译会先判断会不会越界，麻了。    但在创建动态数组的时候，得这么写，不乘num.size()的话，就只有a[0]被初始化为0了。int* a;a = new int[num.size()];memset(a, 0, sizeof(a) * num.size());    如果不是动态数组，初始就创建了个a[5]，这么写就没问题了：int a[5];memset(a, 0, sizeof(a));    代码随想录的思路是贪心：class Solution {public: //判断当前位置能覆盖的最大位置是否能够到达最后一个下标 bool canJump(vector&lt;int&gt;&amp; nums) { int cover = 0;//初始覆盖的范围为0 //如果只有一个数，那么开始就已经到了 if(nums.size() == 1) return true; //注意，要 &lt;= cover cover是到当前位置能覆盖的最远位置，也就是说一定能走到的下标是cover for(int i = 0; i &lt;= cover; i++) { //更新能覆盖的最远下标值 cover = max(i + nums[i], cover); //如果最远下标已经到达最后一个 if(cover &gt;= nums.size() - 1) return true; } return false; }};    节省了不少时间和空间，但能想到这个方法还是挺难的~45. 跳跃游戏 IIclass Solution {public: int cnt = 0; void cal(vector&lt;int&gt;&amp; nums, int maxIndex) { if(maxIndex == 0) return; int cover = 0; for(int i = 0; i &lt;= cover; i++) { cover = max(cover, i + nums[i]); if(cover &gt;= maxIndex) { cnt++; //去找到能走到i这个位置的最小下标 cal(nums, i); return; } } } int jump(vector&lt;int&gt;&amp; nums) { cal(nums, nums.size() - 1); return cnt; }};    我的思路借助了上一个贪心的方法，通过递归，利用贪心算法不断从头开始找能到达终点的最小位置，这里的终点是在不断地变化的，一开始是素组的最后一个下标，递归一次后终点就成了能到达终点的最小下标，直到终点为0时，结束递归。    战绩不佳，时间和空间都只战胜了20%。    代码随想录的思路：class Solution {public: int jump(vector&lt;int&gt;&amp; nums) { if(nums.size() == 1) return 0; int ans = 0;//记录答案 int curFurDis = 0;//记录当前能走到的最远距离 int nextFurDis = 0;//记录下一步能走到的最远距离 for(int i = 0; i &lt; nums.size(); i++) { //先计算i的位置能到达的最远位置是否可以更新下一步能走到的最远位置 nextFurDis = max(i + nums[i], nextFurDis); if(i == curFurDis)//如果i遍历到了当前能走的最远位置，那么步数+1 { ans++; //更新当前i能走到的最远位置 curFurDis = nextFurDis; //如果走了i这一步就能走到底了(确切的说不是在i下标走的这一步，可能是在i之前某一个下标但一定是在上一个i之后) if(curFurDis &gt;= nums.size() - 1) break; } } return ans; }};    他这个思路是贪心，最多只用遍历一遍nums数组，需要两个变量进行判断。    注意nums只有1个数字时候的情况，需要特判。" }, { "title": "复盘动态光照系统", "url": "/posts/%E5%A4%8D%E7%9B%98%E5%8A%A8%E6%80%81%E5%85%89%E7%85%A7%E7%B3%BB%E7%BB%9F/", "categories": "GameMaker Studio2", "tags": "动态光照, shader, 学习笔记", "date": "2022-05-31 07:57:00 +0000", "snippet": "一、基础动态光照原理1.光源    需要写一个光源的shader，光源的计算方式如下：2.影子计算    计算方式与解析如图：3.新的光源的影子盖住旧光源的问题    开启z缓冲，将影子变为透明的存在，并置于自己对应的光照上面。如下图：二、基础动态光照代码实现1.shader的编写    创建一个shader作为光源 shd_light    顶点着色器vsh：attribute vec3 ...", "content": "一、基础动态光照原理1.光源    需要写一个光源的shader，光源的计算方式如下：2.影子计算    计算方式与解析如图：3.新的光源的影子盖住旧光源的问题    开启z缓冲，将影子变为透明的存在，并置于自己对应的光照上面。如下图：二、基础动态光照代码实现1.shader的编写    创建一个shader作为光源 shd_light    顶点着色器vsh：attribute vec3 in_Position; // (x,y,z)varying vec2 pos;uniform float u_z; //z缓冲深度void main(){ vec4 object_space_pos = vec4( in_Position.x, in_Position.y, u_z, 1.0); gl_Position = gm_Matrices[MATRIX_WORLD_VIEW_PROJECTION] * object_space_pos; pos = in_Position.xy;}     片段着色器fsh：varying vec2 pos; //当前像素位置uniform vec2 u_pos; //光源位置const float zz = 32.; //larger zz, larger lightvoid main(){ vec2 dis = pos - u_pos; float str = 1./(sqrt(dis.x*dis.x + dis.y*dis.y + zz*zz)-zz); //strength of light is the inverse distance gl_FragColor = vec4(vec3(str),1.);}    创建一个shader作为阴影 shd_shadow    顶点着色器vsh：attribute vec3 in_Position; // (x,y,z)uniform vec2 u_pos; //光源位置uniform float u_z; //z缓冲深度void main(){ vec2 pos = in_Position.xy; if (in_Position.z &gt; 0.){ //check if vertex requires repositioning vec2 dis = pos - u_pos; pos += dis/sqrt(dis.x*dis.x + dis.y*dis.y) * 100000.; //重定位z缓冲小于0的点 } vec4 object_space_pos = vec4( pos.x, pos.y, u_z-0.5, 1.0); //阴影绘制在u_z-0.5的深度，而其对应的光照在u_z的深度，所以，阴影在光照的上一层，这样才不会被自己的光照盖住 gl_Position = gm_Matrices[MATRIX_WORLD_VIEW_PROJECTION] * object_space_pos;}    片段着色器fsh：void main(){ gl_FragColor = vec4(0.); //绘制一个黑色透明的阴影}2. 初始化代码（逻辑、计算、z缓冲）    先创建一个obj_light作为光源物体，再创建一个obj_light的子物体obj_movinglight设置为可移动的光源。    创建obj_setup添加控制动态光照系统的代码    在obj_setup中添加创建事件：//重置surfacesurface_resize(application_surface,320,180);display_set_gui_maximize();//shader中变量获取u_pos = shader_get_uniform(shd_light,\"u_pos\");u_pos2 = shader_get_uniform(shd_shadow,\"u_pos\");u_z = shader_get_uniform(shd_light,\"u_z\");u_z2 = shader_get_uniform(shd_shadow,\"u_z\");//顶点格式创建、顶点缓冲初始化vertex_format_begin();vertex_format_add_position_3d();vf = vertex_format_end();vb = vertex_create_buffer();    在obj_setup中添加步事件：//创建由两个三角形构成的四边形，用来制作影子//z坐标来判断顶点是否需要重定位function Quad(_vb,_x1,_y1,_x2,_y2){ //上面的三角形 vertex_position_3d(_vb,_x1,_y1,0); vertex_position_3d(_vb,_x1,_y1,1); //repositioned vertex vertex_position_3d(_vb,_x2,_y2,0); //下面的三角形 vertex_position_3d(_vb,_x1,_y1,1); //repositioned vertex vertex_position_3d(_vb,_x2,_y2,0); vertex_position_3d(_vb,_x2,_y2,1); //repositioned vertex}//为每一面墙壁构建顶点缓冲器//使用墙的两条对角线而不是四条边//(优化)vertex_begin(vb,vf);var _vb = vb;with(obj_wall){ Quad(_vb,x,y,x+sprite_width,y+sprite_height); //墙的一条对角线 Quad(_vb,x+sprite_width,y,x,y+sprite_height); //墙的另一条对角线}vertex_end(vb);    在obj_setup中添加draw事件，绘制光源和阴影//局部变量初始化var _u_pos = u_pos;var _u_pos2 = u_pos2;var _u_z = u_z;var _u_z2 = u_z2;var _vb = vb;//开启z缓冲 (3D)gpu_set_ztestenable(1);gpu_set_zwriteenable(1);var _z = 0;//初始化z缓冲的深度值with(obj_light){ //绘制阴影 shader_set(shd_shadow); shader_set_uniform_f(_u_pos2,x,y); shader_set_uniform_f(_u_z2,_z); vertex_submit(_vb,pr_trianglelist,-1); //绘制光 gpu_set_blendmode(bm_add);//打开叠加模式 shader_set(shd_light); shader_set_uniform_f(_u_pos,x,y); shader_set_uniform_f(_u_z,_z); draw_rectangle(0,0,320,180,0); //绘制光的画布 gpu_set_blendmode(bm_normal); _z--; //下一个光源和其对应的影子在这一个的上方}shader_reset();gpu_set_ztestenable(0);gpu_set_zwriteenable(0);二、动态光照系统的完善（原理）1.混合模式方法取代z缓冲    使用gamemaker studio2的混合模式函数gpu_set_blendmode_ext_sepalpha()。    该函数一共有四个参数：[1] 源像素RGB混合模式[2] 目标像素RGB混合模式[3] 源像素透明度混合模式[4] 目标像素透明度混合模式。    在绘制阴影前，调用（此时应当把阴影片段着色器的颜色改为1.）gpu_set_blendmode_ext_sepalpha(bm_zero,bm_one,bm_one,bm_zero);    这意味着源像素RPG（也就是阴影的颜色）要乘以0，目标像素RPG是不变的（乘以1），源像素的透明度（也就是阴影的透明度）乘以1，目标像素透明度乘以0。    在绘制光源前，调用gpu_set_blendmode_ext_sepalpha(bm_inv_dest_alpha,bm_one,bm_zero,bm_zero);    第一个参数bm_inv_dest_alpha意思是（1 - 目标像素透明度），也就是说当某个地方透明度为0（没有阴影）才会绘制光源 源像素，并且目标像素RPG不变，因为光源可以叠加，但源像素的透明度和目标像素的透明度都乘以0，是为了重置surface的透明度以保证RGB值得保留。2.弱光灯效果    在上面的基础上，提前创建一个表面surface，所有的光和阴影绘制完毕后，开始绘制整个表面，绘制表面前调用gpu_set_blendmode_ext(bm_zero,bm_src_color);    这意味着源像素RGB值（也就是阴影）乘以0，说明是黑色，目标像素RGB值就是原来的颜色（比如地板的颜色，依旧不变）    新建sha_shadsurf，修改片段着色器以达到弱光灯的效果，其实就是将片段着色器的alpha通道改为1。3.可修改光源参数    在obj_light中添加变量，如颜色、半径、角度参数，在shader中修改uniform变量即可。四、动态光照系统的完善代码实现    修改obj_setup的创建事件：//Resize the application surface to be lower res (for pixel games + performance boost)surface_resize(application_surface,320,180);display_set_gui_maximize();//turn of automaic drawing of application surfaceapplication_surface_draw_enable(false);//view coordinatesvx = 0;vy = 0;//Shader uniform variable setupu_pos = shader_get_uniform(shd_light,\"u_pos\");u_zz = shader_get_uniform(shd_light,\"zz\");u_str = shader_get_uniform(shd_light,\"u_str\");u_pos2 = shader_get_uniform(shd_shadow,\"u_pos\");//Vertex format and buffer setupvertex_format_begin();vertex_format_add_position_3d();vf = vertex_format_end();vb = vertex_create_buffer();//shadow surface variable declarationshad_surf = noone;    修改obj_setup的步事件: (代码中有控制摄像机移动的代码，并且对传入顶点着色器的参数进行了修改)//Creates Quad with two triangles. Used to make the shadows. //Z coordinate is used as a flag to determine if the vertex will be repositioned in the shaderfunction Quad(_vb,_x1,_y1,_x2,_y2){ //Upper triangle vertex_position_3d(_vb,_x1,_y1,0); vertex_position_3d(_vb,_x1,_y1,1); //repositioned vertex vertex_position_3d(_vb,_x2,_y2,0); //Lower Triangle vertex_position_3d(_vb,_x1,_y1,1); //repositioned vertex vertex_position_3d(_vb,_x2,_y2,0); vertex_position_3d(_vb,_x2,_y2,1); //repositioned vertex}//Construct the vertex buffer with every wall//Instead of using the four edges as the walls, we use the diagonals instead (Optimization)vertex_begin(vb,vf);var _vb = vb;with(obj_wall){ Quad(_vb,x,y,x+sprite_width,y+sprite_height); //Negative Slope Diagonal Wall Quad(_vb,x+sprite_width,y,x,y+sprite_height); //Positive Slope Diagonal Wall}vertex_end(vb);//view movement controlsvy += (keyboard_check(vk_down)-keyboard_check(vk_up))*4; vx += (keyboard_check(vk_right)-keyboard_check(vk_left))*4; camera_set_view_pos(view_camera[0],vx,vy);//add lights by left clicking. For testing purposesif (mouse_check_button_pressed(mb_left)){ instance_create_depth(mouse_x,mouse_y,depth,obj_light); }if (mouse_check_button_pressed(mb_right)){ repeat(100) instance_create_depth(mouse_x,mouse_y,depth,obj_light); }    添加draw_begin事件，这是为了确保每一帧最初会清除掉application_surfacedraw_clear_alpha(c_black,0);    修改Draw事件：(里面包含了摄像机移动时，坐标的变换)//Local variables setupvar _u_pos = u_pos;var _u_zz = u_zz;var _u_str = u_str;var _u_pos2 = u_pos2;var _vb = vb;var _vx = vx;var _vy = vy;//Shadow surface setupif (!surface_exists(shad_surf)){ shad_surf = surface_create(320,180);}matrix_set(matrix_world,matrix_build(-vx,-vy,0,0,0,0,1,1,1));surface_set_target(shad_surf);draw_clear_alpha(c_black,0);with(obj_light){ //Draw the shadows (AKA light blockers) gpu_set_blendmode_ext_sepalpha(bm_zero,bm_one,bm_one,bm_zero); shader_set(shd_shadow); shader_set_uniform_f(_u_pos2,x,y); vertex_submit(_vb,pr_trianglelist,-1); //Draw the Light gpu_set_blendmode_ext_sepalpha(bm_inv_dest_alpha,bm_one,bm_zero,bm_zero); shader_set(shd_light); shader_set_uniform_f(_u_pos,x,y); shader_set_uniform_f(_u_zz,size); shader_set_uniform_f(_u_str,str); draw_rectangle_color(_vx,_vy,_vx+320,_vy+180,color,color,color,color,0); //canvas for drawing the light}surface_reset_target();matrix_set(matrix_world,matrix_build(0,0,0,0,0,0,1,1,1));//Draw and blend the shadow surface to the application surfacegpu_set_blendmode_ext(bm_zero,bm_src_color);shader_set(shd_shadsurf);draw_surface_ext(shad_surf,vx,vy,1,1,0,c_white,0.8);//reset shader and blendmode shader_reset();gpu_set_blendmode(bm_normal);    添加post -Draw事件：    每一帧先画背景，再画application_surface，这样的话背景不受光照的影响draw_clear_alpha(c_teal,1);draw_surface_ext(application_surface,0,0,4,4,0,c_white,1);    修改shd_light的片段着色器fsh：    添加uniform变量，用于调整光源的属性。varying vec2 pos; //current pixel positionvarying vec4 col;uniform vec2 u_pos; //light source positonuniform float zz; //larger zz, larger lightuniform float u_str;void main(){ vec2 dis = pos - u_pos; float str = 1./(sqrt(dis.x*dis.x + dis.y*dis.y + zz*zz)-zz)*u_str; //strength of light is the inverse distance gl_FragColor = col*vec4(vec3(str),1.);}    创建表面的着色器，sh_shadsurf，仅修改片段着色器fsh中透明度即可。    注释掉的代码和最后一行代码的功效一样。varying vec2 v_vTexcoord;varying vec4 v_vColour;void main(){ //vec4 frag = texture2D( gm_BaseTexture, v_vTexcoord ); // gl_FragColor = vec4(vec3(v_vColour.a * frag.rgb + 1.-v_vColour.a),1.); //change the scale of the light intensity then translate it to have max rgb value at pure white gl_FragColor = vec4(texture2D( gm_BaseTexture, v_vTexcoord ).rgb,1.);}五、设置光照角度和阴影边缘柔化1.设置光照角度原理    如下图：2.阴影边缘柔化    原理以及计算过程如下阴影边缘柔化前后对比：六、代码实现设置光照角度和阴影边缘柔化    在olight物体中填加两个参数dir和fov用于调整光照的方向和角度的大小。    修改光源shader的片段着色器,实现可以调整的角度和方向，其中uniform变量需要在setup物体的创建事件中获取，在步事件中设置。varying vec2 pos;varying vec4 col;uniform vec2 u_pos; //light的posuniform float zz;//zz越大，光衰减得越慢, 光源半径越大uniform float u_str;uniform float u_dir;uniform float u_fov;#define PI 3.14159265358void main(){ vec2 dis = pos - u_pos; float str = 1./(sqrt(dis.x * dis.x + dis.y * dis.y + zz * zz) -zz) * u_str;//光照强度 float dir = radians(u_dir); float hfov = radians(u_fov) * 0.5; if(hfov &lt; PI) { float rad = atan(-dis.y, dis.x); float adis = abs(mod(rad + 2. * PI, 2. * PI) - dir); adis = min(adis, 2. * PI - adis); str *= clamp((1. - adis / hfov) * 5., 0., 1.); } gl_FragColor =col * vec4(vec3(str),1.);}    修改阴影的顶点着色器，要通过运算得出tdis和ldis并传递给片段着色器中使用。    顶点着色器代码vsh：//// Simple passthrough vertex shader//attribute vec3 in_Position;//应该是buffer中的坐标也就是墙体的坐标 // (x,y,z)uniform vec2 u_pos;//指的是light的坐标varying float ldis;varying float tdis;const float len = 100000.;void main(){ vec2 pos = in_Position.xy; vec2 dis = pos - u_pos; float sdis = length(dis); if(in_Position.z &gt; 1.) { //sqrt(dis.x * dis.x + dis.y * dis.y)指dis方向的单位矢量 pos += dis / sdis * len;//指原来的点坐标 要加上dis方向*100000像素的 距离 tdis = in_Position.z - 2.; ldis = 1.; } else { ldis = sdis / len; tdis = mix(0.5, in_Position.z, ldis); } vec4 object_space_pos = vec4( pos.x, pos.y, 0., 1.0); gl_Position = gm_Matrices[MATRIX_WORLD_VIEW_PROJECTION] * object_space_pos;}    片段着色器代码fsh：varying float tdis;varying float ldis;void main(){ float str = (1. - abs(tdis - 0.5) * 2. / ldis) * 5.; gl_FragColor = vec4(str);//vec3(0.)是黑色 1.是白色 //现在是透明的shadow}    由于这次加了阴影的边缘柔化，所以在setup的绘制事件中，在绘制阴影之前将blendmode的最后一个参数从bm_zero改为bm_one，目的在于目标像素将透明度的系数改为1，这样的话阴影可以叠加。七、应用到我的项目" }, { "title": "复盘生成随机迷宫算法", "url": "/posts/%E5%A4%8D%E7%9B%98%E9%9A%8F%E6%9C%BA%E8%BF%B7%E5%AE%AB/", "categories": "GameMaker Studio2", "tags": "随机迷宫, 回溯, 块状分割型随机迷宫", "date": "2022-05-29 07:08:00 +0000", "snippet": "一、回溯生成普通迷宫原理 首先要像上图一样，将地面和墙块分隔开来，绿色的是地面，灰色的是墙体 然后选择靠近边缘的地面（上下左右的边）作为起点，在这个地面砖块周围即上下左右四个方向随机寻找一个地面砖块，找到就将他们联通，把两个地砖之间的墙变为绿色的地砖 然后以第二步找到的格子作为新的起点，开始递归，重复第二步，直到某个格子的周围无法找到地面砖块 ...", "content": "一、回溯生成普通迷宫原理 首先要像上图一样，将地面和墙块分隔开来，绿色的是地面，灰色的是墙体 然后选择靠近边缘的地面（上下左右的边）作为起点，在这个地面砖块周围即上下左右四个方向随机寻找一个地面砖块，找到就将他们联通，把两个地砖之间的墙变为绿色的地砖 然后以第二步找到的格子作为新的起点，开始递归，重复第二步，直到某个格子的周围无法找到地面砖块 这时候就回溯，看之前的格子的周围还有没有地砖 直到最后就可以填充完毕 代码实现 创建一个脚本MACRO_randomMaze，用于存放宏定义的变量 //***随机生成地图 //路面、墙体#macro FLOOR -5#macro WALL -6//栅格大小#macro CELL_WIDTH 16#macro CELL_HEIGHT 16//标记地图宽高#macro MAP_STAMP_WIDTH 31#macro MAP_STAMP_HEIGHT 23//显示地图宽高#macro MAP_SHOW_WIDTH MAP_STAMP_WIDTH*2+1#macro MAP_SHOW_HEIGHT MAP_STAMP_HEIGHT*2+1 新建一个object，作为随机生成迷宫的物体obj_maze，在create事件中添加以下代码     其中标记栅格指的就是地面部分的grid，显示栅格指的是既包括地面还有墙体的grid，所以显示栅格是要比标记栅格大一倍的。 ///@description 初始化地图// You can write your code in this editor //标记地图栅格建立和显示地图栅格建立map_stamp_grid_=ds_grid_create(MAP_STAMP_WIDTH,MAP_STAMP_HEIGHT);map_show_grid_=ds_grid_create(MAP_SHOW_WIDTH,MAP_SHOW_HEIGHT);map_stamp_number=0;//已标记的栅格数量//获取图块集tilemap_wall=layer_tilemap_get_id(\"WALL\");tilemap_x(tilemap_wall,8);tilemap_y(tilemap_wall,8);tilemap_floor=layer_tilemap_get_id(\"FLOOR\");tilemap_x(tilemap_floor,8);tilemap_y(tilemap_floor,8); 创建一个步事件，并在步事件中添加以下代码（填在步事件，是为了能够通过按键重新随机生成，可以看到效果） 其中注释掉的是接下来用作块状分割型迷宫和填充。 if(keyboard_check_pressed(vk_enter)){ #region 地图初始化 map_stamp_number=0; //将显示地图全部栅格初始化为墙体 ds_grid_clear(map_show_grid_,WALL); //将标记地图初始化为未标记 ds_grid_clear(map_stamp_grid_,0); //清除上一次绘制的图块集 tilemap_clear(tilemap_floor, 0); tilemap_clear(tilemap_wall, 0); //清除路径中和运动规划网格中的点 path_clear_points(path_id); mp_grid_clear_all(path_map_path_id); //将显示地图奇数位栅格全部设置为地面 for(var i=1;i&lt;MAP_SHOW_WIDTH;i++) { for(var j=1;j&lt;MAP_SHOW_HEIGHT;j++) { if((i mod 2)&amp;&amp;(j mod 2)) map_show_grid_[# i,j]=FLOOR; } } #endregion #region 设置出入口 randomize(); var _random_dir=random(1);//随机选择出入口为上下两侧还是左右两侧 var _random_inout=random(1);//随机选择出入口分别位于哪一侧 if(_random_dir)//上下两侧 { var _inx_no=irandom_range(1,MAP_STAMP_WIDTH);//相当于是第几个可选择的入口 var _inx=_inx_no*2-1; var _outx_no=irandom_range(1,MAP_STAMP_WIDTH);//相当于是第几个可选择的出口 var _outx=_outx_no*2-1; if(_random_inout)//入口在上侧，出口在下侧 { var _iny=0; var _outy=MAP_SHOW_HEIGHT-1; }else//入口在下侧 { var _iny=MAP_SHOW_HEIGHT-1; var _outy=0; } }else//左右两侧 { var _iny_no=irandom_range(1,MAP_STAMP_HEIGHT); var _iny=_iny_no*2-1; var _outy_no=irandom_range(1,MAP_STAMP_HEIGHT); var _outy=_outy_no*2-1; if(_random_inout)//入口在左侧，出口在右侧 { var _inx=0; var _outx=MAP_SHOW_WIDTH-1; }else//入口在右侧，出口在左侧 { var _inx=MAP_SHOW_WIDTH-1; var _outx=0; } } map_show_grid_[# _inx,_iny]=FLOOR; map_show_grid_[# _outx,_outy]=FLOOR; #endregion #region 地图计算 //生成房间 //scr_create_room(); //scr_room_door();//为房间生成门 //scr_create_maze(0,0); //遍历未标记的 var _ix=0; var _jy=0; var _end=0; do { for(var _i=0;_i&lt;MAP_STAMP_WIDTH;_i++) { for(var _j=0;_j&lt;MAP_STAMP_HEIGHT;_j++) { if(!map_stamp_grid_[# _i,_j])//如果该标记网格没有被标记 { _ix=_i; _jy=_j; _end=1; break; } } if(_end)break; } scr_create_maze(_ix,_jy); _end=0; }until(map_stamp_number==MAP_STAMP_HEIGHT*MAP_STAMP_WIDTH); with(obj_mask)instance_destroy(); //scr_fill_path(); #endregion #region 绘制地图 for(var i=0;i&lt;MAP_SHOW_WIDTH;i++) { for(var j=0;j&lt;MAP_SHOW_HEIGHT;j++) { if(map_show_grid_[# i,j]==WALL) { tilemap_set(tilemap_wall,1,i,j); mp_grid_add_cell(path_map_path_id,i,j);//添加路径中不碰撞的栅格 } else if(map_show_grid_[# i,j]==FLOOR) { tilemap_set(tilemap_floor,1,i,j); } } } #endregion } 在上述代码中，使用了脚本scr_create_maze，这个脚本需要我们自己创建 function scr_create_maze(_x,_y){ //_x标记地图的横坐标 //_y标记地图的纵坐标 //随机选择方向 randomize(); var _dir=choose(0,90,180,270); var _dx=lengthdir_x(1,_dir); var _dy=lengthdir_y(1,_dir); if(!scr_can_through(_x+_dx,_y+_dy))exit;//如果不能通过则退出 else { map_show_grid_[# _x*2+1+_dx,_y*2+1+_dy]=FLOOR;//连通所要选择的下一个网格 //更新当前标记地图网格坐标 _x+=_dx; _y+=_dy; //将更新后的网格标记为1 map_stamp_grid_[# _x,_y]=1; //标记过的网格数量+1 map_stamp_number++; } //递归，回溯 while(map_stamp_number&lt;MAP_STAMP_HEIGHT*MAP_STAMP_WIDTH) { if(scr_can_choose(_x,_y))//如果当前坐标不是死路一条 { scr_create_maze(_x,_y); } else { break; } } } 在上述脚本中，还使用了scr_can_through、scr_can_choose方法，当然这些也需要我们创建脚本实现 function scr_can_through(_x,_y){ if(_x&gt;=0&amp;&amp;_x&lt;MAP_STAMP_WIDTH&amp;&amp;_y&gt;=0&amp;&amp;_y&lt;MAP_STAMP_HEIGHT) { if(map_stamp_grid_[# _x,_y]==0)//未被标记 { return 1;//返回可通过 } } return 0;//返回不可通过}function scr_can_choose(_x,_y){ if(scr_can_through(_x+1,_y)||scr_can_through(_x,_y+1)||scr_can_through(_x-1,_y)||scr_can_through(_x,_y-1)) { return 1;//返回下一步可选择 } return 0;//返回下一步不能选择，即是死路}二、块状分割型迷宫原理 在上述迷宫的基础上进行改动，在生成迷宫之前，要为地图创建房间 然后跟之前的方法一样，使用回溯生成迷宫 在房间周围，随机取点作为门来连接迷宫的路 接下来优化地图，填充死路，把一些三条边都是墙块的地面设置为墙块即可     代码实现 创建两个脚本scr_create_room()、scr_room_door() function scr_create_room(){ with(obj_mask)instance_destroy(); //设置临时变量 var _i,_j,_w,_h;//位置以及宽高 randomize(); repeat(30) { _w=irandom_range(6,10); _h=irandom_range(6,10); _i=irandom(MAP_STAMP_WIDTH-1-_w); _j=irandom(MAP_STAMP_HEIGHT-1-_h); tmp=instance_create_depth((_i*2+1)*16+8,(_j*2+1)*16+8,0,obj_mask); tmp.image_xscale=_w*2-1; tmp.image_yscale=_h*2-1; tmp.i=_i; tmp.j=_j; tmp.w=_w; tmp.h=_h; with(tmp) { if(place_meeting(x,y,obj_mask))instance_destroy(); else { ds_grid_set_region(other.map_stamp_grid_,_i,_j,_i+_w-1,_j+_h-1,1);//将房间里的网格标记为1 other.map_stamp_number+=_w*_h; ds_grid_set_region(other.map_show_grid_,_i*2+1,_j*2+1,(_i+_w-1)*2+1,(_j+_h-1)*2+1,FLOOR);//将显示地图中房间设置为地板 } } } } ```function scr_room_door(){ with(obj_mask) { randomize(); var _door_max=2; var _num=0; do { if(irandom(1)) { var _i=irandom_range(i,i+w-1)*2+1;//随机一个门在显示地图的横坐标 var _j=choose(j*2,(j+h-1)*2+1+1);//随机一个门在显示地图的纵坐标 }else { var _i=choose((i+w-1)*2+1+1,i*2); var _j=irandom_range(j,j+h-1)*2+1; } if(_i==0||_j==0||_i==MAP_SHOW_WIDTH-1||_j==MAP_SHOW_HEIGHT-1)continue; else{ _num++; other.map_show_grid_[# _i,_j]=FLOOR; instance_create_depth(_i*16+8,_j*16+8,-10,obj_mask); } }until(_num==_door_max); }} 创建两个脚本scr_fill_path()、scr_fill_dead_way() function scr_fill_path(){ var i,j; for(i=1;i&lt;MAP_SHOW_WIDTH-1;i++) { for(j=1;j&lt;MAP_SHOW_HEIGHT-1;j++) { scr_fill_dead_way(i,j); } } } function scr_fill_dead_way(i,j){ var _pos; _pos[0]=map_show_grid_[# i+1,j]; _pos[1]=map_show_grid_[# i-1,j]; _pos[2]=map_show_grid_[# i,j+1]; _pos[3]=map_show_grid_[# i,j-1]; //如果一块地板周围有三块墙 if(((_pos[0]+_pos[1]+_pos[2]+_pos[3])==-23)&amp;&amp;map_show_grid_[# i,j]==-5) { map_show_grid_[# i,j]=WALL; for(var k=0;k&lt;4;k++) { var _dir=k*90; var iout=i+lengthdir_x(1,_dir); var jout=j+lengthdir_y(1,_dir); if(iout&gt;0&amp;&amp;iout&lt;MAP_SHOW_WIDTH-1&amp;&amp;jout&gt;0&amp;&amp;jout&lt;MAP_SHOW_HEIGHT-1) scr_fill_dead_way(iout,jout); } } } 三、应用到我的项目" }, { "title": "力扣-最大子数组和 & 买卖股票的最佳时机II", "url": "/posts/%E5%8A%9B%E6%89%A3-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C-&-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII/", "categories": "算法刷题", "tags": "贪心", "date": "2022-05-28 04:29:00 +0000", "snippet": "贪心的本质：局部最优推出全局最优53. 最大子数组和class Solution {public: //贪心算法 //从第一个开始计算序列和，一旦和变为负数，那么就重置为0，重新计算后面序列的和 int maxSubArray(vector&lt;int&gt;&amp; nums) { int count = 0;//储存每段序列的和 int ...", "content": "贪心的本质：局部最优推出全局最优53. 最大子数组和class Solution {public: //贪心算法 //从第一个开始计算序列和，一旦和变为负数，那么就重置为0，重新计算后面序列的和 int maxSubArray(vector&lt;int&gt;&amp; nums) { int count = 0;//储存每段序列的和 int ret = INT_MIN;//储存最大返回的结果 for(int i = 0; i &lt; nums.size(); i++) { count += nums[i];//每次都加上和 if(count &gt; ret) ret = count;//判断此时是否要更新最大值 if(count &lt;= 0) count = 0;//如果此时序列和已经小于0了，那么重置count } return ret; }};    注意ret要初始化为int的最小值，如果输入的全是负数，那么取最大的负数作为答案，122. 买卖股票的最佳时机 IIclass Solution {public: //没买状态下，当 明天比今天高，买今天 //买的状态下，当 明天比今天低，卖今天 int maxProfit(vector&lt;int&gt;&amp; prices) { bool isPurchased = false;//状态机 int in;//买入价格 int result = 0;//利润 for(int i = 0; i &lt; prices.size() - 1; i++) { if(!isPurchased) { if(prices[i + 1] &gt; prices[i]) { in = prices[i]; isPurchased = true;//进入买的状态 } } else { if(prices[i + 1] &lt; prices[i]) { result += (prices[i] - in); isPurchased = false;//返回没买的状态 } } } //如果到最后一天了手上的股票还没卖，说明一直涨到最后一天了 if(isPurchased) result += prices[prices.size() - 1] - in; return result; }};    这是我的思路，我的想法就是判断明天价格和今天的关系来决定是否买卖。class Solution {public: int maxProfit(vector&lt;int&gt;&amp; prices) { int result = 0; for (int i = 1; i &lt; prices.size(); i++) { result += max(prices[i] - prices[i - 1], 0); } return result; }};    这是代码随想录的方案。这个意思就是把利润分解为每天的利润，使用贪心把正利润求和就是最终结果，负利润不管。    假如第0天买入，第3天卖出，那么利润为：prices[3] - prices[0]。    相当于(prices[3] - prices[2]) + (prices[2] - prices[1]) + (prices[1] - prices[0])。" }, { "title": "力扣-分发饼干 & 摆动序列", "url": "/posts/%E5%8A%9B%E6%89%A3-%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2&%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97/", "categories": "算法刷题", "tags": "贪心", "date": "2022-05-27 12:53:00 +0000", "snippet": "455. 分发饼干class Solution {public: int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) { sort(g.begin(), g.end()); sort(s.begin(), s.end()); int i = 0,...", "content": "455. 分发饼干class Solution {public: int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) { sort(g.begin(), g.end()); sort(s.begin(), s.end()); int i = 0, j = 0;//一个指向g数组，一个指向s数组 while(i &lt; g.size() &amp;&amp; j &lt; s.size()) { if(s[j] &gt;= g[i])//如果饼干满足孩子的胃口值 {//ij同时后移 j++; i++; } else j++;//满足不了孩子那就饼干下标后移 } return i; }};    先排序，贪心+双指针376. 摆动序列class Solution {public: int wiggleMaxLength(vector&lt;int&gt;&amp; nums) { if(nums.size() &lt;= 1) return nums.size(); int preDiffer = 0; int ret = 1; for(int index = 1; index &lt; nums.size(); index++) { //当前index与上一个数字的差值 int curDiffer = nums[index] - nums[index - 1]; //如果相等，那么这个index与前面的构不成摆动序列 if(curDiffer == 0) continue; else { if(ret == 1) { ret++; preDiffer = curDiffer; }//特殊情况当ret = 1也就是说之前的摆动序列只有一个数字，只要differ不是0，那么这两个数字就是摆动序列了 else { if(curDiffer * preDiffer &lt; 0)//是摆动序列 { ret++; preDiffer = curDiffer; } } } } return ret; }};注意 特殊情况是当摆动序列个数ret只有1个时，而不是下标index = 1时" }, { "title": "力扣-N皇后 & 解数独", "url": "/posts/%E5%8A%9B%E6%89%A3-N%E7%9A%87%E5%90%8E&%E8%A7%A3%E6%95%B0%E7%8B%AC/", "categories": "算法刷题", "tags": "回溯", "date": "2022-05-26 04:02:00 +0000", "snippet": "51. N 皇后class Solution {public: vector&lt;string&gt; path; //某一种解法 vector&lt; vector&lt;string&gt;&gt; ans;//解法集合 //额外加2列 int board[11][11] = {0}; //放棋子的位置是 1~9 0 和 10是边界，永远是0 int b...", "content": "51. N 皇后class Solution {public: vector&lt;string&gt; path; //某一种解法 vector&lt; vector&lt;string&gt;&gt; ans;//解法集合 //额外加2列 int board[11][11] = {0}; //放棋子的位置是 1~9 0 和 10是边界，永远是0 int boardCol[11] = {0}; string defaultString;//默认的每一行的字符串，将在回溯前初始化 //回溯三部曲 //1.确认返回类型以及参数 void backtracing(int n, int row) { //2.终止条件,当行数大于n时，说明n个棋子已经放完了 if(row == n + 1) { ans.emplace_back(path); return; } //每次回溯的遍历过程 for(int column = 1; column &lt;= n; column++) { //先判断这一列有没有棋子 if(boardCol[column] == 1) continue; //判断会不会和上面的棋子同一斜线 int curRow = row ;//记录上面的行 int colLeft = column - 1;//记录左斜线的列号 int colRight = column + 1;//记录右斜线的列号 while(curRow--) { //如果左上方有棋子 if( colLeft &gt; 0 &amp;&amp; board[curRow][colLeft] == 1) break; //如果右上方有棋子 if( colRight &lt;= n &amp;&amp; board[curRow][colRight] == 1) break; //如果当前行没有冲突的棋子 colLeft--; colRight++; } //如果当前行没有减到0，说明在之前有冲突的棋子，提前退出了，那么继续 if(curRow &gt; 0) continue; //此时这个row column是安全的，可以放置 board[row][column] = 1;//该位置标记 boardCol[column] = 1;//该行标记 string s = defaultString; s[column - 1] = 'Q'; path.emplace_back(s); backtracing(n, row + 1);//放下一行的棋子 board[row][column] = 0;//回溯完了，要把棋子收回 boardCol[column] = 0; path.pop_back(); } } vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) { for(int i = 0; i &lt; n; i++) { defaultString += \".\"; } backtracing(n, 1); return ans; }};约束条件 同行不能有，所以是按行回溯 同列不能有，使用全局数组int boardCol[11]来判断 同一斜线不能有，这个比较麻烦，需要用循环，判断之前每一行有没有 注意 判断斜线的时候，我用的是while(curRow–)，这个过程中出现了很多问题，debug之后发现，while语句，无论curRow是否大于0，只要执行while(curRow–)这一行代码，curRow就会-1，所以初始化时，要初始化为row，这样的话while(curRow–)正好curRow就是上一行。而且在最后判断斜线上到底有无时，if(curRow &gt; 0) 要&gt;0不能==0，因为如果没有冲突，最后是-1. 在记录棋盘每一行的字符串时，需要一个默认的字符串defaultString，全是”.”，在每次放棋子时，再新建一个s来=defaultString，不然的话，直接用defaultString，Q会填满默认字符串变成“QQQQ” 37. 解数独class Solution {public: //二维回溯 回溯三部曲 //1.确认返回类型，参数 //使用bool是因为只有一个答案，一旦发现一个答案，就返回true，不再继续回溯了 //在回溯的过程中修改board bool backtracing(vector&lt;vector&lt;char&gt;&gt;&amp; board) { //2.中止条件直接就是遍历过程，23究极合体 for(int row = 0; row &lt; 9; row++) { for(int col = 0; col &lt; 9; col++) { //来判断是不是可以填数，是点的话就可以填 if(board[row][col] == '.') { //来判断填哪个 for(int i = 1; i &lt;= 9; i++) { if(isValid(row, col, i, board))//如果这个位置填这个i是合理的 { //填上这个数 board[row][col] = i + '0'; //去回溯,遇到true了，直接返回 if(backtracing(board)) return true; board[row][col] = '.'; } } //如果9个数遍历完了，都不能填，那么返回false return false; } } } //所有格子都填满了 return true; } bool isValid(int row, int col, int val, vector&lt;vector&lt;char&gt;&gt;&amp; board) { //判断行 for(int j = 0; j &lt; 9; j++) { if(board[row][j] == val + '0') return false; } //判断列 for(int i = 0; i &lt; 9; i++) { if(board[i][col] == val + '0') return false; } //判断9宫格 row = (row / 3) * 3; col = (col / 3) * 3; for(int i = row; i &lt; row + 3; i++) { for(int j = col; j &lt; col + 3; j++) { if(board[i][j] == val + '0') return false; } } //判断下来，都没冲突的话就返回true return true; } void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) { backtracing(board); }};    这个题目感觉挺暴力的，就一个一个挨个查，这次回溯三部曲的2和3合体了，直接在遍历的过程中来判断是否该中止    至此，回溯章节的题目终于刷完啦~    明天就要开坑贪心算法喽~" }, { "title": "力扣-全排列II & 重新安排行程", "url": "/posts/%E5%8A%9B%E6%89%A3-%E5%85%A8%E6%8E%92%E5%88%97II&%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B/", "categories": "算法刷题", "tags": "回溯, 哈希表", "date": "2022-05-25 14:00:00 +0000", "snippet": "47. 全排列 IIclass Solution {public: vector&lt;int&gt; path;//单一序列 vector&lt; vector&lt;int&gt;&gt; ans;//序列集合 bool isUsed[8] = {false};//回溯一整根树枝时需要判断某个位置的数字是否使用过 //回溯三部曲 //1.确认回溯返回类型，返...", "content": "47. 全排列 IIclass Solution {public: vector&lt;int&gt; path;//单一序列 vector&lt; vector&lt;int&gt;&gt; ans;//序列集合 bool isUsed[8] = {false};//回溯一整根树枝时需要判断某个位置的数字是否使用过 //回溯三部曲 //1.确认回溯返回类型，返回参数,因为是要所有的排列组合，所以不需要记录startIndex void backtracing(vector&lt;int&gt;&amp; nums) { //2.终止条件 if(path.size() == nums.size()) { ans.emplace_back(path); return; } //3.每次回溯的遍历过程，去重只要在每次回溯的循环中，不出现相同的数字即可 //起初每个数字都没用过 bool isRepeat[21] = {false}; for(int i = 0; i &lt; nums.size(); i++) { //如果这一位的数字使用过，继续 if(isUsed[i]) continue; //如果在同一树层（也就是一次回溯的循环中，出现了相同的数字，也要继续） if(isRepeat[nums[i] + 10]) continue; //如果没用过，而且是首次出现 isRepeat[nums[i] + 10] = true;//设置为true，这样的话，下次再出现就跳过了 isUsed[i] = true;//设置为true，用过就跳过了 path.emplace_back(nums[i]); backtracing(nums); path.pop_back(); isUsed[i] = false;//当这个节点回溯完了，要将是否使用过重置为false } } vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) { backtracing(nums); return ans; }};    这次不仅要在全局判断是否使用过，还要判断是否重复使用过（为了去重）332. 重新安排行程class Solution {public: //unordered_map&lt;出发机场， &lt;目标机场，航班次数&gt;&gt; unordered_map&lt;string, map&lt;string, int&gt;&gt; targets; //储存行程 vector&lt;string&gt; result; //机票的张数 int ticketsNum; //回溯三部曲 //1.确认返回类型，参数 bool backtracing(string cur) { //2.中止条件,当行程中的机场数量等于及票数+1时 if(result.size() == ticketsNum + 1) { return true; } //3.每次回溯的遍历,遍历当前机场所有的目标机场 for(const pair&lt;string, int&gt; &amp; target : targets[cur]) { //如果目标机场已经飞过，没有航班次数了 if(target.second == 0) continue; else//如果没有飞过 { //把这个没飞过的机场加入到result中 result.emplace_back(target.first); //航班次数-1，说明这次用掉了一张机票,机票出发机场为cur，目标机场为target.first targets[cur][target.first]--; //如果在某次回溯中返回了true， //说明一直有满足条件的机场，最终result的长度也=ticketsNum + 1了 //那么直接退出递归 if(backtracing(target.first)) return true; //说明这条行程不行，航班次数加回来，去飞下一个机场 targets[cur][target.first]++; result.pop_back();//删掉 } } //如果遍历完了，还没有结束，那么说明这条行程不对 return false; } vector&lt;string&gt; findItinerary(vector&lt;vector&lt;string&gt;&gt;&amp; tickets) { //初始化出发机场到目标机场的哈希表 //遍历每一张机票 for(vector&lt;string&gt; &amp; ticket : tickets) { //ticket[0]指的是机票的出发机场，ticket[1]是目标机场，++就是航班次数+1 targets[ticket[0]][ticket[1]]++; } //从JFK出发 result.emplace_back(\"JFK\"); ticketsNum = tickets.size(); backtracing(\"JFK\"); return result; }}; 行程要字典排序最小的那个，所以这里要用哈希表map来存机票，出发机场可能有多个目标机场，到目标机场的机票通过map自动排好序，那么再遍历的时候，自然是从字典顺序最小的开始 行程要避免死循环，所以1中的map的第二个值是航班次数，一旦用过了，就要减掉，这样之后再回溯的时候发现航班次数为0了就会跳过 判断中止条件，就是当找到第一条行程时，他就是答案了，因为按1中的逻辑，他已经是字典序最小的行程了，这个时候返回true，那么在之前的回溯也会返回true，一层一层返回回去，就直接结束递归了 遍历机场所有机场的时候，使用const pair&lt;string, int&gt;来遍历出发机场也就是cur的unordered_map中的第二个参数map " }, { "title": "力扣-递增子序列 & 全排列", "url": "/posts/%E5%8A%9B%E6%89%A3-%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97&%E5%85%A8%E6%8E%92%E5%88%97/", "categories": "算法刷题", "tags": "回溯", "date": "2022-05-23 03:50:00 +0000", "snippet": "491. 递增子序列class Solution {public: vector&lt;int&gt; path;//储存某个单一子序列 vector&lt;vector&lt;int&gt; &gt; ans;//答案集合 //回溯三部曲 //1.确认返回类型、参数 void backtracing(vector&lt;int&gt;&amp; nums, i...", "content": "491. 递增子序列class Solution {public: vector&lt;int&gt; path;//储存某个单一子序列 vector&lt;vector&lt;int&gt; &gt; ans;//答案集合 //回溯三部曲 //1.确认返回类型、参数 void backtracing(vector&lt;int&gt;&amp; nums, int startIndex) { //2.中止条件，如果path长度大于等于2了加入答案集合 if(path.size() &gt;= 2) { ans.emplace_back(path); } //3.每次回溯的遍历过程 //这个哈希表只是服务于一次回溯的遍历过程，也就是同一层，但再往下一层回溯时，是可以出现重复数字的 unordered_map&lt;int, int&gt; m; for(int i = startIndex; i &lt; nums.size(); i++) { //先判断是否是递增的,如果不递增，直接继续,或者同一层已经出现过了（为了去重） //注意，递增是要和path的最后一个数字对比，不是和数组的上一个对比 if(( path.size() &amp;&amp; nums[i] &lt; path.back() )|| m.count(nums[i])) continue; else { path.emplace_back(nums[i]); m[nums[i]]++; backtracing(nums, i + 1); path.pop_back(); } } } vector&lt;vector&lt;int&gt;&gt; findSubsequences(vector&lt;int&gt;&amp; nums) { backtracing(nums, 0); return ans; }};    注意，递增是要和path的最后一个数字对比，不是和数组的上一个对比，用参数传递序列最后一位，不如直接用path.back()。    注意去重，去掉同一层相同的数字。46. 全排列class Solution {public: vector&lt;int&gt; path; vector&lt; vector&lt;int&gt;&gt; ans; //用来记录数字是否使用过 unordered_map&lt;int, int&gt; m; //经典回溯三部曲 //1.确认返回类型和参数 void backtracing(vector&lt;int&gt;&amp; nums) { //2.中止条件 if(path.size() == nums.size()) { ans.emplace_back(path); } //3.每次回溯的遍历过程 for(int i = 0; i &lt; nums.size(); i++) { //如果这个数字用过 if(m.count(nums[i])) continue; else { m[nums[i]]++; path.emplace_back(nums[i]); backtracing(nums); //当一个分支回溯完了，那么将该数退出 path.pop_back(); //也要在表中删除 m.erase(nums[i]); } } } vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) { backtracing(nums); return ans; }};    我用了哈希表来存值判断是否使用过，我看可以用一个bool数组来判断是否用过这个数字，空间应该会节省更多。" }, { "title": "力扣-子集 & 子集II", "url": "/posts/%E5%8A%9B%E6%89%A3-%E5%AD%90%E9%9B%86&%E5%AD%90%E9%9B%86II/", "categories": "算法刷题", "tags": "回溯", "date": "2022-05-22 06:45:00 +0000", "snippet": "78. 子集class Solution {public: vector&lt;int&gt; path;//储存每一个组合 vector&lt;vector&lt;int&gt; &gt; ans;//子集 //1.回溯三部曲，确认返回类型、参数 void backtracing(vector&lt;int&gt;&amp; nums, int startIndex...", "content": "78. 子集class Solution {public: vector&lt;int&gt; path;//储存每一个组合 vector&lt;vector&lt;int&gt; &gt; ans;//子集 //1.回溯三部曲，确认返回类型、参数 void backtracing(vector&lt;int&gt;&amp; nums, int startIndex) { //2.中止条件 //因为每个组合都要存放在子集中，所以每次都要保存，所以其实是没有中止条件的 ans.emplace_back(path); //3.每次回溯的遍历过程 for(int i = startIndex; i &lt; nums.size(); i++) { path.emplace_back(nums[i]); backtracing(nums, i + 1); path.pop_back(); } } vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) { backtracing(nums, 0); return ans; }};    backtracing(nums, i + 1);一开始写成了backtracing(nums, startIndex + 1);结果不对，传给下一次回溯的应该是当前i的下一位，startInde下一位的话，会有重复的内容。90. 子集 IIclass Solution {public: //树层去重方法 vector&lt;int&gt; path;//储存每一个组合 vector&lt;vector&lt;int&gt; &gt; ans;//子集 //1.回溯三部曲，确认返回类型、参数 void backtracing(vector&lt;int&gt;&amp; nums, int startIndex) { //2.中止条件 //因为每个组合都要存放在子集中，所以每次都要保存，所以其实是没有中止条件的 ans.emplace_back(path); //3.每次回溯的遍历过程 for(int i = startIndex; i &lt; nums.size(); i++) { path.emplace_back(nums[i]); backtracing(nums, i + 1); //去重,保证当前位置的数字与下一个不一样 while(i &lt; nums.size() - 1 &amp;&amp; nums[i] == nums[i + 1]) i++; path.pop_back(); } } vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) { //需要先对数组排序 sort(nums.begin(), nums.end()); //回溯 backtracing(nums, 0); return ans; }};    这个要注意去重代码的位置，去重应该是这一根树枝已经回溯完了，要回溯下一根树枝时去重，这样去掉的才是统一树层中的相同树枝。    我开始把去重放在了for循环的开始，这样是不对的，会少很多组合。" }, { "title": "游戏设计艺术-学习笔记", "url": "/posts/GameDesignNote/", "categories": "游戏设计", "tags": "学习笔记, 游戏设计艺术", "date": "2022-05-22 06:45:00 +0000", "snippet": "第一章 太初之时，有设计师​ 游戏设计师最重要的技能是倾听​ 五种倾听：倾听 团队、受众、游戏、客户、自己 的声音 。第二章 设计师创造体验​ 人们在玩游戏时会产生一种体验，缺少体验的游戏毫无价值。游戏体验会产生特定的感受，选择感、自由感、责任感、成就感、友情和其他只有基于游戏体验才能获得的感受。 一号透镜：情感 ​ 为了确定你创造的情感是正确的,问自己这几个问题: 我希望玩家...", "content": "第一章 太初之时，有设计师​ 游戏设计师最重要的技能是倾听​ 五种倾听：倾听 团队、受众、游戏、客户、自己 的声音 。第二章 设计师创造体验​ 人们在玩游戏时会产生一种体验，缺少体验的游戏毫无价值。游戏体验会产生特定的感受，选择感、自由感、责任感、成就感、友情和其他只有基于游戏体验才能获得的感受。 一号透镜：情感 ​ 为了确定你创造的情感是正确的,问自己这几个问题: 我希望玩家能够体验到怎样的情感?为什么? 当人们(包括我自己)玩游戏时,他们产生了怎样的情感?为什么? 我怎样缩小人们的实际体验与我设想之间的距离 ? 二号透镜:本质体验 ​ 要想使用这个透镜,你需要停止你的游戏,开始思考游戏给玩家的体验,问自己这几个问题: 我想让玩家获得怎样的体验 这种体验的本质是什么 我应该如何让我的游戏抓住这种体验的本质 第三章 体验发生于场景​ 私人场景：炉边、工作台、读书角；分别如电视机前、书桌、躺椅。​ 公共场合：剧场、竞技场、博物馆​ 半公开半私人场景：游戏桌、操场、随时随地 三号透镜：场景 ​ 在我们的游戏设计中，我们玩游戏的场景队游戏会产生巨大的影响。为了确认你没有凭空设计游戏，问自己这几个问题： 我想要制作的游戏最适合哪些场景？ 我的场景中是否有一些特殊的属性会影响到我的游戏？ 我的游戏中有哪些元素能与场景和谐共处？哪些元素不行？ 第四章 体验从游戏中诞生​ 惊喜和有趣在每个游戏设计中都是重要的部分。 四号透镜：惊喜 ​ 惊喜是一种我们很容易忘记的基础情绪。这个透镜来提醒你让你的游戏充满惊喜： 当玩家玩我的游戏时，什么会让他们感到惊喜？ 我的游戏中的故事有惊喜吗？或者规则呢？或者艺术呢？或者技术呢？ 你的规则能够让玩家之间互相带来惊喜吗？ 你的规则能够让玩家们给自己带来惊喜吗？ 五号透镜：乐趣 ​ 尽管有时候乐趣无法被分析，但在几乎所有的游戏中乐趣都是令人喜爱的。为了最大化游戏的乐趣，问你自己这几个问题： 我的游戏中哪个部分很有趣，为什么？ 哪个部分需要变得更加有趣？ ​ 玩耍是沉迷于好奇心的活动。 ​ 六号透镜:好奇心 ​ 要使用这个透镜,思考玩家的真的动机——不是游戏的目标，而是玩家想要完成目标的真正原因。问自己这几个问题： 我的游戏给玩家的大脑提出了怎样的问题？ 我正在做哪些努力让他们在意这些问题？ 我能做什么来使他们提出更多的问题？ ​ “游戏是一种对自主控制系统的练习，其中包含了力量的竞争，被规则限制以产生一个不平衡的结果。”——艾略特​ 这条定义包含了以下游戏的关键特质： 游戏是完全自主的 游戏有目标 游戏有冲突 游戏有规则 游戏有输赢 七号透镜：内生价值 ​ 一个游戏的成功与玩家认为它是否重要紧密相关。要使用这个透镜来思考一下，在你的游戏中，玩家对道具、目标和分数的感受。二五年你自己这几个问题： 在我的游戏中哪些东西对玩家很有价值？ 怎样让这些东西对玩家更有价值？ 游戏中的价值与玩家的动机之间有怎样的关系？ 思考玩家真正在意的东西 ​ “（游戏是）一个拥有内在意义的交互结构，需要玩家们努力完成目标。”——格雷格·科斯蒂基安​ 这条定义给出了三个新的特质： 游戏是可交互的 游戏具有挑战性 游戏能够创造它自己的内在价值这些特质总结出游戏共通的特质：解决问题​ 游戏是一种以嬉戏的态度进行的解决问题的活动 八号透镜：解决的问题 ​ 要使用这个透镜，需要思考一下游戏中的问题，由于每个游戏都有一些等待解决的问题，在你的游戏中，玩家需要解决哪些问题才能在游戏中获胜。问你自己这几个问题： 我的游戏要求玩家解决哪些问题？ 是否有一些隐藏的问题作为玩法的一部分出现？ 在我的游戏中，怎样产生新的问题来对玩家保持吸引力？ 本章总结 快乐是一种带有惊喜的满足感 玩耍是一种满足好奇心的行为 玩具是你玩耍的对象 优秀的玩具是一个能够带来乐趣的物品 游戏是一种以嬉戏的态度进行的解决问题的活动第五章 游戏由元素构成​ 四种基本元素：美学、机制、故事、技术 （没有任何一种元素比其他的更重要） 九号透镜：四种元素 ​ 要使用这个透镜，观察你的游戏实际上是有什么构成的，单独考虑各种元素然后将它们统一看待，问你自己这几个问题： 我的游戏设计使用了全部的四种元素吗？ 我的设计能够通过增强一种或者多种分类的元素来获得提高吗？ 四种元素是否和谐，互相作用并向同一个主题努力？ ​ 拓展这项技能：全息设计——在观察你自己体验的同时，思考产生体验的潜在原因。 十号透镜：全息设计 ​ 要是用这个透镜，你必须一次性看到游戏的全部：四种元素和玩家体验，以及他们是怎样关联起来的。你可以把注意力从皮肤转移到骨骼再到皮肤，但更好的方法是全息观察游戏和体验。问你自己这几个问题： 游戏中的哪一种元素产生了令人享受的体验？ 游戏中的哪一种元素会让玩家在体验中分心？ 怎样改变游戏元素来提高游戏体验？ 第五章总结​ 两个字：协同第六章 元素支撑起主题​ 我们的目标不是艺术化的表达，而是创造伟大的体验。我们所作的所有事和所有决定都聚焦在是否能够强化主题，传达我们想要给予的必要体验。 十一号透镜：统一 ​ 要使用这个透镜,就要尽可能地考虑到这背后所有的原因.问你自己这几个问题: 我的主题是什么? 我已经采用了所有可能的方法来强化这个主题吗? 统一透镜与九号透镜元素四分透镜很搭配。使用元素四分透镜从你的游戏中分割出元素，你就能够从统一主题的角度更方便地研究他们​ 共鸣主题能把你的作品升华为艺术，艺术家会引领你进入无法独自到达的领域，而主题就是让你前行的工具。 十二号透镜：共鸣 ​ 要使用这个透镜，你必须去寻找隐藏的力量，问你自己这几个问题： 在我的游戏中，能感觉到哪些有力的或者特殊的元素？ 将我的游戏描述给他人听时，哪些创意能让他们真的兴奋吗？ 如果没有任何限制，这个游戏将会变成怎样？ 我对这个游戏的方向有特定的直觉，那到底是什么在驱动这种直觉呢？ 共鸣透镜是一件安静美妙的乐器，也是一种倾听自己和他人的工具。我们把重要的事物都埋藏在内心的深处，当某些东西引起了它们的共鸣时，就会触动我们的内心。事实上这些隐藏的特性给了它们力量，也让我们难以寻找 第七章 游戏始于一个创意​ 不要从其他杂技演员那里寻找灵感——到其他地方去看看。 十三号透镜：无尽灵感 ​ 要使用这个透镜，不要思考你的游戏，也不要观察那些看起来差不多的游戏。正相反，你要四处看看。问你自己这几个问题： 我的生活中有怎样的体验想要与他人分享？ 有哪些小技巧可以让我捕捉到体验的本质，并把它纳入我的游戏中？ ​ 清晰地陈述你的问题将带来三项优势： 更广阔的创造空间 更清晰地评估 更顺畅的交流 十四号透镜：问题陈述 ​ 要是用这个透镜，需要把你的游戏当作解决问题地方案。问你自己这几个问题： 我真正想要解决什么问题？ 我是否做过一些与真正目标无关的游戏设定？ 游戏是不是这个问题最好的解决方案？为什么？ 我将怎样分辨出问题是否已经解决了？ 为你的游戏定义好约束条件和目标，并把这些作为问题陈述，这能帮助你更快地进入清晰的游戏设计中十六个关键的头脑风暴建议 记下答案 写字还是打字 草图 玩具 改变你的视角 沉浸你自己 开几个玩笑 不要节约 写在墙上 空间记忆 记下所有东西 为你的清单计数 颠覆你的设定 组合和搭配分类 自言自语 找一个搭档​ 对于一个四人以上的团队，更好的做法时每个人首先独立地进行头脑风暴，然后在聚集在一起分享、交换和匹配他们的创意，一起解决问题。第八章 游戏通过迭代提高​ 创意不是一个完好的瓷器，而是一次性纸杯——他很廉价，能够大量生产。八项测试 艺术冲动。“这个游戏看起来不错吗” 人群特征。“我们的目标受众很喜欢这个游戏吗” 体验设计。“这个游戏设计得不错吗” 革新。“这个游戏是否与众不同” 商业和市场。“这个游戏能盈利吗” 工程。“这个游戏在技术上是否具备可行性“ 社交/社区。”这个游戏完成我们得社交或者社区目标了吗？“ 玩法测试。”游戏测试者是否享受这个游戏？“ 十五号透镜：八项测试 ​ 要使用这个透镜，你的设计必须满足许多约束条件。只有当它通过了八项测试而不需要修改时，你的设计才算完成。问你自己这八个关键问题： “这个游戏看起来不错吗” “我们的目标受众很喜欢这个游戏吗” “这个游戏设计得不错吗” “这个游戏是否与众不同” “这个游戏能盈利吗” “这个游戏在技术上是否具备可行性“ ”这个游戏完成我们得社交或者社区目标了吗？“ ”游戏测试者是否享受这个游戏？“ 在某些情况下，还需要考虑一些其他得测试。例如，教育游戏必须回答这样得的问题：”这个游戏达到教育目标了吗“ ​ 迭代规则：你的游戏测试和改进的次数越多，就会越出色。​ 敏捷开发核心元素： 灵活的目标 优先级列表 冲刺（ddl） 争分夺秒会议 演示日（观看测试结果，分析风险并确定下一阶段冲刺计划） 回顾 十六号透镜：风险消除 ​ 要使用这个透镜，停止积极地思考，然后开始认真考虑那些会危机游戏的风险。问你自己这几个问题： 是什么让这个游戏变得平庸？ 我们怎样防止这样的风险发生？ 制作有效原型的十个技巧 回答问题 忘记质量 不要太过留恋 区分原型优先级 有效的并行原型（同时制作几个原型） 并不总需要数字化（纸上原型） 无须交互 选择一个”快速迭代“的游戏引擎 先构建玩具 抓住更多迭代的机会 十七号透镜：玩具 ​ 要使用这个透镜，不要思考你的游戏是否好玩，而是思考参与这个游戏是否有趣。问你自己这几个问题： 如果我的游戏没有目标，它会有趣吗？如果不是，我怎样才能改进它？ 当人们考到我的游戏时，他们想要与它产生互动吗，甚至在他们知道应该怎样玩之前？如果不是，我怎样才能改进它？ 十八号透镜：激情 ​ 在每个原型的结尾，当你小心的消除风险并计划下一步时，别忘了用这些重要的问题检验你对游戏的感受： 我对这款游戏的成功是否抱有极大的激情？ 如果我失去了激情，我怎样才能找回它？ 如果敬请没有回来，我是否应该做一些其他事呢？ 第九章 游戏为玩家而生​ 男性玩家喜欢在游戏中看到的五件事：掌握、竞争、破坏、空间谜题、试错。​ 女性玩家喜欢在游戏中看到的五件事：情感、现实世界、照料、对话与字谜、通过例子学习。 第十九号透镜：玩家 ​ 要使用这个透镜，你需要停止思考你的游戏，开始思考你的玩家。问你自己这几个关于你的目标玩家的问题： 他们通常喜欢什么？ 他们不喜欢什么，为什么？ 他们希望能在你的游戏中看到什么？ 如果我处在他们的位置上，我想要在游戏中看到什么？ 他们将会特变喜欢或者不喜欢游戏中的哪一部分？ ​ 勒布朗的游戏乐趣分类：感官、幻想、叙事、挑战、团队关系、探索、表达、服从。​ 巴特尔的玩家类型分类：成功者、探索者、社交者、杀手。​ 更多的乐趣：预感、完成、幸灾乐祸、赠与礼物、幽默感、可能性、成就的自豪感、惊喜、激动、战胜逆境、难以置信、 二十号透镜：乐趣/愉悦 ​ 要是用这个透镜，思考你的游戏提供了哪些类型的乐趣。问你自己这几个问题： 你的游戏能给玩家带来哪些乐趣？这些乐趣能够继续改善吗？ 你的体验中缺少了那些乐趣，为什么？能够在游戏中增加这种乐趣吗？ 第十章 体验在玩家的脑中​ 四项主要心理能力令玩游戏成为可能：建模、专注、想象、共情。​ 玩家进入心流状态，要达到以下关键点：目标清晰、没有干扰、反馈直接、持续挑战。 二十一号透镜：心流 ​ 使用本透镜前，请考虑是什么在吸引玩家的注意力。问自己这些问题： 我的游戏有清晰的目标吗？如果没有，怎样改好？ 玩家目标和我所希望的一致吗？ 游戏中是否有令玩家分心，以致忘记目标的部分？若有，能否减少这些干扰，或能否融入游戏目标内？ 我的游戏是否稳定提供连串不太容易，也不太难的挑战？有没有考虑到玩家的技巧可能逐步提高？ 玩家的技巧提高的速率和我的期望相符吗？若不是，游戏该怎样改进？ ​ 想象力有两个重要功能：第一是交流（一般用于讲故事）；第二是解决问题。第十一章 玩家的动机驱使着玩家的脑马斯洛的人类需求层次 第一层：生理——食物、水、居所、温暖 第二层：安全——安全、稳定、免于恐惧 第三层：归属之爱——朋友、家人、配偶、恋人 第四层：尊重——成就、掌握、认可、尊重 第五层：自我实现——追求内在才能、创造力、愿望满足 瑞安和德西的三大精神需求 胜任：我需要觉得自己擅长做些什么 自主：我需要按自己的方式做事的自由 关联：我需要和其他人建立联系 二十二号透镜：需求 ​ 要使用此透镜，先不要考虑你的游戏本身，改为考虑它满足人类的哪些基础需求。问自己这些问题： 我的游戏主要运作在马斯洛层次的那一层？ 我的游戏是否满足“胜任、自主、关联”的需求？ 我怎样让游戏在现有水平上，满足更多基础需求？ 游戏已经满足的需求，怎样令其满足得更好？ 说游戏能满足人类得基础需求，虽有点奇怪，但人类的一切行为，都是在以某种方式满足这些需求。记住，有些游戏比其他游戏更能满足需求——所以你的游戏不能仅仅对绣球作出承诺，而要切实满足。玩家本来以为玩你的游戏能够让自己感觉良好，或者和朋友交往更密，结果你的游戏没能满足需求，玩家就会改玩其他能满足的游戏了动机   规避痛苦（得dei做） 追求愉悦（想做） 外在动机 为了避免惩罚 为了奖赏 内在动机 为了避免愧疚 为了快乐 二十三号透镜：动机 ​ 每个游戏都是由动机组成的复杂的生态系统。要细致地加以研究，请问自己这些问题： 玩家因何种动机来玩我的游戏？ 其中哪些动机是最内在的？ 哪些是追求愉悦的？哪些是规避痛苦的？ 哪些动机互相支撑？ 哪些动机互相抵触？ ​ 创新：每一个成功的游戏都是新鲜与熟悉的混合体。 二十四号透镜：创新 我的游戏有何新奇之处？ 新奇之处是贯穿物品的游戏还是仅限于开头？ 新奇和熟悉的混合感觉对吗？ 新奇感退去后，玩家还会喜欢玩我的游戏吗？ 评断 二十五号透镜：评断 针对玩家，你的游戏都评价些什么？ 游戏怎样传达这种评断？ 玩家觉得评断结果公平吗？ 他们在意评断结果吗？ 评断结果是否让他们想要加强能力？ 第十二章 有些元素是游戏机制七大类游戏机制 空间 二十六号透镜：功能空间 ​ 要使用此透镜，请思考将所有表面元素剥离你的游戏之后，游戏究竟在什么空间内进行。问自己以下问题： 游戏空间是离散的还是连续的？ 它有几个维度？ 空间的边界在哪里？ 有没有子空间？空间如何互相联系？ 是否有不止一种合理方式给游戏空间建立抽象模型？ ​ 功能空间透镜与10号透镜全息设计合用，效果很好。 时间 二十七号透镜：时间 ​ 俗话说“时间就是一切”。我们身为设计师的目标是创造体验，而体验如果太长、太短、太快、都很容易扫兴。要让你的体验长度刚刚好，可问自己以下问题： 究竟是什么决定了我的游戏活动长度？ 我的玩家是否因为游戏结束太快，感到沮丧？我怎样才能改变这种状况？ 我的玩家是否因为游戏时间太长，感到无聊？我怎样才能改变这种状况？ 时钟和禁赛能不能让我的游戏玩法更激动人心？ 时间限制也许会让玩家烦躁、我去掉时间限制会更好吗？ 有层级的时间架构对我的游戏是否有益？或者说，几个小回合组成一个大回合好不好？ 要把时间调至合适的程度很难，但时间能成就一款游戏，也能毁掉一款游戏。听从以前歌舞艺人的格言“吊着他们的胃口”，一般不会错。 对象、属性和状态 二十八号透镜：状态机 ​ 要使用此透镜，请思考你的游戏种哪些信息在改变。问自己这些问题： 我的游戏种有什么对象？ 这些对象的属性是什么？ 每个属性有什么可能的状态？ 每个属性中，是是什么出发状态改变？ 玩游戏的过程就是做决定，决定是根据信息做出的。决定不同的属性、属性的状态、改变状态的时间，就是你游戏机制的核心。 二十九号透镜：秘密 ​ 改变谁掌握哪些信息，就能彻底改变你的游戏。要使用此透镜，请思考“谁”知道“哪些”，又是“为什么”。问自己这些问题： 哪些信息只有游戏本身知道？ 哪些信息只有玩家知道？ 哪些信息只有一些或一个玩家知道？ 改变谁掌握哪些信息，可以改进我的游戏吗？ 游戏过程就是做决定的过程。决定根据信息做出。决定不同的属性及其状态，以及谁了解它们，是你的游戏机制的核心。对谁知道哪些信息做一些小修改，可以极大地改变一个游戏——或者强到飞起，或者低到尘埃里。谁知道哪些属性这件事甚至可以在游戏过程种改变——想在你地游戏种创造戏剧性，一大方法就是突然将一条重要地私密信息公开 行动 打造”自发玩法“，即”有趣地策略行动“的五个提示： 添加更多动词 能在许多对象互动的动词 用各种方式达成的目标 许多主体 改变限制条件的额外效果 三十号透镜：自发 ​ 要确保你的游戏有有趣的自发玩法。问自己这些问题： 我的玩家有多少动词可选？ 每个动词可作用于多少对象？ 玩家要达成目标有多少种方式？ 玩家控制多少主体？ 额外效果如何改变限制条件？ ​ 你选择哪些行动，很大程度定义你游戏的结构。 三十一号透镜：行动 ​ 要使用此透镜，请思考你的玩家能做些什么、不能做什么，分别是为什么。问自己这些问题： 我游戏中的基础行动是什么？ 策略行动又是什么？ 我想要看到什么样的策略活动？我怎样改变游戏，令这些行动成为可能？ 策略行动与基础行动的比例，我满意吗？ 玩家在我的游戏中有什么想做但不能做的行动？我能不能设法令其成为可能，无论作为基础行动或策略行动？ 没有行动的游戏就像是没有动词的继承自——什么也不会发生。你身为游戏设计师要做的最基础的决定，便是确定你游戏中的行动。对这些行动进行微小改变也会对游戏造成一系列巨大影响，可能会创造出惊人的自发玩法，也可能让游戏变得波澜不惊又繁琐、要小心选择你的行动，学会听从你游戏的声音、玩家的声音，从中了解你的选择能带来什么。 规则帕莱特的规则分析：操作规则、基础规则、行为规则、书面规则、赛事条例、官方规则、建议性规则、房规。模式：玩家永远不该花费太长时间在子游戏内，以致忘记了在著游戏里做什么。最重要的规则：具体、可行、回报丰厚的目标 三十二号透镜：目标 ​ 为了确保游戏目标适当且均衡，请问自己以下问题： 我的游戏的中级目标是什么？ 这个目标对玩家明确吗？ 如果有一系列目标，玩家明白吗？ 不同的目标是否以一种有意义的方式相互关联？ 我的目标是否具体、可行、汇报丰厚？ 短期和长期目标是否平衡？ 玩家有无机会决定自己的目标？ 同时拿起17玩具透镜、6好奇透镜和目标透镜，它们之间会相互影响 三十三号透镜：规则 ​ 要使用此透镜，深刻观察你的游戏，知道能辨别其中最基础的架构。问自己这些问题： 我的游戏中基本规则是哪些？这些规则和操作规则有何不同？ 游戏开发过程中有没有形成”条例“或”房规“？这些是否应该直接纳入我的游戏中？ 我的游戏中又不同的模式吗？这些模式让一切更简单，还是更复杂？减少一些模式会让游戏更好玩吗？还是增加模式？ 谁来执行规则？ 规则是简单易懂，还是又晦涩之处？如果又晦涩支出要修订，是应该改变规则，还是更清除地解释规则？ 技巧​ 真实技巧：玩家拥有的​ 虚拟技能：玩家假装拥有的技能 三十四号透镜：技巧 ​ 要使用此透镜，先不要观察你的游戏本身，改为观察它要求玩家发挥的技巧。问自己这些问题： 我的游戏需要玩家拥有何种技能？ 其中是否缺少某个类别的技能？ 哪些技能占主导地位？ 这些技能是我想要创造的体验吗？ 是否有一些玩家的这些技能远超过其他玩家？这是否让游戏感觉不公平呢？ 玩家能不能通过练习提高技巧，从而感觉掌握了游戏？ 游戏需要的技巧水平合适吗？ 概率 内容涉及概率论知识。 三十五号透镜：期望值 ​ 要使用此透镜，请思考你的游戏内发生的各种不同事件，以及它们对玩家有什么意义。问自己这些问题： 某些事件发生的实际概率是多少？ 感知概率又是多少？ 这件事的结果有什么价值？此价值能否被量化？有没有我没考虑到的无形价值？ 当我把所有可能的结果相加，玩家可以采取的每个行动都有着不同的期望值。我对这些满意吗？它们石佛给玩家有趣的选择？会不会奖赏太多，或者惩罚太过？ 纠结的技巧和概率 估算概率是一种技巧 技巧都有成功率 估计对手的技巧也是种技巧 预测纯概率是一种想象种的技巧（两个虚假规律：“热手谬误“：我连赢好几次，所以下次也可能赢；”赌徒谬误“：我连输了好几次，所以下次会赢） 控制纯概率是一种想象中的技巧 三十六号透镜：概率 ​ 要使用此透镜，专注于游戏中包含随机和风险的那部分，时刻记住两者有不同之处。问自己这些问题： 我的游戏中真正随机的内容是什么？哪些部分只是感觉起来随机？ 随机性给玩家的，是刺激和体哦站等积极情感，还是绝望和缺乏控制能消极情感？ 改变概率分布曲线能改进我的游戏吗？ 玩家能在游戏中冒各种有趣的风险吗？ 我的游戏中，概率与技巧之间有何关系？有没有办法可以让随机元素感觉像是在发挥技巧？有没有办法让发挥技巧感觉像是在冒风险？ 第十三章 游戏机制必须平衡十二种最常见的游戏平衡1. 公平对称游戏和不对称游戏属性相克 三十七号透镜：公平 ​ 要使用公平透镜，请从每个玩家的视角仔细思考游戏。考虑每个玩家的技巧水平，找到一种方法让每个玩家都有机会获胜，并且各自都认为公平。问自己这些问题： 我的游戏应该对称吗？为什么？ 我的游戏应该不对称吗？为什么？ 以下哪点更重要：我的游戏赢能有效地衡量谁的技巧水平最高；或是，我的游戏应该为所有玩家都带来有趣的挑战？ 如果我想要不同水平的玩家一起玩，我会用什么手段，令游戏对所有人都具有趣味性和挑战性？ 2.挑战与成功 随着每次成功增加难度 让玩家快速打通容易的部分 创建”层层挑战“ 让玩家自选难度级别 请各种玩家进行试玩 让失败者休息一下（《马里奥赛车》发放道具机制：前弱后强） 三十八号透镜：挑战 ​ 挑战是几乎所有游戏玩法的核心。你甚至可以说，一个游戏由它的目标和挑战所定义。请一边检查自己游戏中的挑战，一边问自己这些问题： 我的游戏中挑战是什么？ 它们是太容易，太难还是刚刚好？ 我的这些挑战能否容纳各种各样的技巧水平？ 随着玩家不断成功，挑战难度如何增长？ 挑战的种类是否多样？ 我的游戏中最高水平的挑战是什么？ 3. 有意义的选择 如果选择&gt;欲望，则玩家感到不堪重负 如果选择&lt;欲望，则玩家感到沮丧 如果选择=欲望，则玩家感觉自由和满足 三十九号透镜：有意义的选择 ​ 当我们做出有意义的选择后，会感觉自己做的事情很重要。要使用此透镜，问自己以下问题： 我要求玩家做何种选择？这些选择有意义吗？怎么做呢？ 我给玩家的选择数量对吗？加多些，是否让它们更有力量感？减少些，是否让游戏变得更清晰？ 我的游戏中是否有最优策略？ 三角：玩家、低风险低回报、高风险高回报 四十号透镜：三角形 ​ 让玩家选择小心形式获得小回报，还是冒大风险搏得大回报，是很有效得方式，可令你的游戏变得令人兴奋又有趣。要使用三角形透镜，问自己以下问题： 我的游戏中有三角形了吗？如果没有，怎样才能有呢？ 我常识构造得三角形平衡吗？换言之，回报与风险成比例吗？ 一旦你在各种游戏中寻找三角性，就会发现它无处不再，添加一点三角形，沉闷、单调 的游戏很快就会变得令人兴奋而满足。4. 技巧与概率 四十一号透镜：技巧与概率 ​ 为了帮你确定在自己的游戏中如何平衡技巧和概率，请问自己以下问题： 我的玩家是来接收评断（技巧）的，还是来冒风险（概率）的？ 技巧一般比概率更严肃：这是个严肃游戏们还是休闲游戏？ 我的游戏有没有乏味的部分？如果有，加入概率元素能盘活它吗？ 我的游戏中有没有感觉太随机的部分？如果有，及那个概率元素替换为技巧或策略元素，能让玩家感觉控制感更强吗？ 5. 头与手 四十二号透镜：头与手 ​ 为了确保心理和生理元素在你的游戏内获得更真实的平衡，请使用头与手透镜。问自己这些问题： 我的玩家想要无脑动作还是智力挑战？ 在游戏里更多地方包含解谜，会更加有趣吗？ 有没有地方可以让玩家放松大脑，只管玩，不用像事情？ 我能不能给玩家一个选择——可以展示高度敏捷，也可以找到一个最不需要身体技巧的聪明策略？ 如果”1分“是纯身体，”10分”是纯精神，我的游戏得几分？ 此透镜与19号透镜“玩家”共同使用效果尤其好6. 竞争与合作 四十三号透镜：竞争 ​ 确定某件事情上，谁最优秀，是人的基本冲动。竞争类游戏能满足这种冲动。请使用这副透镜，确保有人愿意在你得竞争游戏中获胜。问自己这些问题： 我的游戏对玩家技巧高低得衡量公平吗？ 人们是否像赢得我的游戏？为什么？ 在这个游戏中获胜是可以自豪的事情吗？为什么？ 新手可以在我的游戏中有意义地竞争吗？ 专家可以在我的游戏中有意义地竞争吗？ 专家们是否普遍肯定能够它们会打败新手？ 四十四号透镜：合作 ​ 作为一个团队进行协作并取得成功是种特别的快乐，可以创建持久的社交纽带。可使用这个透镜研究游戏中合作这一方面。问自己这些问题： 合作需要沟通。我的玩家有足够契机来沟通吗？如何加强沟通？ 我的玩家们已经是朋友，还是陌生人？如果它们是陌生人，能帮助它们破冰吗？ 玩家合作时有协同作用或者妨碍作用吗？为什么？ 玩家们都是相同角色，还是各有特殊分工？ 如果只靠一个人无法完成某项任务，就能大大加强了合作。我的游戏有此类任务吗？ 强制沟通的任务会激发合作。我有强制沟通的任务吗？ 四十五号透镜：竞争与合作 ​ 有许多有趣的方法可以实现竞争与合作平衡。使用此透镜来测定你的游戏中两者是否平衡得当。问自己这些问题： 如果“1分”是竞争，“10分”是合作，我的游戏得几分？ 我能不能让玩家选择，是合作还是竞争？ 我的受众喜欢竞争、合作还是两者混合？ 团队竞技适合我的游戏吗？我的游戏中，是团队竞争好玩，还是单人竞争好玩？ 7. 短与长游戏时间长短8.奖赏​ 赞美、分数、延长游戏、入口、演出、表现、能力、地位、完成；​ 奖励随进度增加、变化的奖励。 四十六号透镜：奖励 ​ 人人都喜欢听人称赞自己干得不错。要确认你的游戏是否在正确的时间、以正确的量给出正确的奖励，就得问这些问题： 我的游戏现在给出哪些奖励？我还能给出其他的吗？ 玩家在我的游戏中得到奖励后，是激动还是无聊？为什么？ 收到奖赏却不理解，如同根本没有奖赏，我的玩家理解它们收到的奖励吗？ 我的游戏中送出的奖赏是不是太有规律？能不能用更多变的方式送出呢？ 我的奖励之间有何种练习？有没有办法让它们连接得更好？ 我的奖励逐渐累积的方式如何？太快，太慢，还是正？ 每款游戏的奖励平衡都有所不同。设计师不光要挂念送出的奖励对不对，还要担心送出的时间对不对、量是否合适。而这只能通过试错来确定——就算试错过，也不一定适合每个人。常识调整奖励平衡很难做到完美——经常要安心于“足够好”。9. 惩罚​ 优点：惩罚创造内生价值、冒险激动人心、可能的惩罚增加挑战​ 常见惩罚类型：羞辱、失分、缩短游戏、中断游戏、倒退、剥夺能力、消耗资源 四十七号透镜：惩罚 ​ 惩罚一定要小心使用，毕竟玩家们是自主主动来玩游戏的。适当平衡的惩罚可以让你游戏中的一切更有意义，玩家在其中成功后也会有真正的自豪感。若要检验你游戏中的惩罚，问自己这些问题： 我的游戏中有什么惩罚？ 我为什么要惩罚玩家？我希望通过它来实现什么？ 我的惩罚在玩家看来公平吗？为什么？ 有没有办法把这些处罚改为奖励，并收到同样或更好的效果？ 我的强力惩罚，有没有相应丰厚的回报来平衡？ 10.自由体验与受控实验​ 有时要去掉那些无聊、繁复或者不必要的决定与行动。11.简单与复杂​ 固有复杂性：含有大量特殊情况​ 自发复杂性：简单的规则，却能产生很多局面 四十八号透镜：简单/复杂 ​ 在简单与复杂之间取得合适的平衡很难，但有理由必须做好。使用此透镜，能使你的游戏从简单系统中产生有意义的复杂性。问自己这些问题： 我的游戏有什么元素是固有复杂的？ 有办法令这种固有的复杂性可以变成自发的复杂性吗？ 我的游戏中是否会产生自发的复杂元素？如果没有，为什么？ 我的游戏中是否有些元素太过简单？ 四十九号透镜：优雅 ​ 大多数“经典游戏”都被认为是优雅的杰作。使用此副透镜，让你的游戏尽可能优雅吧。问自己这些问题： 我的游戏有哪些元素？ 每个元素的目的是什么？全部数出来，给每个元素一个“优雅评分”。 有的元素只有一个或者两个目的，能否合并一些或干脆剔除？ 有的元素有多重目的，能否让它们承担更多目的？ 五十号透镜：性格 ​ 优雅和性格是对立的。它们就像缩小版的简单与复杂，也必须保持平衡。要确保你的游戏有些可爱的怪地方能定义其性格，问自己这些问题： 我的游戏里有没有奇怪的东西，玩家会激动地讨论它们？ 我的游戏有没有好玩的特性，令其与众不同？ 我的游戏里有没有玩家喜欢的缺陷？ 12. 细节与想象​ 只做能做好的细节、给出供想象力使用的细节、熟悉的世界无需太多细节、使用望远镜效应、给出激发想象力的细节。 五十一号透镜：想象力 ​ 所有游戏都有一些想象元素以及一些与现实相关的元素，使用此透镜，帮助你找到细节与想象间的平衡。问自己这些问题： 要玩我的游戏，玩家必须明白什么？ 用一些想象元素能帮助它们更好的理解吗？ 在这个游戏中，我们提供哪些高质量、真实的细节？ 哪些细节，如果我们提供的话，质量会低？可以改用想象力来填补差距吗？ 我能给出些细节，让想象力一次又一次来使用？ 我提供的哪些细节能激发想象力？ 我提供的哪些细节会扼杀想象力？ 游戏平衡方法论 使用问题陈述透镜 加倍与减半 通过精准猜测训练你的直觉 记录你的模型 调整游戏的同时调整模型 计划好平衡 交给玩家平衡经济 五十二号透镜：经济系统 ​ 给游戏一个经济系统，能让它自己产生令人惊讶的深度和生命。但是，像所有的生物一样，它很难控制。使用此透镜来保持你的经济平衡： 我的玩家可以怎样转到钱？还应该有其他方式吗？ 我的玩家可以买什么？为什么？ 钱会来得太容易吗？太难吗？怎样改变呢？ 有关赚钱花钱的选择有意义吗？ 在我的游戏里做一种通用货币是好主意吗？还是应该有特殊货币呢？ 总览全局 五十三号透镜：平衡 ​ 游戏平衡有许多类型，每一种都很重要。然而，我们容易迷失在细节中，忘了全局。使用这个简单的透镜来脱出泥潭，只问自己一个最重要的问题： 我的游戏感觉对吗？为什么对？为什么不对？ 第十四章 游戏机制支持谜题​ 谜题就是有最优策略的游戏好的谜题原则 让目标变得简单易懂 让它容易上手 ”要设计一个好的谜题，首先要打造一个好的玩具“ 五十四号透镜：可达性 ​ 当你将一个谜题展示给玩家的时候（或任何一种游戏），它们应该可以清楚地知道最开始几个步骤是什么样子地，问问你自己这些问题： 玩家怎么知道如何解开我的谜题或者玩我的游戏？我是否需要解释，或者它是显而易见的？ 我的谜题或者游戏是否和它们之前见过的东西相像？如果是这样，我怎么能让他们注意到这些相似点？如果不是这样，我怎么能让他们理解谜题或游戏的动作？ 我的谜题或游戏是否吸引玩家而且让他们想感受它及操作它？如果不是，我如何能改变它使它变得吸引人。 给予进步感 五十五号透镜：可见进步 ​ 玩家在解决难题的时候需要看见他们正在进步。为了确保他们能够得到这个反馈，向你自己提出以下问题： 在你的游戏或者谜题里取得进步意味着什么？ 在我的游戏里有足够的成长吗？是否有方法能让我添加更多的中间步骤来让玩家逐步取得成功？ 哪些成长是可见的，哪些成长是隐藏的？我是否能找到一种方法来揭示那些隐藏的成长？ 给予可解决感 逐步增加难度 平行性让玩家休息 给予玩家两个或更多的平行挑战 五十六号透镜：平行性 ​ 你谜题中的平行性有益于提升玩家的体验。为了使用这个透镜，问你自己这几个问题： 在我的设计中存在瓶颈以致玩家不能通过一个特定的挑战就无法前进吗？如果是这样的，当玩家碰到这个挑战时，我是否可以给玩家增加一个平行挑战？ 如果平行挑战太相似了，平行性则无益，我的每个平行挑战之间是否足够不同，可以给玩家多样性的益处？ 我的平行挑战可以以某种方式联系起来吗？是否有办法使战胜挑战所取得的进步可以让解决另外的挑战变得容易吗？ 金字塔结构会延长兴趣 五十七号透镜：金字塔 ​ 金字塔使我们着迷，是因为它有一个单一的最高点。为了赋予你的谜题古老金字塔的魅力，问自己以下这些问题： 是否有方法将谜题中的所有部分注入游戏最终的单一挑战中？ 巨大的金字塔经常是由小金字塔组成的——我是否可以拥有一个具有前所未有挑战性的谜题元素层次，逐步地走向最终挑战？ 我的金字塔顶部的挑战是否有趣、吸引人而且清晰？它是否让人们想要为了达到它而愿意去工作？ 提示会延长兴趣 给出答案 感知转移是把双刃剑 五十八号透镜：谜题 ​ 谜题使玩家停下来思考，要确保你的谜题为达到你所塑造的玩家体验而全力以赴，问问自己这些问题： 我的游戏中的谜题是什么？ 我应不应该制作更多的谜题，或者更少？为什么？ 十条谜题原则中有哪些适用于我的谜题？ 我的游戏是否有任何不适宜的谜题？我怎么才能把它们更好地融入游戏内？（使用49号透镜，优雅，来做到这点）。 在之前几章里，我们聚焦在游戏内部，现在是时候来考虑一个外部因素了，游戏的界面。第十五章 玩家通过界面玩游戏界面就是存在于玩家和游戏世界之间的所有事物 五十九号透镜：控制 ​ 这个透镜的作用不只是用来检查你的界面，因为有意义的控制对沉浸式互动非常关键，在使用这个透镜之前，问自己以下几个问题： 当玩家使用界面时，它是否能尽其责？如果不能，为什么？ 直观的界面给人以控制感。你的界面时容易还是难以掌握呢？ 你的玩家是否感觉他们对游戏的结果有着强烈的影响力？如果不是，你如何来改变这种情况？ 感觉强大=掌控感。你的玩家是否感觉强大？你是否能设法使他们感觉更强大呢？ 6种连接 物理输入→世界 世界→物理输出 物理输入→虚拟界面 虚拟界面→世界 世界→虚拟界面 虚拟界面→物理输出 六十号透镜：物理界面 ​ 玩家会和你的游戏产生物理互动。抄袭现有的物理界面会是一个很容易跌落的陷阱。通过以下问题可以用这个透镜来确认你的物理界面是否适合你的游戏： 玩家捡起和接触了什么东西？是否能把这个过程做的更令人愉悦？ 游戏世界内的动作映射使如何的？这种映射是否可以做的更直接？ 如果你不能创造一个定制的物理界面，当你将输入映射到游戏世界时你使用哪种隐喻方式？ 在玩具透镜下，物理界面看上去是什么样的？ 玩家是怎么看到、听到和触碰游戏世界的？是否有方式可以集成某种物理输出设备使整个世界在玩家的想象种变得真是？ 六十一号透镜：虚拟界面 ​ 设计虚拟界面可能会非常微妙。做的不好，他们会变成玩家和游戏世界之间的一道墙。做的好，它们会放大玩家在游戏世界种的力量和控制。问自己这些问题确认你的虚拟界面在尽可能地提升玩家地体验： 玩家必须接收哪些光靠观察游戏世界而无法明确获取地信息？ 玩家何时需要这些信息？一直？还是只是有时？或者只是在每关结尾？ 这些信息如何以一种不会打扰玩家与游戏世界互动动地方式传递给玩家？ 游戏世界里是否存在某些相比直接互动更容易通过虚拟界面互动的元素（如弹出菜单）？ 对于我的物理界面来说哪种虚拟界面更合适？比如弹出菜单对于游戏手柄来说是一种很差的匹配。 六十二号透镜：透明 ​ 理想的界面对玩家来说是隐形的，它可以使玩家的想象完全沉浸入游戏世界。为了确保不可见性，问自己以下的问题： 玩家的欲望是什么？界面是否让玩家做了他们想做的事？ 这个界面是否足够简单到玩家通过练习后可以不用思考直接使用？ 新的玩家是否觉得这个界面直观？如果不是，它是否可以用某种方法做到更直观？如果让玩家可以定制操作方式会起到帮助还是伤害的作用？ 界面是否在所有情况下都工作良好或者是否存在某些情况下（靠近一个角落、走得非常块等）它的行为会使玩家迷惑？ 在紧张的情况下玩家是否可以继续良好地使用界面。或者他们开始笨拙地摸索如何操控或者遗漏了关键信息？如果是这样，如何改善它？ 界面是否有任何迷惑玩家地地方？6个界面箭头中的哪一个有这种情况？ 当玩家使用界面时是否有沉浸感？ 互动循环 六十三号透镜：反馈 ​ 一个玩家从游戏中得到的反馈有很多种：判断、奖励、指导、鼓舞以及挑战。用这个透镜来确认你的反馈回路正在创造你想要的体验，随时随地在你游戏中问自己以下这些问题： 在这个时刻玩家应该知道什么？ 在这个时刻玩家想要知道什么？ 在这个时刻你想要玩家感受到什么？你如何给出能够创造这种感受的反馈？ 在这个时刻玩家希望感受到什么？对他们来说是否有机会创造这样一个能使他们获得这种感受的情境？ 在这个时候玩家的目标是什么？哪种反馈会帮助他们达到这个目标？ 有趣 六十四号透镜：多汁 ​ 人们常用“干燥”来形容一个几乎没有任何反馈的界面。在你开始使用多汁界面的那一刻起多汁界面就很有趣。为了最大化它的多汁，问你自己这些问题： 我的界面对玩家的动作给予持续的反馈了吗？如果没有，为什么没有？ 二级运动是由玩家的动作创造的吗？这个二级运动是否有利且有趣？ 多汁系统以多少种方式在奖励他们？我可以找到更多的方式吗？ ​ 触摸屏表现出了让人吃惊地容易上手，原始工具便是触摸着操作。 六十五号透镜：原始性 ​ 一些动作和界面是如此的直观，连动物都在几亿年前就在做这些动作。为了捕捉到原始性的力量，问你自己这些问题： 我的游戏中的哪些部分是如此的原始连动物都可以玩？为什么？ 我的游戏中的哪些部分可以做的更原始 信息通道​ 在游戏中展现信息的最佳方式： 列表与优先信息 列表通道（可理解为显示区域） 将信息映射到通道（可理解为将信息显示出来） 检验维度的使用（同一种信息如数字的不同维度，如字号，颜色） 六十六号透镜：通道和维度 ​ 选择如何将游戏信息映射到通道和维度是设计游戏界面的核心。使用这个透镜来确认你深思熟虑并且优秀地做到了这一点。问你以下这些问题： 哪些数据需要在玩家这儿往来？ 哪个数据是最重要地？ 我可以用哪些通道来传输这些数据？ 哪些通道对于那些数据来说最合适？为什么？ 这些不通地通道上哪些维度是可用的？ 我该如何使用这些维度？ 模式建议： 使用尽可能少的模式 避免模式叠加 制作尽可能不同的差异模式 该百年屏幕上巨大且可视的东西 改变你人物所采取的行动 改变屏幕上的数据 改变镜头视角 六十七号透镜：模式 ​ 任何复杂的界面都需要模式。为了确保你的模式让玩家感到有力和控制感并且不要使他们疑惑或不知所措，问你自己这几个问题： 我的游戏中需要什么模式？为什么？ 有些模式是否可以折叠或者合并？ 是否有些模式重叠了？如果是这样，我是否可以把它们放到不同的输入频道？ 当游戏改变模式，玩家怎么知道？游戏是否可以用不止一种的方式来传递模式改变的信息？ 其他关于界面的建议 偷窃 定制 围绕你的物理界面设计 主题化你的界面 将声音映射到触摸 用层级平衡选项和简单度 使用隐喻 如果它看上去不同，它的行为也应该不同 测试 打破不能帮助玩家的法则第十六章 体验可以用它们的兴趣曲线来评价兴趣曲线​ 娱乐体验是一系列时刻，其中的一些时刻比其他的更强大，根据兴趣曲线排列这些时刻往往能达到更好的效果。 六十八号透镜：时刻 ​ 值得纪念的时刻是组成你兴趣曲线星座的星星。为了能够绘制这些最重要的东西，问你自己以下这些问题： 我的游戏中最重要的时刻有哪些？ 我如何能够让每一个时刻尽可能的强大？ 六十九号透镜：兴趣曲线 ​ 究竟什么东西可以吸引人们地心神通常看上去是因人而异地，但是大部分让人愉悦地那种吸引模式对于每个人来说确实明显地相似。为了看出你给出地体验中一个玩家地兴趣是如何随着时间变化地，问你自己这些问题： 如果我画一张我的体验地兴趣图，它的大致形状是如何的？ 它有钩子吗？ 它是否拥有逐渐提升的兴趣并由阶段性的休息间隔开？ 它是否拥有一个比其他一切更有趣的一个大结局？ 什么改变会给我一条更好的兴趣曲线？ 我的兴趣曲线是否拥有一个碎片化的组织？它应该存在吗？ 我关于兴趣曲线的直觉是否符合我观察到的玩家的兴趣？如果我让试玩人员画一条兴趣曲线，它看上去是什么样子的呢？ 可与19号兴趣透镜一同使用兴趣组成 内在兴趣 七十号透镜：内部兴趣 ​ 有些事情就是有趣。通过问这些问题你可以使用这个透镜来确认你的游戏是否拥有内在兴趣品质； 我的游戏的哪些方面会立刻吸引玩家兴趣？ 我的游戏会让玩家做或看一些他们从没见过或做过的东西吗？ 我的游戏会吸引哪些基础本能？它是否可以吸引更多的基础本能呢？ 我的游戏会吸引哪些更高层次的本能？它是否可以吸引更多的高层次本能呢？ 戏剧性变化和对这种变化的期待是否会在我的游戏中发生？怎样可以让它变得更具戏剧性？ 演出的诗歌艺术 七十一号透镜：美丽 ​ 美丽是神秘的。举例来说，为什么大部分美的事物都有一点悲伤的味道？通过问以下这些问题来使用这个透镜注视你游戏中美丽的神秘之处： 我的游戏是由哪些元素组成的？每一个元素如何能变得更加美丽？ 一些东西它们本身并不美丽，但是组合起来就很漂亮。我的游戏中的元素如何才能编绘得既富有诗意又美丽？ 在我的游戏得上下文中，美丽意味着什么？ 投影 七十二号透镜：投影 ​ 某人正在享受一段体验得一个关键指标是他们将自己得想象投影进了体验中。当他们这么做得时候，他们对体验得享受以一种良性循环得方式快速增长。为了检查你的游戏是否合适地引导了玩家地投影，问你自己这几个问题： 我的游戏中有什么可以让玩家和自身联系起来的东西？除此之外我还可以添加什么？ 我的游戏中有什么可以抓住玩家想象力的东西》除此之外我还可以添加什么？ 游戏中有什么地方是玩家一直希望前往的？ 玩家是否可以成为一个他们一直想象自己能够成为的人物？ 游戏中是否还有别的玩家会感兴趣遇见（或者监视）的人物？ 玩家是否可以做那些他们在现实生活中想做而不能做的事？ 游戏中是否有一个玩家一旦开始做就很难停下的行动？ 有种体验叫做故事 七十三号透镜：故事机器 ​ 一个好的游戏是当人们玩它的时候它是一台能够生产故事的机器，为了确保你的故事能够尽可能高产，问你自己这些问题： 当玩家在如何达到目标时又不同的选择，新的不同的故事会产生。我如何才能添加更多的这种选择呢？ 不同的矛盾导致不同的故事。我怎么才能让更多种类的矛盾从我的游戏中产生？ 当玩家可以个性化角色和设定时，他们会更关心故事的结果，类似的故事会开始感觉非常不同。你怎么才能让玩家个性化故事呢？ 好的故事拥有好的兴趣曲线。我的规则能导致故事拥有好的兴趣曲线吗？ 一个故事只有在你能讲述它的时候才是一个好故事。 问题 好的故事是统一的 组合爆炸 多重结局让人失望 动词不够 时间旅行使悲剧过时给游戏设计师的故事秘诀 目标、障碍和冲突 七十四号透镜：障碍 ​ 一个没有障碍的目标并不值得追寻。使用这个透镜来确保你的障碍是哪些你的玩家想要克服的。 主人公和目标之间存在什么关系？为什么主角会在意它？ 主角和目标之间的障碍是什么？ 在障碍背后是否存在一个对手？在主角和对手之间存在什么关系？ 障碍是否在逐渐增加难度？ 有些人说“障碍越大，故事越好”。你的障碍够大吗？它们能够变得更大吗？ 杰出的故事经常包含为了克服障碍主角发生了转变。你的主角是如何转变的？ 做到真实 时刻牢记：如果它对你来说不像真的，那对他们来说也是一样。 提供简单和超越 简单：游戏世界比真实世界简单 超越：玩家在游戏世界比真实世界更富有力量 例如： 中世纪 未来派 战争 现代 抽象 七十五号透镜：简单和超越emsp;为了确认你将简单和超越正确地组合，问你自己这些问题： 我的世界如何比真实世界更简单？用其他方法可否使它更简单？ 我给予玩家何种超越的力量？我如何可以在不去除游戏挑战的前提下给予玩家 更多的这种力量？ 我创造的简单与超越组合是否很不自然，或者它是否满足了我的玩家一种特别的愿望？ 参考英雄的旅程 沃格勒对于英雄的旅程的概要： 平凡世界 冒险的召唤 拒绝召唤 和导师见面 跨过大门 测试、同盟、敌人 接近洞窟——英雄遭遇挫折并且需要尝试一些新的东西 严峻的考验 奖励 回家的路——回到平凡世界，但问题未完全解决 重生——英雄面临一场更大的危机而且必须运用所有他已学到的东西 带着长生不老药回归——彻底结束 可结合使用六十九号透镜兴趣曲线 七十六号透镜：英雄的旅程 ​ 许多英雄都拥有类似的结构。使用这个透镜来确保你没有遗漏任何可能改进你的故事的元素。问你自己这些问题： 我的故事是否拥有能够使之称为英雄故事的元素？ 如果是这样，他如何匹配英雄的旅程的结构？ 我的故事是否可以通过加入更多典型元素的方法来改进？ 我的故事是否可以通过加入更多典型元素的方法来改进？ 我的故事是否和这个形式过于匹配以至于感觉上陈腐？ 开始使用你的故事 ​ 牢记一个故事可以变得如此的柔软、灵活、有力量——别怕将你的故事塑造成可以支持你认为最好的玩法的样子。 保持你故事世界的一致性 ​ 如果你有一组定义你的世界万物运行的规则，坚持它并认真对待它。 让你的故事世界平易近人 七十七号透镜：最奇怪的东西 你的故事里有奇怪的东西可以帮助给奇异的游戏机制赋予意义——它可以抓住玩家的兴趣而且可以让你的世界看上去特别。不过，太多太奇怪的东西会把你的故事渲染得费解并难以接近。为了确保你得故事是号得那种奇怪，问你自己这些问题： 我的故事里最奇怪的东西是什么？ 我怎么可以确保这最奇怪的东西不会迷惑活疏远玩家？ 如果有多件奇怪的东西，我是否应该去掉或合并其中的一些？ 如果我的故事里没有奇怪的东西，它依然有趣吗？ 明智地使用陈词滥调 ​ 尽管陈词滥调有着被滥用的危险，但它们拥有经常打的对玩家熟悉的优势，而熟悉就意味着可理解和可领会。有人说每一款成功的电子游戏都找到了一种将熟悉和创新组合在一起的方法。 ​ 过于使用陈词滥调是一个错误，但完全将它从你的工具箱内驱逐也是一个同样的错误。 有时一张地图能让故事活过来 ​ 大部分电子游戏并不发生在文字的世界里，而是在实体的地方。通过画这个地方的素描和图画，一般故事都会自然成型，因为你被迫去思考谁生活在那，他们在干什么以及为什么。 七十八号透镜：故事 ​ 问你自己这几个问题： 我的游戏真的需要一个故事吗？为什么？ 为什么玩家会对这个故事感兴趣？故事怎么去支持四元素中其他的部分（美学、技术、机制）？能优化它吗？ 四元组中其他的部分如何支持游戏？能优化它吗？ 怎样能使我的游戏变好？ 第十八章 故事和游戏结构可以用间接控制艺术性地融为一体自由的感觉 七十九号透镜：自由 ​ 自由感是区分游戏和其他娱乐形式地事物之一。为了确保你的玩家尽可能地感觉自由，问你自己这些问题： 我的玩家什么时候可以自由行动？这些时间里他们感觉到自由了吗？ 他们什么时候会被束缚？在这些时候他们感觉到被束缚了吗？ 游戏中是否有些地方我可以让他们比现在感觉更加自由？ 游戏中是否有些地方他们会因为过于自由而感到手足无措？ ​ 玩家拥有了美妙的自由感，而设计师也做到了经济地创造一场具有理想兴趣曲线又包含理想事件集合地体验。间接控制方法： 限制 目标 界面 视觉设计 角色 音乐 八十号透镜：帮助 ​ 本质上，每个人都愿意给予帮助。为了将这种乐于助人的精神引导向引人入胜的游戏玩法，问你自己这些问题： 在游戏的上下文内容里，玩家在帮助谁？ 我是否可以让玩家感觉需要帮助的角色内心联系得更紧密？ 我是否可以更好地讲述完成游戏目标可以帮助人地故事？ 被帮助角色如何可以表现出他们地感谢？ 八十一号透镜：间接控制 ​ 为了达到一种理想地游戏体验，每位设计师对于想要玩家做什么都有一个幻想。为了帮助确保玩家是完全凭着他们自由意愿做这些事，问你自己这几个问题： 最理想情况下，我想要玩家做什么？ 限制是否可以让玩家去做这件事？ 目标是否可以让玩家去做这件事？ 界面是否可以让玩家去做这件事？ 视觉设计是否可以让玩家去做这件事？ 游戏角色是否可以让玩家去做这件事？ 是否还有别地方法在不侵犯玩家的自由感前提下，我可以用来强迫玩家去进行理想中的行为？ 我的设计是否会降低玩家不该有的欲望？ 功成事遂，百姓皆谓我自然 八十二号透镜：串通 ​ 角色应该起到在游戏世界种的作用，但是如果可能的话，也应该作为游戏设计师的许多小分身向着它的最终目标努力工作，这也保证了它是一场对玩家来说迷人的体验。为了确保你的角色没有违背这个责任，问你自己这些问题： 我想要玩家体验什么？ 角色如何能够在不损害他们游戏世界的目标前提下帮助实现这种体验？ 第十九章 在世界里发生的故事与游戏跨媒体世界玩具、周边、影视玩具给了粉丝一个通往这个世界的入口 八十三号透镜：幻想 ​ 每个人都有不能说的愿望与欲求。为了确保你（创造）的世界能够满足它们，请问自己如下的问题： 我的世界能够满足什么幻想？ 我的玩家幻想成为什么样的人？ 我的玩家会幻想在那个世界里做些什么事情？ 成功的跨媒体世界有些什么共同点 它们常常扎根在一个单一的媒体里 它们很直观 它们的核心是富有创造力的个人 它们适合讲多个故事 它们可以通过任意一个入口去理解 它们常常与探索有关 它们与完成心愿有关 八十四号透镜：世界 ​ 你游戏的世界与游戏是分离的。你的游戏是一扇通向这个只存在于玩家想象力的神奇世界的大门。为了确保你的世界有足够的力量和完整性，请问你自己如下的问题： 我的世界在哪些方面比现实世界更胜一筹？ 能有多个通往该世界的入口存在吗？它们之间有什么不同？它们之间如何互相支持？ 我的世界是围绕一个单一的故事吗？有没有可能在其中发生多个故事？ 第二十章 世界种的角色化身： 由玩家在游戏里控制的角色是一个拥有神奇力量的角色，因此赋予它一个特殊的名字。那种角色适合玩家投射自己？ 理想型 白板 八十五号透镜：化身 ​ 化身是玩家进入游戏世界的入口。为了确保化身能展示出玩家尽可能多的身份特征，请问你自己如下的问题： 我创造的化身是不是一个能于玩家引起共鸣的理想型？ 我创造的化身有没有符号化的特性来让玩家将自己投射到那个角色中去？ 创造出令人信服的角色 八十六号透镜：角色功能 ​ 为了确保你的角色完成游戏所赋予它们的全部职责，请问你自己如下的问题： 我需要这些角色行使哪些功能？ 我已经想象了哪些角色？ 某角色与某功能是否很好地对应？ 能否让某一角色行使多个功能？ 我是否需要改变以下角色设定，来让它与功能对应得更好？ 我需要新的角色吗？ 八十七号透镜：角色特征 ​ 为了确保一名角色得特征在其言行中表现出来，请问你自己如下的问题： 是什么特征定义了我的角色？ 这些特征是如何表现在世界、角色的举止和容貌上的？ 八十八号透镜：人际关系环状图 ​ 理解角色之间的关系非常重要。一种方法是画一个直角坐标系，其中一根轴表示敌意/友好，另外一根轴表示服从/支配。选取一名角色进行分析，将其放在原点位置。思考其他角色相对于该角色所处的位置。" }, { "title": "你好，世界！", "url": "/posts/hello-world/", "categories": "随笔", "tags": "生活", "date": "2022-05-21 09:14:00 +0000", "snippet": "测试//代码片段int main(){ hello world;}    图片一直上传不上picgo，就只是因为仓库名打成ImgStge了，少了个a，然后又莫名放到了代码框里……", "content": "测试//代码片段int main(){ hello world;}    图片一直上传不上picgo，就只是因为仓库名打成ImgStge了，少了个a，然后又莫名放到了代码框里……" } ]
